/* This is a flex file for UCPM instruction lexer which cooperates with UCPM
 * instruction parser. This custom instruction lexer is a low-level, UCPM-specific
 * instruction lexer to analyze just one UCPM instruction line
 * (an VLIW instruction line). It is distinguished from LLVM platform generic
 * lexer and target-specific lexer. A similar description is created for UCPM
 * instruction parser.
 * See UCPMInstrParser.y for more details.
 */

%{
#include "UCPMGenInstrParser.h" // generated by bison, including definition of tokens and data types
#include <string>
#include "llvm/ADT/SmallString.h"
#include "llvm/MC/MCParser/AsmLexer.h"
#define SAVE_TOKEN yylval->string = new std::string(ucpmtext, ucpmleng)
#define TOKEN(t) (yylval->token = t)
#define YY_USER_ACTION                                                         \
  yylloc->S = TokStart;                                                        \
  yylloc->E = SMLoc::getFromPointer(yylloc->S.getPointer() + ucpmleng);    \
  TokStart = yylloc->E;
%}

/* list all needed compiling option so we can simplify makefiles */
/*%option outfile="UCPMGenInstrLexer.flex"
%option header-file="UCPMGenInstrLexer.h"*/

/*%option debug*/
/*%option trace*/
%option bison-bridge
%option bison-locations

%option prefix="ucpm"

/* yywrap() is a function to invoke for EOF. */
%option noyywrap

/* suppress stdout for unmatched input */
%option nodefault

/* suppress unput() */
%option nounput

%x EXPRPARSE PARENEXPRPARSE CONDPARSE

L   [a-zA-Z_]
A   [a-zA-Z_0-9]

%% /*---------------------------section delimiter--------------------------------*/

	/* register classes with lower-case names */
<EXPRPARSE>[ \t\n]                {;}
<EXPRPARSE>"("                    {BEGIN PARENEXPRPARSE;}
<EXPRPARSE>0[xX][[:xdigit:]]+                 { /* hex */
  BEGIN INITIAL;
  SAVE_TOKEN;
  yylval->val=strtol(yylval->string->substr(2).c_str(),0,16);
  return IMM5;
}
<EXPRPARSE>[1-9][0-9]*    { /* dec */
  BEGIN INITIAL;
  SAVE_TOKEN;
  yylval->val=atol(yylval->string->c_str());
  return IMM5;
}
<EXPRPARSE>0[01234567]+                       { /* oct */
  BEGIN INITIAL;
  SAVE_TOKEN;
  yylval->val=strtol(yylval->string->substr(1).c_str(),0,8);
  return IMM5;
}
<EXPRPARSE>0+                       { /* num '0' */
  BEGIN INITIAL;
  SAVE_TOKEN;
  yylval->val=0;
  return IMM5;
}

<EXPRPARSE>"abs"                  {BEGIN INITIAL; return TOKEN(ABS);}//yangl for imac abs
<EXPRPARSE>"t"[0-7]               {SAVE_TOKEN; yylval->val = atol((yylval->string->substr(1)).c_str()); BEGIN INITIAL; return TREG;}
<PARENEXPRPARSE>"ki"[0-9]+        {SAVE_TOKEN; yylval->val = atol((yylval->string->substr(2)).c_str()); BEGIN INITIAL; return KI;}
<EXPRPARSE>"ki"[0-9]+             {SAVE_TOKEN; yylval->val = atol((yylval->string->substr(2)).c_str()); BEGIN INITIAL; return KI;}
<EXPRPARSE>{L}{A}*                {
  BEGIN INITIAL;
  while (Lexer->getTok().getLoc() != yylloc->S) Lexer->Lex();
  SAVE_TOKEN;
  const MCExpr *Res;
  StringRef Identifier;
  SMLoc End = Lexer->getTok().getEndLoc();
  SMLoc Start = Lexer->getTok().getLoc();
  if (llvmParser->parseIdentifier(Identifier)) {
    llvmParser->TokError("Invalid Identifier");
    REJECT;
  }
  ucpm_flush_buffer(YY_CURRENT_BUFFER);
  MCSymbol *Sym = llvmParser->getContext().getOrCreateSymbol(Identifier); 
  if (Sym->isVariable() && isa<MCConstantExpr>(Sym->getVariableValue()))
    Res = Sym->getVariableValue();
  else
    Res = MCSymbolRefExpr::create(Sym, MCSymbolRefExpr::VK_None, llvmParser->getContext());
  yylval->op = UCPM::UCPMAsmOperand::createExpr(Res, Start, End);
  yylloc->S = Start;
  yylloc->E = End;
  TokStart = Lexer->getLoc();
  ucpmleng = End.getPointer() - Start.getPointer() + 1;
  CurLoc = Lexer->getLoc();
  return EXPR;
}
<PARENEXPRPARSE>[ \t\n]                {;}
<PARENEXPRPARSE>"!"                {return TOKEN(NEG);}
<PARENEXPRPARSE>"c"                {BEGIN INITIAL; return TOKEN(C);}
<PARENEXPRPARSE>[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+|"("|"-" {
  BEGIN INITIAL;
  while (Lexer->getTok().getLoc() != yylloc->S) Lexer->Lex();
  SAVE_TOKEN;
  SMLoc End;
  SMLoc Start = Lexer->getTok().getLoc();
  const MCExpr *IdVal = 0;
  if (llvmParser->parseExpression(IdVal, End)) {
    llvmParser->Error(Start, "Invalid expression");
    REJECT;
  }
  ucpm_flush_buffer(YY_CURRENT_BUFFER);
  if (Lexer->isNot(AsmToken::RParen)) {
    llvmParser->Error(End, "Right parenthesis is expected here: " + Twine(yylloc->S.getPointer()));
    REJECT;
  }
  llvmParser->Lex();
  CurLoc = Lexer->getLoc();
  yylloc->S = Start;
  yylloc->E = End;
  TokStart = Lexer->getLoc();
  ucpmleng = End.getPointer() - Start.getPointer() + 1;
  const MCConstantExpr *CE = dyn_cast<MCConstantExpr>(IdVal);
  if (!CE) {
    yylval->op = UCPM::UCPMAsmOperand::createExpr(IdVal, Start, End);
    return EXPR;
  }
  else {
    yylval->val = CE->getValue();
    if (yylval->val < 0) {
      llvmParser->Warning(Start, "Negative immediate is not allowed");
      return IMM5;
    }
    return IMM5;
  }
}
<PARENEXPRPARSE>.                {}

0[xX][[:xdigit:]]+                 { /* hex */
  BEGIN INITIAL;
  SAVE_TOKEN;
  yylval->val=strtol(yylval->string->substr(2).c_str(),0,16);
  return IMM5;
}
[1-9][0-9]*    { /* dec */
  BEGIN INITIAL;
  SAVE_TOKEN;
  yylval->val=atol(yylval->string->c_str());
  return IMM5;
}
0[01234567]+                       { /* oct */
  BEGIN INITIAL;
  SAVE_TOKEN;
  yylval->val=strtol(yylval->string->substr(1).c_str(),0,8);
  return IMM5;
}
0+                       { /* num '0' */
  BEGIN INITIAL;
  SAVE_TOKEN;
  yylval->val=0;
  return IMM5;
}
[ \t\n]                {;}
"->"                   {return TOKEN(ASSIGNTO);}
"=="                   {return TOKEN(EQU);}
"!="                   {return TOKEN(NEQ);}
"<"                    {return TOKEN(ST);}
"<="                   {return TOKEN(NLT);}
">"                    {return TOKEN(LT);}
">="                   {return TOKEN(NST);}
"("                    {return TOKEN(LPAREN);}
"{"                    {return TOKEN(LBRACE);}
"["                    {return TOKEN(LBRACKET);}//dcx
<CONDPARSE>"("         {BEGIN PARENEXPRPARSE; return TOKEN(LPAREN);}
<CONDPARSE>[ \t\n]     {;}
<CONDPARSE>.           {BEGIN INITIAL;}
")"                    {return TOKEN(RPAREN);}
"}"                    {return TOKEN(RBRACE);}
"]"                    {return TOKEN(RBRACKET);}//dcx
"."                    {return TOKEN(DOT);}
","                    {return TOKEN(COMMA);}
"+"                    {return TOKEN(ADD);}
"-"                    {return TOKEN(SUB);}
"*"                    {return TOKEN(MUL);}
"**"                   {return TOKEN(CMUL);}
"<-"                   {return TOKEN(ASSIGN);}



"<<"                   {return TOKEN(LSHT);} // {BEGIN EXPRPARSE; return TOKEN(LSHT);}
">>"                   {return TOKEN(RSHT);} // {BEGIN EXPRPARSE; return TOKEN(RSHT);}
"|"                    {return TOKEN(OR);}
"&"                    {return TOKEN(AND);}
"^"                    {return TOKEN(XOR);}
"not"                  {return TOKEN(NOT);}
"~"                    {return TOKEN(NOT2);}//dcx
"!"                    {return TOKEN(NEG);}
"+-"                   {return TOKEN(ADDSUB);}
"+="                   {BEGIN EXPRPARSE; return TOKEN(ACC1);}
"=+"                   {BEGIN EXPRPARSE; return TOKEN(ACC2);}
"-="                   {return TOKEN(SUBEQU);}
"@"                    {BEGIN CONDPARSE; return TOKEN(ALPHA);}
"||"                   {return TOKEN(SPLIT);}
";"                    {return TOKEN(LINEEND);}

"shu0"                   {return TOKEN(SHU0);}
"shu1"                   {return TOKEN(SHU1);}
"shu2"                   {return TOKEN(SHU2);}
"ialu"                   {return TOKEN(IALU);}
"_ialu"                   {return TOKEN(_IALU);}
"imac"                   {return TOKEN(IMAC);}
"_imac"                   {return TOKEN(_IMAC);}
"falu"                   {return TOKEN(FALU);}
"_ifalu"                 {return TOKEN(_IFALU);}
"fmac"                   {return TOKEN(FMAC);}
"ifalu"                   {return TOKEN(IFALU);}
"ifmac"                   {return TOKEN(IFMAC);}
"_ifmac"                   {return TOKEN(_IFMAC);}
"m"                      {return TOKEN(M);}
"mc"                     {return TOKEN(MC);} //yangl for imac flag
"mv"                     {return TOKEN(MV);} //yangl for imac flag
"ls"                     {return TOKEN(LS);} //yangl for imac flag
"erased"                 {return TOKEN(ERASE);} //yangl for imac flag
"biu0"                   {return TOKEN(BIU0);}
"biu1"                   {return TOKEN(BIU1);}
"biu2"                   {return TOKEN(BIU2);}
"r0"                     {return TOKEN(R0);}
"r1"                     {return TOKEN(R1);}
"r2"                     {return TOKEN(R2);}
"r3"                     {return TOKEN(R3);}
"r4"                     {return TOKEN(R4);}
"r5"                     {return TOKEN(R5);}
"mreg0"                     {return TOKEN(MREG0);}//dcx
"mreg1"                     {return TOKEN(MREG1);}//dcx
"mreg2"                     {return TOKEN(MREG2);}//dcx
"mreg3"                     {return TOKEN(MREG3);}//dcx
"mreg4"                     {return TOKEN(MREG4);}//dcx
"mreg5"                     {return TOKEN(MREG5);}//dcx
"biu"                    {return TOKEN(BIU);}
"i"[0-7]                 {SAVE_TOKEN; yylval->val = atol((yylval->string->substr(1)).c_str()); return IPATH;} 
"t"[0-7]                 {SAVE_TOKEN; yylval->val = atol((yylval->string->substr(1)).c_str()); return TREG;}
"m["[0-9]+"]"            {SAVE_TOKEN; yylval->val = atol((yylval->string->substr(2, ucpmleng-2)).c_str()); return MINDEXN;}



"s""++"  		 {return TOKEN(SPP);}//dcx  "m[s""++]"               {return TOKEN(MINDEXS);}"m[i""++]"               {return TOKEN(MINDEXI);}
"i""++"  		 {return TOKEN(IPP);}//dcx
"shift"                  {return TOKEN(SHIFT);}
"dis"                    {return TOKEN(DIS);}
"cond"                   {return TOKEN(COND);}
"setcond"                {return TOKEN(SETCOND);}//dcx
"tb"                     {return TOKEN(TB);}

"mpp"                    {return TOKEN(MPP);}
"mdis"                   {return TOKEN(MDIS);}

"tc0"                    {return TOKEN(TC0);}
"tc1"                    {return TOKEN(TC1);}
"tc2"                    {return TOKEN(TC2);}
"tc3"                    {return TOKEN(TC3);}
"tc4"                    {return TOKEN(TC4);}
"tc5"                    {return TOKEN(TC5);}
"tc6"                    {return TOKEN(TC6);}
"tc7"                    {return TOKEN(TC7);}
"tc8"                    {return TOKEN(TC8);}
"tc9"                    {return TOKEN(TC9);}
"tca"                    {return TOKEN(TCA);}
"tcb"                    {return TOKEN(TCB);}
"tcc"                    {return TOKEN(TCC);}
"tcd"                    {return TOKEN(TCD);}
"tce"                    {return TOKEN(TCE);}
"tcf"                    {return TOKEN(TCF);}

"ind"                    {return TOKEN(IND);}
"comb"                   {return TOKEN(BY);}
"cprs"                   {return TOKEN(CPRS);}
"expd"                   {return TOKEN(EXPD);}
"conj"                   {return TOKEN(CONJ);}//dcx
"minus"                  {return TOKEN(MINUS);}//dcx
"readq"                  {return TOKEN(READQ);}//dcx
"readr"                  {return TOKEN(READR);}//dcx
"divstart"               {return TOKEN(DIVSTART);}//dcx
"divcont"                {return TOKEN(DIVCONT);}//dcx
"start"                  {return TOKEN(START);}
"stop"                   {return TOKEN(STOP);}
"max"                    {return TOKEN(MAX);}
"min"                    {return TOKEN(MIN);}
"abs"                    {return TOKEN(ABS);}
"merge"                  {return TOKEN(MERGE);}
"mdivr"                  {return TOKEN(MDIVR);}
"mdivq"                  {return TOKEN(MDIVQ);}
"divr"                   {return TOKEN(DIVR);}
"divq"                   {return TOKEN(DIVQ);}
"divs"                   {return TOKEN(DIVS);}
"rmax"                   {return TOKEN(RMAX);}
"rmin"                   {return TOKEN(RMIN);}
"radd"                   {return TOKEN(RADD);}//dcx
"rsub"                   {return TOKEN(RSUB);}//haoxb

"recip"                  {return TOKEN(RECIP);}
"rsqrt"                  {return TOKEN(RSQRT);}
"single"                 {return TOKEN(SINGLE);}
"double"                 {return TOKEN(DOUBLE);}
"mr"                     {return TOKEN(MR);}
"int"                    {return TOKEN(INT);}
"repeat"                 {return TOKEN(REPEAT);}
"lpto"                   {BEGIN EXPRPARSE; return TOKEN(LOOP);}
"jump"                   {BEGIN EXPRPARSE; return TOKEN(JMP);}
"mpustop"                {return TOKEN(MPUSTOP);}
"br"                     {return TOKEN(BR);}
"cr"                     {return TOKEN(CR);}
"a""++"                  {return TOKEN(APP);}
"k""++"                  {return TOKEN(KPP);}
"ql"                     {return TOKEN(QL);}//dcx
"qh"                     {return TOKEN(QH);}//dcx
"q"                      {return TOKEN(Q);}//dcx
"ml"                     {return TOKEN(ML);}//dcx
"mh"                     {return TOKEN(MH);}//dcx
"mask"                   {return TOKEN(MASK);}//dcx
"wait"                   {return TOKEN(WAIT);}//dcx
"bit"                    {return TOKEN(BIT);}//dcx
"byte"                   {return TOKEN(BYTE);}//dcx
"w0"			 {return TOKEN(W0);}//dcx
"w1"			 {return TOKEN(W1);}//dcx
"w2"			 {return TOKEN(W2);}//dcx
"w3"			 {return TOKEN(W3);}//dcx
"w4"			 {return TOKEN(W4);}//dcx
"k"   			 {return TOKEN(K);}//dcx
"if"   			 {return TOKEN(IFIF);}//dcx
"on"   			 {return TOKEN(ON);}//dcx
"off"   		 {return TOKEN(OFF);}//dcx
"setcg"   		 {return TOKEN(SETCG);}//dcx
"st"   		         {return TOKEN(SIGNEDT);}//dcx
"hh"   		         {return TOKEN(HH);}//dcx
"ll"   		         {return TOKEN(LL);}//dcx
"hl"   		         {return TOKEN(HL);}//dcx

"vplus"   		 {return TOKEN(VPLUS);}//dcx

"round"   		 {return TOKEN(ROUND);}//huhh
"dis" 			 {return TOKEN(DIS);}//huhh
"by" 			 {return TOKEN(BY);}//huhh
"odd" 			 {return TOKEN(ODD);}//huhh
"stepext" 		 {return TOKEN(STEPEXT);}//huhh
"restepext" 		 {return TOKEN(RESTEPEXT);}//huhh
"o" 		         {return TOKEN(O);}//huhh
"z" 		         {return TOKEN(Z);}//huhh
"to" 		         {return TOKEN(TO);}//huhh

"invert"   		 {return TOKEN(INVERT);}//dcx
"km"   			 {return TOKEN(KM);}//dcx
"kg"   			 {return TOKEN(KG);}//dcx
"ke"   			 {return TOKEN(KE);}//dcx
"kmenable"   		 {return TOKEN(KMEABLE);}//dcx
"kgcurrent"   		 {return TOKEN(KGCURRENT);}//dcx
"l1"   			 {return TOKEN(L1);}//dcx
"l2"   			 {return TOKEN(L2);}//dcx
"l3"   			 {return TOKEN(L3);}//dcx
"l4"   			 {return TOKEN(L4);}//dcx
"all"   		 {return TOKEN(ALL);}//dcx
"configbiu" 		 {return TOKEN(CONFIGBIU);}//dcx
"configmfetch" 		 {return TOKEN(CONFIGMFETCH);}//dcx
"configmr" 		 {return TOKEN(CONFIGMR);}//dcx
"configmw" 		 {return TOKEN(CONFIGMW);}//dcx
"flag" 			 {return TOKEN(FLAG);}//dcx
"writeflag"		 {return TOKEN(WRITEFLAG);}//dcx
"clearmr"	  	 {return TOKEN(CLEARMR);}//yangl
"setsm" 		 {return TOKEN(SETSM);}//yangl:set shift mode
"?"                      {return TOKEN(TRIPLE);} //yangl:for imac triple
":"			 {return TOKEN(COLON);} //yangl:for imac triple
"n" 			 {return TOKEN(N);}//dcx
"v" 			 {return TOKEN(V);}//dcx
"a" 			 {return TOKEN(A);}//dcx
"a1" 			 {return TOKEN(A1);}//haoxb
"a2" 			 {return TOKEN(A2);}//haoxb
"mfetch" 		 {return TOKEN(MFETCH);}//dcx
"all2"   		 {return TOKEN(ALL2);}//haoxb
"mr0"   		 {return TOKEN(MR0);}//haoxb
"mr1"   		 {return TOKEN(MR1);}//haoxb
"mr2"   		 {return TOKEN(MR2);}//haoxb
"mr3"   		 {return TOKEN(MR3);}//haoxb
"mr4"   		 {return TOKEN(MR4);}//haoxb
"mr5"   		 {return TOKEN(MR5);}//haoxb
"mw0"   		 {return TOKEN(MW0);}//haoxb
"mw1"   		 {return TOKEN(MW1);}//haoxb
"mw2"   		 {return TOKEN(MW2);}//haoxb
"mw3"   		 {return TOKEN(MW3);}//haoxb
"mw4"   		 {return TOKEN(MW4);}//haoxb
"mw5"   		 {return TOKEN(MW5);}//haoxb
"configlatch" 		 {return TOKEN(CONFIGLATCH);}//haoxb

"rp0"                    {return TOKEN(RP0);}//haoxb
"rp1"                    {return TOKEN(RP1);}//haoxb
"rp2"                    {return TOKEN(RP2);}//haoxb
"rp3"                    {return TOKEN(RP3);}//haoxb
"rp4"                    {return TOKEN(RP4);}//haoxb
"rp5"                    {return TOKEN(RP5);}//haoxb
"rp0-2"                  {return TOKEN(RP02);}//haoxb
"rp3-5"                  {return TOKEN(RP35);}//haoxb
"wp0"                    {return TOKEN(WP0);}//haoxb
"wp1"                    {return TOKEN(WP1);}//haoxb
"wp2"                    {return TOKEN(WP2);}//haoxb
"wp3"                    {return TOKEN(WP3);}//haoxb
"wp4"                    {return TOKEN(WP4);}//haoxb
"wfromrp0"               {return TOKEN(WFROMRP0);}//haoxb
"wfromrp3"               {return TOKEN(WFROMRP3);}//haoxb
"wpall"                    {return TOKEN(WPALL);}//haoxb
"rpall"                    {return TOKEN(RPALL);}//haoxb


"modadd"                   	{return TOKEN(MODADD);}//dcx
"modsub"                    	{return TOKEN(MODSUB);}//dcx
"signed"                  	{return TOKEN(SIGNED);}//dcx
"maskgen"                    	{return TOKEN(MASKGEN);}//dcx
"bitfilter"                     {return TOKEN(BITFILTER);}//dcx
"bitexpd"                   	{return TOKEN(BITEXPD);}//dcx
"count"                  	{return TOKEN(COUNT);}//dcx
"first"                    	{return TOKEN(FIRST);}//dcx
"compsel"                   	{return TOKEN(COMPSEL);}//dcx
"sel"                    	{return TOKEN(SEL);}//dcx
"e"                   	 	{return TOKEN(E);}//dcx
"g"                   	 	{return TOKEN(G);}//dcx
"x"                    		{return TOKEN(X);}//dcx
"sign"                   	{return TOKEN(SIGN);}//dcx
"comp"                    	{return TOKEN(COMP);}//dcx
"find"                    	{return TOKEN(FIND);}//dcx
"turbo"                    	{return TOKEN(TURBO);}//dcx
"turbo1"                    	{return TOKEN(TURBO1);}//dcx
"turbo2"                    	{return TOKEN(TURBO2);}//dcx
"flagcheck"                    	{return TOKEN(FLAGCHECK);}//dcx

"p1"                    	{return TOKEN(P1);}//dcx
"p2"                    	{return TOKEN(P2);}//dcx
"as"                      	{return TOKEN(AS);}//dcx

"ki12-15"   			 {return TOKEN(KI1215);}//dcx
"ki16-19"   			 {return TOKEN(KI1619);}//dcx
"ki20-23"   			 {return TOKEN(KI2023);}//dcx
"ki24-27"   		 	 {return TOKEN(KI2427);}//dcx
"ki12-27"   			 {return TOKEN(KI1227);}//dcx
"ki16-18"   			 {return TOKEN(KI1618);}//dcx
"ki20-22"   			 {return TOKEN(KI2022);}//dcx
"ki24-26"   			 {return TOKEN(KI2426);}//dcx
"ki"   				 {return TOKEN(KII);}//dcx
"ki23"   			 {SAVE_TOKEN; yylval->val = 23; return KI23;}//dcx
"ki19"   			 {SAVE_TOKEN; yylval->val = 19; return KI19;}//dcx

"reg"[0-3]  			 {SAVE_TOKEN; yylval->val = atol((yylval->string->substr(3)).c_str()); return REG;}//dcx
"writereg"[0-3]   		 {SAVE_TOKEN; yylval->val = atol((yylval->string->substr(8)).c_str()); return WRITEREG;}//dcx

"="   				 {return TOKEN(ASSIGNMENT);}//dcx

"u"                      {return TOKEN(U);}
"p"                      {return TOKEN(P);}
"r"                      {return TOKEN(R);}
"t"                      {return TOKEN(T);}
"shift"                  {return TOKEN(SHIFT);}//huhh
"shiftmode0"                 {return TOKEN(SHIFTMODE0);}
"shiftmode1"                 {return TOKEN(SHIFTMODE1);}
"shiftmode2"                 {return TOKEN(SHIFTMODE2);}
"shiftmode3"                 {return TOKEN(SHIFTMODE3);}
"send"                   {return TOKEN(SEND);}
"ci"                     {return TOKEN(CI);}
"f"                      {return TOKEN(F);}
"b"                      {return TOKEN(B);}
"h"                      {return TOKEN(H);}
"s"                      {return TOKEN(S);}
"w"			 {return TOKEN(W);}//yangl, for imac triple b/s/w flag
"float"                  {return TOKEN(FLOAT);} //dcx
"imm"                    {return TOKEN(IMMSYM);} //dcx
"("[ \t]*"mode0"[ \t]*")" 		 {return TOKEN(MODE0);}//dcx
"("[ \t]*"mode1"[ \t]*")" 		 {return TOKEN(MODE1);}//dcx
"("[ \t]*"!mode0"[ \t]*")" 		 {return TOKEN(NMODE0);}//dcx
"("[ \t]*"!mode1"[ \t]*")" 		 {return TOKEN(NMODE1);}//dcx
"d"                      {return TOKEN(D);}
"i"                      {return TOKEN(I);}
"di"                     {return TOKEN(DI);}//dcx
"ei"                     {return TOKEN(EI);}//dcx
"c"                      {return TOKEN(CFLAG);}
"l"                      {return TOKEN(L);}
"tc"                     {return TOKEN(TC);}
"ki"[0-9]+               {SAVE_TOKEN; yylval->val = atol((yylval->string->substr(2)).c_str()); return KI;}
"wf"[1-3]+               {SAVE_TOKEN; yylval->val = atol((yylval->string->substr(2)).c_str()); return WFLAG;}
"wx"[1-4]+               {SAVE_TOKEN; yylval->val = atol((yylval->string->substr(2)).c_str()) + 3; return WFLAG;}
"true"                   {return TOKEN(TRUE);}
"nop"                    {return TOKEN(NOOP);}
"uint"                   {return TOKEN(UINT);}
"dm"                     {return TOKEN(DM);}
"readflag"               {return READFLAG;}//yangl
"readmr"                 {return READMR;}//yangl
"setmr"                  {return SETMR;}//yangl
"readxorreg"             {return READXOR;}//yangl
"settisflag"             {return SETTISFLAG;}//yangl for imac SetTIsFLAG
{L}{A}*                  {SAVE_TOKEN; return IDENTIFIER;}
.                        {}
%%
