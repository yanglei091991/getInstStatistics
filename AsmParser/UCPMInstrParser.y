                   %{
//#define YYDEBUG 1//ducx                   
#include <string>
#include <bitset>

std::bitset<128> flags;
static unsigned int flagsort;
static bool isTnValid = true;//yangl:a symbol to mark if Tn in imac multiplication is "1"
static bool isTpValid = true;//yangl:a symbol to mark if Tp in imac MulAA is "0"
static bool isTpMR = false;//yangl:a symbol to mark if Tp in imac MulAA is "MR"
static bool isTpMR_toMR = false;//yangl:a symbol to mark if Tp in imac MulAA is "MR", and like "MR+=/-="
//yangl:a symbol to mark it's abs() instruction of IMAC
static bool isIMACABS = false;
//yangl: a symbol to mark if there is double dest for IMAC
static int imac_additional_dest = 0;
//yangl: to replace imac single dest's return value, i.e. imacdest's $$=xxx
static int imac_dest_return_value = -1;
static int ImacMulAA_addsub, ImacMuAA_BSflag;//IMAC MulAA flags
//yangl: if imac or ifmac inst
//extern bool llvm::is_ifmac;
static unsigned uImacFlag = 0;//yangl: for imac flag: B/S/R/I, or B/S/W

static bool isIALUDoubleDest = false;//ducx
//static bool isIMACDoubleDest = false;//niuxx
//static bool isIFALUDoubleDest = false;//haoxb
static bool isSHU0DoubleDest = false;//huhh
static bool isSHU1DoubleDest = false;//huhh
static bool isSHU2DoubleDest = false;//huhh
static bool isSetCond = false;//ducx
static int ImacToialu_flag;//ducx
static bool hasErr = false;//ducx

void clear();

const unsigned HF=1, UF=2, TF=3, SF=4, DF=5, IF=6, LF=7, APPF=8, KPPF=9, CRF=10, BRF=11, MF=12, MLF=13, MHF=14, NCF=15, 
               CIF = 16, FF = 17, BF=18, PF = 19, RF = 20, CF = 21, SENDF = 22, S0F = 23, S1F = 24, S2F = 25, S3F = 26, SSF=27, QF=28, QLF=29, QHF=30, dLF=31, dHF=32, dMLF=33, dMHF=34, SPPF=35, IPPF=36,
               W0F = 37, W1F=38, W2F = 39, W3F = 40, W4F = 41, APPF2 = 42, KMF=43, KGF=44, KMEABLEF=45, KGCURRENTF=46, KEF=47, L1F=48, L2F=49, L3F=50, L4F=51, ALLF =52, KI0F= 53, KI1F=54, KI2F=55, KI3F=56, KI4F=57,
               KI5F =58, KI6F=59, KI7F=60, NF=61, VF=62, AF=63, SHIFTF=64, EIF=65, DIF=66,ROUNDF=67, ALL2F=68, MR0F=69, MR1F=70, MR2F=71, MR3F=72, MR4F=73, MR5F=74, MW0F=75, MW1F=76, MW2F=77, MW3F=78, MW4F=79, MW5F=80,
               KR0F=81,  KR1F=82,  KR2F=83, KR3F=84, KR4F=85, KR5F=86, KR6F=87, KR7F=88, KW0F=89, KW1F=90, KW2F=91, KW3F=92, KW4F=93, KFROM0F=94, KFROM3F=95, KWPALLF=96, KRPALLF=97,A1F=98,A2F=99, NOT1F = 100, NOT2F = 101, WF = 102, ODDF = 103, OF = 104, ZF = 105, 
               MCF = 106, MVF = 107, LSF = 108, ERASEF = 109, EF = 110, XF = 111,FLAGF = 112, GF=113, P1F=114, P2F=115, ONF=116, OFFF=117, HHF=118, LLF=119, HLF=120;

               
               
static UCPM::UCPMAsmOperand *opc, *tm, *tn, *tp, *tk,*tl,*ts, *revt, *f, *ff,*rf, *shift, *step, *qlh, *sia, *unit, *unit2, *unit3, *unit4, *ut, *b, *b2, *md, *ms, *imm,*imm1,*imm2, *expr, *ipath,*treg, *dis;//unit2, b2 are used as alternative unit, such as MReg Target
static UCPM::UCPMAsmOperand *oImacFlag;////yangl: for imac flag: B/S/R/I, or B/S/W
static int slotid;
static unsigned condpos;
SMLoc FlagS, FlagE;
llvm::raw_ostream &OS = errs();
%}
//??? CRF is remained to be fixed!!!
%code requires {
//Try to trace token's location in terms of LLVM SMLoc
#if !YYLTYPE_IS_DECLARED
typedef struct YYLTYPE {
  SMLoc S;
  SMLoc E;
} YYLTYPE;
#define YYLTYPE_IS_DECLARED 1
#endif
#define YYLLOC_DEFAULT(Current, Rhs, N)               \
  do                                                  \
    if (N) {                                          \
      (Current).S = YYRHSLOC(Rhs, 1).S;               \
      (Current).E = YYRHSLOC(Rhs, N).E;               \
    }                                                 \
    else                                              \
      (Current).S = (Current).E = YYRHSLOC(Rhs, 0).S; \
  while (0)
}

%locations

//%output  	"UCPMGenInstrParser.bison"
%defines 	"UCPMGenInstrParser.h"
%define api.pure
%name-prefix="ucpm"

%parse-param { OperandVector &Operands }

%union {
	UCPM::UCPMAsmOperand* op;
  std::string *string;
  int val;
  int token;
}
%token <val> NEGIMM IMM3 IMM IMM5 ASSIGNTO EQU NEQ ST NLT LT NST LPAREN RPAREN LBRACE RBRACE LBRACKET RBRACKET DOT MASK WAIT COMMA ADD SUB MUL CMUL LSHT RSHT
%token <val> OR AND XOR NOT NOT2 NEG MODE0 MODE1 NMODE0 NMODE1 ADDSUB ACC1 ACC2 SUBEQU ALPHA SPLIT LINEEND SHU0 SHU1 SHU2 BIU0 BIU1 BIU2 M COND SETCOND
%token <val> IALU IMAC FALU FMAC IFALU IFMAC TB TC0 TC1 TC2 TC3 TC4 TC5 TC6 TC7 TC8 TC9 TCA TCB TCC TCD TCE TCF IND BY
%token <val> CPRS EXPD CONJ MINUS READQ READR DIVSTART DIVCONT START STOP MAX MIN ABS MERGE MDIVR MDIVQ DIVR DIVQ DIVS RECIP RSQRT SINGLE DOUBLE MR INT RMAX RMIN RADD RSUB
%token <val> REPEAT LOOP JMP MPUSTOP REG WRITEREG CLEARMR TRIPLE COLON
%token <val> BR CR APP KPP SPP IPP CI F U P R T B H S W D I L TC C CFLAG LABEL SHU BIU SHIFT SHIFTMODE0 SHIFTMODE1 SHIFTMODE2 SHIFTMODE3 SEND FLOAT Q QL QH ML MH BIT BYTE
%token <val> TRUE ASSIGN ASSIGNMENT NOOP UINT DM R0 R1 R2 R3 R4 R5 IPATH WFLAG KM KE KG KMEABLE KGCURRENT L1 L2 L3 L4 ALL CONFIGBIU CONFIGMFETCH CONFIGMR CONFIGMW CONFIGLATCH
%token <string> IDENTIFIER
%token <op> EXPR
%token <val> N V A  A1 A2 FLAG WRITEFLAG IFIF KI23 KI19
%token <val> W0 W1 W2 W3 W4 K IMMSYM MREG0 MREG1 MREG2 MREG3 MREG4 MREG5 KI1215 KI1619 KI2023 KI2427 KI1227 KI1618 KI2022 KI2426 
%token <val> ROUND ALL2 MR0 MR1 MR2 MR3 MR4 MR5 MW0 MW1 MW2 MW3 MW4 MW5 
%token <val> RP0 RP1 RP2 RP3 RP4 RP5  RP02  RP35 WP0 WP1 WP2 WP3 WP4 WFROMRP0 WFROMRP3 WPALL RPALL

//add token here for ducx!!!
%token <val> TREG MODADD MODSUB DestSHU0 DestSHU1 DestSHU2 SIGNED MASKGEN BITFILTER BITEXPD COUNT FIRST COMPSEL E X SIGN SEL COMP FIND _IFMAC G VPLUS P1 P2 AS ON OFF SETCG SIGNEDT HH LL HL TURBO TURBO1 TURBO2 FLAGCHECK
//add token here for huhh!!!
%token <val> MINDEXN ODD STEPEXT RESTEPEXT O Z TO
//add token here for haoxb!!!
%token <val> KI _IALU _IFALU
//add token here for yangl!!!
%token <val> KII READFLAG MC MV LS ERASE READMR SETMR READXOR SETTISFLAG _IMAC


%token <val> DIS INVERT SETSM
%token <val> EI DI MFETCH MPP MDIS

%type <val> slots slotref slot 
%type <val> mr012345slot shuslot shu0code shu1code shu2code shu0inst shu1inst shu2inst biu0t biu1t biu2t shut shu0t shu1t shu2t  biuslot biu0code biu1code biu2code biu0inst biu1inst biu2inst seqslot 
%type <val> r0inst r1inst r2inst r3inst r4inst r5inst maccdestp maccdest ialut imact ifalut ifmact shu0te shu1te shu2te b1shu2te b2shu1te ialute imacte ifalute ifmacte s1biu1t s2biu1t bbiu0te bbiu1te bbiu2te 
//%type <val> sshu0t sshu1t sshu2t
%type <val> shuwaitInstr ialuwaitInstr 
%type <val> ucpshusrcTm ucpindtkclause ucpshusrcTk ucpindtbclause ucpshuexp ucpindclause shu0dest shu1dest shu2dest mindexn w_mindexn mindexsia mindexdis w_mindexsia w_mindexdis ialuasclause biu0dest biu1dest biu2dest 
//%type <val> ucpindtkclause2 ucpindtbclause2 ucpshuexp2 ucpindclause2 
%type <val> imacbiut0 imacbiut1 imacbiut2 imacsetshiftclause

%type <val> ialu_dest 
%type <val> shu0_shu0dest shu1_shu1dest shu2_shu2dest
%type <val> ialudest ifaludest imacdest ifmacdest biut imacmaclause imacflagclause ifmacclause 
%type <val> ialu imac falu fmac ifalu ifmac imm imm1 imm2 imm5 mcodeline hmacro _flag flag_ constt _constt
%type <val> ldselect lddis ldstep stinst binInstr shiftInstr compareInstr notInstr movInstr maskInstr waitInstr imm0Instr imm1Instr imm2Instr biu0imm biu1imm biu2imm setcond0Instr setcond1Instr setcond2Instr biu0cond biu1cond biu2cond
%type <val> reinst repeatexp immrep kirep lpinst lpexp lpcond label mpustop condflag kiflagtol
%type <val> shu0setcondInstr shu1setcondInstr shu2setcondInstr shu0cond shu1cond shu2cond r0setcondInstr r1setcondInstr r2setcondInstr r3setcondInstr r4setcondInstr r5setcondInstr ialusetcondInstr ialucond
%type <val> sbiu1t sbiu2t biushute bshu0te bshu1te bshu2te r1configmfetch r4configmfetch r0Toconfigmr r3Toconfigmw configmrTor0 configmwTor3  configlatch
%type <val> iaddclause isubclause imaclogicclause


//add value here for ducx!!!
%type <val> addexp ialudestTol _ialut imacASclause imacASdest ifmacASdest configbiu
//add value here for huhh!!!
%type <val> subexp shulogicclause shunotclause sandclause sorclause sxorclause snotclause shuimm_tbInstr shuimm_immInstr
%type <val> shubyteclause shubitclause shustepextclause stepextclause restepextclause shushift_Tclause shushift_IMMclause
%type <val> shu0_shu0TBdest shu1_shu1TBdest shu2_shu2TBdest shuadd_imm7 shuadd_tt ucpshuexp2 shu0destTol shu1destTol shu2destTol
//add value here for haoxb!!!
%type <val> shubiut ifalu_dest ifaludestTol _ifalut
//add value here for yangl!!!
%type <val> sbiu0t imacmaclause_0_tm_tn imacmaclause_mr_equ_tm_tn imacmaclause_mr_equ_tm_tn_inside imacMulAAclause t


%%
mcodeline: NOOP LINEEND {ADDOPERAND(Opc, UCPM::NOP, @1.S, @1.E); 
           int NumBuffers = llvmParser->getSourceManager().getNumBuffers();
           //llvm::UCPM::InputSrcBuffer = llvmParser->getSourceManager().getMemoryBuffer(NumBuffers)->getBuffer();
                 
           llvm::UCPM::LineNumber = llvmParser->getSourceManager().FindLineNumber(TokStart);
           slots_occupation_table[1] = true; YYACCEPT;}
|          slots LINEEND {YYACCEPT;};
mcodeline: NOOP error { llvmerror(&@2, "No line end."); clear();YYABORT;};
slots: slotref | slotref SPLIT slots ;
slotref : slot {
  //OS<<"line number:"<<llvmParser->getSourceManager().FindLineNumber(TokStart)<<"\n";
  llvm::UCPM::LineNumber = llvmParser->getSourceManager().FindLineNumber(TokStart);
  /* in fact it's should not be executed for more than 1 time */
  int NumBuffers = llvmParser->getSourceManager().getNumBuffers();
  //llvm::UCPM::InputSrcBuffer = llvmParser->getSourceManager().getMemoryBuffer(NumBuffers)->getBuffer();
  /*int NumBuffers = llvmParser->getSourceManager().getNumBuffers();
  OS<<llvmParser->getSourceManager().getMemoryBuffer(NumBuffers)->getBuffer();*/
  //OS<<"slotref!!!!!!!!!!!!!!!!!!!\n";
  tm = NULL;
  tn = NULL;
  tp = NULL;
  ts = NULL;
  tk = NULL;
  tl = NULL;//dcx
  ut = NULL;
  revt = NULL;
  ms = NULL;
  md = NULL;
  imm = NULL;
  imm1 = NULL;//dcx
  imm2 = NULL;//dcx
  f = NULL;
  ff = NULL;
  rf = NULL;
  shift = NULL;
  unit = NULL;
  unit2 = NULL;
  unit3 = NULL;
  unit4 = NULL;
  expr = NULL;
  b = NULL;
  b2 = NULL;
  opc = NULL;
  ipath = NULL;
  treg = NULL;
  condpos = 0;
  FlagS = SMLoc();
  FlagE = SMLoc();
  //dcx
  qlh = NULL;
  step = NULL;
  sia = NULL;
  dis = NULL;//huhh
  isTnValid = true;//yangl
  isIMACABS = false;//yangl
  oImacFlag = NULL;//yangl
  isTpValid = true;//yangl
  isTpMR = false;//yangl
  isTpMR_toMR = false;//yangl
  isIALUDoubleDest = false;//ducx
//  isIMACDoubleDest = false;//niuxx
  //isIFALUDoubleDest = false;//haoxb
  isSHU0DoubleDest = false;//huhh
  isSHU1DoubleDest = false;//huhh
  isSHU2DoubleDest = false;//huhh
  imac_additional_dest = 0;//yangl
  imac_dest_return_value = -1;//yangl
  isSetCond = false;//ducx
  hasErr = false;//ducx
  flags.reset();//ducx
};
slot: mr012345slot condflag {ADDOPERAND(Slot, 9 + $1, @$.S, @$.E); slots_occupation_table[9 + $1] = true;} |
      shuslot condflag {ADDOPERAND(Slot, 2 + $1, @$.S, @$.E); slots_occupation_table[2 + $1] = true;} |
      ialuslot condflag { if(hasErr)
                          { hasErr = false;
                            llvmerror(&@1, "Incorrect IALU inst."); clear();YYABORT;
                          }
          ADDOPERAND(Slot, 5, @$.S, @$.E); slots_occupation_table[5] = true;
      } |
      ifaluslot condflag { if(hasErr)
                           { hasErr = false;
                             llvmerror(&@1, "Incorrect IFALU inst."); clear();YYABORT;
                           }
          ADDOPERAND(Slot, 7, @$.S, @$.E); slots_occupation_table[7] = true;
      } |
      imacslot condflag {  if(hasErr)
                           { hasErr = false;
                             llvmerror(&@1, "Incorrect IMAC inst."); clear();YYABORT;
                           }
          ADDOPERAND(Slot, 6, @$.S, @$.E); slots_occupation_table[6] = true;
      } |
      ifmacslot condflag { if(hasErr)
                           { hasErr = false;
                             llvmerror(&@1, "Incorrect IFMAC inst."); clear();YYABORT;
                           }
          ADDOPERAND(Slot, 8, @$.S, @$.E); slots_occupation_table[8] = true;
      } |
      biuslot condflag {ADDOPERAND(Slot, 15 + $1, @$.S, @$.E); slots_occupation_table[15 + $1] = true;}|  
      seqslot condflag {   if(hasErr)
                           { hasErr = false;
                             llvmerror(&@1, "Incorrect Mfetch inst."); clear();YYABORT;
                           }
                           slots_occupation_table[1] = true;
      }|
      hmacro | //?
      error { llvmerror(&@1, "Unrecognized slot."); clear();YYABORT; };
hmacro: IDENTIFIER {ADDOPERAND(HMacro, $1, @$.S, @$.E);};
hmacro: IDENTIFIER LPAREN RPAREN {ADDOPERAND(HMacro, $1, @$.S, @$.E); ADDOPERAND(Imm, 1, @$.S, @$.E);};

// start mreg -------------------------------------------------- 
//yangl
mr012345slot: mr0code { if(hasErr)
                        { hasErr = false;
                          llvmerror(&@1, "Incorrect M.r0 inst.");clear();YYABORT;
                        }
                        $$ = 0;
                      } 
	    | mr1code { if(hasErr)
                        { hasErr = false;
                          llvmerror(&@1, "Incorrect M.r1 inst.");clear();YYABORT;
                        }
                        $$ = 1;
                      } 
	    | mr2code { if(hasErr)
                        { hasErr = false; 
                          llvmerror(&@1, "Incorrect M.r2 inst.");clear();YYABORT;
                        }
                        $$ = 2;
                      } 
	    | mr3code { if(hasErr)
                        { hasErr = false; 
                          llvmerror(&@1, "Incorrect M.r3 inst.");clear();YYABORT;
                        }
                        $$ = 3;
                      } 
	    | mr4code { if(hasErr)
                        { hasErr = false; 
                          llvmerror(&@1, "Incorrect M.r4 inst.");clear();YYABORT;
                        }
                        $$ = 4;
                      } 
            | mr5code { if(hasErr)
                        { hasErr = false; 
                          llvmerror(&@1, "Incorrect M.r5 inst.");clear();YYABORT;
                        }
                        $$ = 5;
                      };


mr0code: R0 DOT r0inst {
  switch ($3) {
  case 0:
    //r0inst: mindexn -> r0dest
    ADDOPERAND(Opc, UCPM::MR0ToDestCom, @$.S, @$.E);
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit2));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    break;
    
  case 1:
    //r0inst: (m[i++/s++/a++]) -> r0dest         
    flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
    sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	      
    flags.reset();
	      
    ADDOPERAND(Opc, UCPM::MR0ToDestSIA, @$.S, @$.E);
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit2));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;
    
    case 2:
    //r1inst: (m[dis(shift)]) -> r1dest 
    flagsort = (flags[SHIFTF]);
    dis = OPERAND(Imm, flagsort, FlagS, FlagE);	
    flags.reset();
     
    ADDOPERAND(Opc, UCPM::MR0ToDestDis, @$.S, @$.E);
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit2));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default:
    llvmerror(&@1, "mreg r0dest error!"); clear();YYABORT;
    break;
  }

}
| R0 DOT mregwait{          
      ADDOPERAND(Opc, UCPM::MR0Wait, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));  
}
| R0 DOT r0Toconfigmr{

		  if(flags[SF])
		      flagsort = 0x1;
		  else if(flags[IF])
		      flagsort = 0x0;
		  else {llvmerror(&@1, "Incorrect R0.configmr inst! S/I flag error!"); clear();YYABORT;}
		  ff = OPERAND(Imm, flagsort, FlagS, FlagE);   

		  if(flags[MR0F])
		      flagsort = 0x0;
		  else if(flags[MR1F])
		      flagsort = 0x1;
		  else if(flags[MR2F])
		      flagsort = 0x2;
		  else if(flags[MR3F])
		      flagsort = 0x3;
		  else if(flags[MR4F])
		      flagsort = 0x4;
		  else if(flags[MR5F])
		      flagsort = 0x5;
		  else if(flags[ALLF])
		      flagsort = 0x6;
		  else if(flags[ALL2F])
		      flagsort = 0x7;
		  else {llvmerror(&@1, "Incorrect R0.configmr inst! OPT flags error!"); clear();YYABORT;}
	      f = OPERAND(Imm, flagsort, FlagS, FlagE);
             
 switch ($3) {
       case 0:
       flags.reset();
	   ADDOPERAND(Opc, UCPM::MR0ToConfigMR, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
	case 1:
	 flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
         sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	      
         flags.reset();
	   ADDOPERAND(Opc, UCPM::MR0SIAToConfigMR, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
	case 2:
	flagsort = (flags[SHIFTF]);
        dis = OPERAND(Imm, flagsort, FlagS, FlagE);	
        flags.reset();
	   ADDOPERAND(Opc, UCPM::MR0DisToConfigMR, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
	/*   default:
	   llvmerror(&@1, "only R0 can pass configmr!"); 
	   break;*/
}
}
| R0 DOT configmrTor0{
	      
	   if(flags[SF])
		      flagsort = 0x1;
		  else if(flags[IF])
		      flagsort = 0x0;
		  else {llvmerror(&@1, "Incorrect R0.configmr inst! S/I flag error!"); clear();YYABORT;}
		      
		  ff = OPERAND(Imm, flagsort, FlagS, FlagE);   

		  if(flags[MR0F])
		      flagsort = 0x0;
		  else if(flags[MR1F])
		      flagsort = 0x1;
		  else if(flags[MR2F])
		      flagsort = 0x2;
		  else if(flags[MR3F])
		      flagsort = 0x3;
		  else if(flags[MR4F])
		      flagsort = 0x4;
		  else if(flags[MR5F])
		      flagsort = 0x5;
		  else if(flags[ALLF])
		      flagsort = 0x6;
		  else if(flags[ALL2F])
		      flagsort = 0x7;
		  else {llvmerror(&@1, "Incorrect R0.configmr inst! OPT flags error!"); clear();YYABORT;}
	      f = OPERAND(Imm, flagsort, FlagS, FlagE);
switch ($3) {
       case 0:
           flags.reset();
	   ADDOPERAND(Opc, UCPM::ConfigMRToMR0, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
       case 1:
	 flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
         sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	      
         flags.reset();
	   ADDOPERAND(Opc, UCPM::ConfigMRToMR0SIA, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
	case 2:
	flagsort = (flags[SHIFTF]);
        dis = OPERAND(Imm, flagsort, FlagS, FlagE);	
        flags.reset();
	   ADDOPERAND(Opc, UCPM::ConfigMRToMR0Dis, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
/*	   default:
	   llvmerror(&@1, "only R0 can pass configmr!"); 
	   break;*/
}
}

| R0 DOT configbiu{
	     //OS<<"R0 DOT configbiu\n";
		  if(flags[KMF])
		      flagsort = 0x0;
		  else if(flags[KGF])
		      flagsort = 0x1;
		  else if(flags[KGCURRENTF])
		      flagsort = 0x2;
		  else if(flags[BRF])
		      flagsort = 0x3;
		  else if(flags[L1F])
		      flagsort = 0x4;
		  else if(flags[L2F])
		      flagsort = 0x5;
		  else if(flags[L4F])
		      flagsort = 0x6;
		  else if(flags[ALLF])
		      flagsort = 0x7;
		  else {llvmerror(&@1, "Incorrect R0.configbiu inst! OPT flags error!"); clear();YYABORT;}
	      f = OPERAND(Imm, flagsort, FlagS, FlagE);
	      
 switch ($3) {
  case 0:
  flags.reset();
    //r0inst: mindexn -> MR0ConfigBIU	      
	   ADDOPERAND(Opc, UCPM::MR0ConfigBIU, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
  case 1:
    //r0inst: m[S++/I++/A++] -> MR0ConfigBIU
    flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
    sia = OPERAND(Imm, flagsort, FlagS, FlagE);	      
    flags.reset();
           ADDOPERAND(Opc, UCPM::MR0SIAConfigBIU, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
  case 2:
    //r0inst: m[dis(shift)] -> MR0ConfigBIU
    flagsort = (flags[SHIFTF]);
    dis = OPERAND(Imm, flagsort, FlagS, FlagE);	
    flags.reset();
           ADDOPERAND(Opc, UCPM::MR0DisConfigBIU, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;   
/*     default:
     llvmerror(&@1, "only R0 can configbiu0!"); 
    break;*/
  }
}

| R0 DOT configlatch{
               if(flags[KR0F])
		      flagsort = 0x0;
		  else if(flags[KR1F])
		      flagsort = 0x1;
		  else if(flags[KR2F])
		      flagsort = 0x2;
		  else if(flags[KR3F])
		      flagsort = 0x3;
		  else if(flags[KR4F])
		      flagsort = 0x4;
		  else if(flags[KR5F])
		      flagsort = 0x5;
		  else if(flags[KR6F])
		      flagsort = 0x6;
		  else if(flags[KR7F])
		      flagsort = 0x7;
          else if(flags[KW0F])
		      flagsort = 0x8;
          else if(flags[KW1F])
		      flagsort = 0x9;
          else if(flags[KW2F])
		      flagsort = 0xA;
          else if(flags[KW3F])
		      flagsort = 0xB;
          else if(flags[KW4F])
		      flagsort = 0xC;
          else if(flags[KFROM0F])
		      flagsort = 0xD;
          else if(flags[KWPALLF])
		      flagsort = 0xE;
          else if(flags[KRPALLF])
		      flagsort = 0xF;
          else {llvmerror(&@1, "Incorrect R0.configlatch inst! OPT flags error!"); clear();YYABORT;}
	      f = OPERAND(Imm, flagsort, FlagS, FlagE);
switch ($3) {
         case 0:
	   flags.reset();
           ADDOPERAND(Opc, UCPM::MR0ToConfigLatch, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
	 case 1:
	   flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
           sia = OPERAND(Imm, flagsort, FlagS, FlagE);	   
	   flags.reset();
           ADDOPERAND(Opc, UCPM::MR0SIAToConfigLatch, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
	  case 2:
	  flagsort = (flags[SHIFTF]);
          dis = OPERAND(Imm, flagsort, FlagS, FlagE);	
	   flags.reset();
           ADDOPERAND(Opc, UCPM::MR0DisToConfigLatch, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break; 
	/*   default:
	   llvmerror(&@1, " configlatch only pass R0 or R3!"); 
    break;*/
  }
}

| r0setcondInstr{   
	    isSetCond = true;
	    ADDOPERAND(Opc, UCPM::MR0SetCond, @$.S, @$.E);
	    Operands.push_back(nullptr);
	    condpos = Operands.size();
	    if (imm == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
	    if (imm1 == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));   
}
| R0 DOT setCGInstr{   

          flagsort = (flags[ONF]);
          f = OPERAND(Imm, flagsort, FlagS, FlagE);	
	  flags.reset();
	   
	    ADDOPERAND(Opc, UCPM::MR0SetCG, @$.S, @$.E);
	    Operands.push_back(nullptr);
	    condpos = Operands.size();
	    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));   
};

mr1code: R1 DOT r1inst {

  
    
    
  switch ($3) {
  case 0:
    ADDOPERAND(Opc, UCPM::MR1ToDestCom, @$.S, @$.E);
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit2));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    break;
  case 1:
    flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
    sia = OPERAND(Imm, flagsort, FlagS, FlagE);	      
    flags.reset();
    ADDOPERAND(Opc, UCPM::MR1ToDestSIA, @$.S, @$.E);
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit2));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;
  case 2:
    //r1inst: (m[dis(shift)]) -> r1dest 
    flagsort = (flags[SHIFTF]);
    dis = OPERAND(Imm, flagsort, FlagS, FlagE);	
    flags.reset();
     
    ADDOPERAND(Opc, UCPM::MR1ToDestDis, @$.S, @$.E);
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit2));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
  default:
  llvmerror(&@1, "mreg r1dest error!"); clear();YYABORT;
    break;
  }
  
}
| R1 DOT mregwait{           
      ADDOPERAND(Opc, UCPM::MR1Wait, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));  
}
| R1 DOT configbiu{
	     
		  if(flags[KMF])
		      flagsort = 0x0;
		  else if(flags[KGF])
		      flagsort = 0x1;
		  else if(flags[KGCURRENTF])
		      flagsort = 0x2;
		  else if(flags[BRF])
		      flagsort = 0x3;
		  else if(flags[L1F])
		      flagsort = 0x4;
		  else if(flags[L2F])
		      flagsort = 0x5;
		  else if(flags[L4F])
		      flagsort = 0x6;
		  else if(flags[ALLF])
		      flagsort = 0x7;
		  else {llvmerror(&@1, "Incorrect R1.configbiu inst! OPT flags error!"); clear();YYABORT;}
	      f = OPERAND(Imm, flagsort, FlagS, FlagE);
switch ($3) {
   case 0:
   flags.reset();
    //r1inst: mindexn -> MR1ConfigBIU	      
	   ADDOPERAND(Opc, UCPM::MR1ConfigBIU, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
  case 1:
    //r1inst: m[S++/I++/A++] -> MR1ConfigBIU
    flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
    sia = OPERAND(Imm, flagsort, FlagS, FlagE);	      
    flags.reset();
           ADDOPERAND(Opc, UCPM::MR1SIAConfigBIU, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
  case 2:
    //r2inst: m[dis(shift)] -> MR2ConfigBIU
    flagsort = (flags[SHIFTF]);
    dis = OPERAND(Imm, flagsort, FlagS, FlagE);	
    flags.reset();
           ADDOPERAND(Opc, UCPM::MR1DisConfigBIU, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;   
   /*  default:llvmerror(&@1, "only R1 can configbiu1!"); 
    break;*/
  }
}
| R1 DOT r1configmfetch{
	     
		  if(flags[KI0F])
		      flagsort = 0x0;
		  else if(flags[KI1F])
		      flagsort = 0x1;
		  else if(flags[KI2F])
		      flagsort = 0x2;
		  else if(flags[KI3F])
		      flagsort = 0x3;
		  else if(flags[KI4F])
		      flagsort = 0x4;
		  else if(flags[KI5F])
		      flagsort = 0x5;
		  else if(flags[KI6F])
		      flagsort = 0x6;
		  else if(flags[KI7F])
		      flagsort = 0x7;
		  else {llvmerror(&@1, "Incorrect R1.configmfetch inst! OPT flags error!"); clear();YYABORT;}
	      f = OPERAND(Imm, flagsort, FlagS, FlagE);
	      
switch ($3) {
     case 0:
           flags.reset();
	   ADDOPERAND(Opc, UCPM::MR1ToConfigMFetch, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
     case 1: 
           flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
           sia = OPERAND(Imm, flagsort, FlagS, FlagE);	      
           flags.reset();
           ADDOPERAND(Opc, UCPM::MR1SIAToConfigMFetch, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
     case 2: 
           flagsort = (flags[SHIFTF]);
           dis = OPERAND(Imm, flagsort, FlagS, FlagE);	
           flags.reset();
           ADDOPERAND(Opc, UCPM::MR1DisToConfigMFetch, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
            break;   
       /*     default:
            llvmerror(&@1, "configmfetch only pass R1 or R4 !"); 
             break;*/
  }
}
	   






| r1setcondInstr{   
	    isSetCond = true;
	    ADDOPERAND(Opc, UCPM::MR1SetCond, @$.S, @$.E);
	    Operands.push_back(nullptr);
	    condpos = Operands.size();
	    if (imm == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
	    if (imm1 == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));   
};

mr2code: R2 DOT r2inst {
  switch ($3) {
  case 0:
    ADDOPERAND(Opc, UCPM::MR2ToDestCom, @$.S, @$.E);
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit2));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    break;
  case 1:
    flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
    sia = OPERAND(Imm, flagsort, FlagS, FlagE);      
    flags.reset();
    ADDOPERAND(Opc, UCPM::MR2ToDestSIA, @$.S, @$.E);
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit2));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;
    case 2:
    //r1inst: (m[dis(shift)]) -> r1dest 
    flagsort = (flags[SHIFTF]);
    dis = OPERAND(Imm, flagsort, FlagS, FlagE);	
    flags.reset();
     
    ADDOPERAND(Opc, UCPM::MR2ToDestDis, @$.S, @$.E);
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit2));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
  default:
  llvmerror(&@1, "mreg r2dest error!"); clear();YYABORT;
    break;
  }
  
}
| R2 DOT mregwait{           
      ADDOPERAND(Opc, UCPM::MR2Wait, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));  
}
| R2 DOT configbiu{
	     
		if(flags[ALLF])
		      flagsort = 0x7;
		else
		{ 
		  llvmerror(&@1, "Incorrect R2.configbiu inst! flag must be 'ALL' !"); 
		  clear();YYABORT;
		} 
		  
	      f = OPERAND(Imm, flagsort, FlagS, FlagE);
switch ($3) {
   case 0:
   flags.reset();
    //r2inst: mindexn -> MR2ConfigBIU	      
	   ADDOPERAND(Opc, UCPM::MR2ConfigBIU, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
  case 1:
    //r2inst: m[S++/I++/A++] -> MR2ConfigBIU
    flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
    sia = OPERAND(Imm, flagsort, FlagS, FlagE);	      
    flags.reset();
           ADDOPERAND(Opc, UCPM::MR2SIAConfigBIU, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
  case 2:
    //r2inst: m[dis(shift)] -> MR2ConfigBIU
    flagsort = (flags[SHIFTF]);
    dis = OPERAND(Imm, flagsort, FlagS, FlagE);	
    flags.reset();
           ADDOPERAND(Opc, UCPM::MR2DisConfigBIU, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;   
/*     default:
     llvmerror(&@1, "mreg r2dest error!"); 
    break;*/
  }
}
| r2setcondInstr{   
	    isSetCond = true;
	    ADDOPERAND(Opc, UCPM::MR2SetCond, @$.S, @$.E);
	    Operands.push_back(nullptr);
	    condpos = Operands.size();
	    if (imm == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
	    if (imm1 == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));   
};

mr3code: R3 DOT r3inst {
  switch ($3) {
  case 0:
    ADDOPERAND(Opc, UCPM::MR3ToDestCom, @$.S, @$.E);
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit2));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    break;
  case 1:
    flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
    sia = OPERAND(Imm, flagsort, FlagS, FlagE);	      
    flags.reset();
    ADDOPERAND(Opc, UCPM::MR3ToDestSIA, @$.S, @$.E);
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit2));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
     break;
    case 2:
    //r1inst: (m[dis(shift)]) -> r1dest 
    flagsort = (flags[SHIFTF]);
    dis = OPERAND(Imm, flagsort, FlagS, FlagE);	
    flags.reset();
     
    ADDOPERAND(Opc, UCPM::MR3ToDestDis, @$.S, @$.E);
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit2));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
  default:
  llvmerror(&@1, "mreg r3dest error!"); clear();YYABORT;
    break;
  }
 
}
| R3 DOT mregwait{           
      ADDOPERAND(Opc, UCPM::MR3Wait, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size(); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));  
}
| R3 DOT configbiu{
	     
		if(flags[ALLF])
		      flagsort = 0x7;
		else
		{ 
		  llvmerror(&@1, "Incorrect R3.configbiu inst! flag must be 'ALL' !"); 
		  clear();YYABORT;
		} 
	      f = OPERAND(Imm, flagsort, FlagS, FlagE);
switch ($3) { 	     
   case 0:
   flags.reset();
    //r3inst: mindexn -> MR3ConfigBIU	      
	   ADDOPERAND(Opc, UCPM::MR3ConfigBIU, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
  case 1:
    //r3inst: m[S++/I++/A++] -> MR3ConfigBIU
    flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
    sia = OPERAND(Imm, flagsort, FlagS, FlagE);	      
    flags.reset();
           ADDOPERAND(Opc, UCPM::MR3SIAConfigBIU, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
  case 2:
    //r3inst: m[dis(shift)] -> MR3ConfigBIU
    flagsort = (flags[SHIFTF]);
    dis = OPERAND(Imm, flagsort, FlagS, FlagE);	
    flags.reset();
           ADDOPERAND(Opc, UCPM::MR3DisConfigBIU, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;   
 /*    default:
     llvmerror(&@1, "R3 configure configbiu0!"); 
    break;*/
  }
}
| R3 DOT configlatch{
               if(flags[KR0F])
		      flagsort = 0x0;
		  else if(flags[KR1F])
		      flagsort = 0x1;
		  else if(flags[KR2F])
		      flagsort = 0x2;
		  else if(flags[KR3F])
		      flagsort = 0x3;
		  else if(flags[KR4F])
		      flagsort = 0x4;
		  else if(flags[KR5F])
		      flagsort = 0x5;
		  else if(flags[KR6F])
		      flagsort = 0x7;
		  else if(flags[KR7F])
		      flagsort = 0x6;
          else  if(flags[KW0F])
		      flagsort = 0x8;
          else if(flags[KW1F])
		      flagsort = 0x9;
          else if(flags[KW2F])
		      flagsort = 0xA;
          else if(flags[KW3F])
		      flagsort = 0xB;
          else if(flags[KW4F])
		      flagsort = 0xC;
          else if(flags[KFROM3F])
		      flagsort = 0xD;
          else if(flags[KWPALLF])
		      flagsort = 0xE;
          else if(flags[KRPALLF])
		      flagsort = 0xF;
          else {llvmerror(&@1, "Incorrect R3.configlatch inst! OPT flags error!"); clear();YYABORT;}
          
/*          if( flags[KR0F] || flags[KR1F] || flags[KR2F] || flags[KR3F] || flags[KR4F] || flags[KR5F] || flags[KR6F]
	      || flags[KR7F] || flags[KRPALLF])
          {
	    llvmerror(&@1, "flags error!"); 
	    clear();YYABORT;
          }*/
	      f = OPERAND(Imm, flagsort, FlagS, FlagE);
	      
switch ($3) {
         case 0:
	   flags.reset();
           ADDOPERAND(Opc, UCPM::MR3ToConfigLatch, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
	 case 1:
	   flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
           sia = OPERAND(Imm, flagsort, FlagS, FlagE);	   
	   flags.reset();
           ADDOPERAND(Opc, UCPM::MR3SIAToConfigLatch, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
	  case 2:
	  flagsort = (flags[SHIFTF]);
          dis = OPERAND(Imm, flagsort, FlagS, FlagE);	
	   flags.reset();
           ADDOPERAND(Opc, UCPM::MR3DisToConfigLatch, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break; 
/*	   default:
	   llvmerror(&@1, "configlatch only pass R0 or R3!"); 
    break;*/
  }
}

| R3 DOT r3Toconfigmw{

		  if(flags[SF])
		      flagsort = 0x1;
		  else if(flags[IF])
		      flagsort = 0x0;
		  else {llvmerror(&@1, "Incorrect R3.configmw inst! S/I flag error!"); clear();YYABORT;}
		  ff = OPERAND(Imm, flagsort, FlagS, FlagE);   

		  if(flags[MW0F])
		      flagsort = 0x0;
		  else if(flags[MW1F])
		      flagsort = 0x1;
		  else if(flags[MW2F])
		      flagsort = 0x2;
		  else if(flags[MW3F])
		      flagsort = 0x3;
		  else if(flags[MW4F])
		      flagsort = 0x4;
		  else if(flags[MW5F])
		      flagsort = 0x5;
		  else if(flags[ALLF])
		      flagsort = 0x6;
		  else if(flags[ALL2F])
		      flagsort = 0x7;
		  else {llvmerror(&@1, "Incorrect R3.configmw inst! OPT flags error!"); clear();YYABORT;}
	      f = OPERAND(Imm, flagsort, FlagS, FlagE);
 switch ($3) {      
	  case 0:
           flags.reset();
	   ADDOPERAND(Opc, UCPM::MR3ToConfigMW, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
	case 1:
	 flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
         sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	      
         flags.reset();
	   ADDOPERAND(Opc, UCPM::MR3SIAToConfigMW, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
	case 2:
	flagsort = (flags[SHIFTF]);
        dis = OPERAND(Imm, flagsort, FlagS, FlagE);	
        flags.reset();
	   ADDOPERAND(Opc, UCPM::MR3DisToConfigMW, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
	/*   default:
	   llvmerror(&@1, "only R3 can pass configmw!"); 
	   break;*/
}
}
| R3 DOT configmwTor3{
	      
	   if(flags[SF])
		      flagsort = 0x1;
		  else if(flags[IF])
		      flagsort = 0x0;
		  else {llvmerror(&@1, "Incorrect R3.configmw inst! S/I flag error!"); clear();YYABORT;}
		  ff = OPERAND(Imm, flagsort, FlagS, FlagE);   

		  if(flags[MW0F])
		      flagsort = 0x0;
		  else if(flags[MW1F])
		      flagsort = 0x1;
		  else if(flags[MW2F])
		      flagsort = 0x2;
		  else if(flags[MW3F])
		      flagsort = 0x3;
		  else if(flags[MW4F])
		      flagsort = 0x4;
		  else if(flags[MW5F])
		      flagsort = 0x5;
		  else if(flags[ALLF])
		      flagsort = 0x6;
		  else if(flags[ALL2F])
		      flagsort = 0x7;
		 else {llvmerror(&@1, "Incorrect R3.configmw inst! OPT flags error!"); clear();YYABORT;}
	      f = OPERAND(Imm, flagsort, FlagS, FlagE);
switch ($3) {      
	  case 0:
           flags.reset();
	   ADDOPERAND(Opc, UCPM::ConfigMWToMR3, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 	
 break;
	case 1:
	 flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
         sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	      
         flags.reset();
	   ADDOPERAND(Opc, UCPM::ConfigMWToMR3SIA, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
	case 2:
	flagsort = (flags[SHIFTF]);
        dis = OPERAND(Imm, flagsort, FlagS, FlagE);	
        flags.reset();
	   ADDOPERAND(Opc, UCPM::ConfigMWToMR3Dis, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
	/*   default:
	   llvmerror(&@1, "only R3 can pass configmw!"); 
	   break;*/
}
}

| r3setcondInstr{   
	    isSetCond = true;
	    ADDOPERAND(Opc, UCPM::MR3SetCond, @$.S, @$.E);
	    Operands.push_back(nullptr);
	    condpos = Operands.size();
	    if (imm == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
	    if (imm1 == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));   
};

mr4code: R4 DOT r4inst {
  switch ($3) {
  case 0:
    ADDOPERAND(Opc, UCPM::MR4ToDestCom, @$.S, @$.E);
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit2));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    break;
  case 1:
    flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
    sia = OPERAND(Imm, flagsort, FlagS, FlagE);	      
    flags.reset();
    ADDOPERAND(Opc, UCPM::MR4ToDestSIA, @$.S, @$.E);
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit2));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
     break;
    case 2:
    //r1inst: (m[dis(shift)]) -> r1dest 
    flagsort = (flags[SHIFTF]);
    dis = OPERAND(Imm, flagsort, FlagS, FlagE);	
    flags.reset();
     
    ADDOPERAND(Opc, UCPM::MR4ToDestDis, @$.S, @$.E);
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit2));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
  default:
  llvmerror(&@1, "mreg r4dest error!"); clear();YYABORT;
    break;
  }
 
}
| R4 DOT mregwait{           
      ADDOPERAND(Opc, UCPM::MR4Wait, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));  
}
| R4 DOT configbiu{
	     
	        if(flags[ALLF])
		      flagsort = 0x7;
		else
		{ 
		  llvmerror(&@1, "Incorrect R4.configbiu inst! flag must be 'ALL' !"); 
		  clear();YYABORT;
		} 
	      f = OPERAND(Imm, flagsort, FlagS, FlagE);
	      
switch ($3) {
   case 0:
   flags.reset();
    //r4inst: mindexn -> MR4ConfigBIU	      
	   ADDOPERAND(Opc, UCPM::MR4ConfigBIU, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
  case 1:
    //r4inst: m[S++/I++/A++] -> MR4ConfigBIU
    flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
    sia = OPERAND(Imm, flagsort, FlagS, FlagE);	      
    flags.reset();
           ADDOPERAND(Opc, UCPM::MR4SIAConfigBIU, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
  case 2:
    //r4inst: m[dis(shift)] -> MR4ConfigBIU
    flagsort = (flags[SHIFTF]);
    dis = OPERAND(Imm, flagsort, FlagS, FlagE);	
    flags.reset();
           ADDOPERAND(Opc, UCPM::MR4DisConfigBIU, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;   
  /*   default:
     llvmerror(&@1, "mreg r4dest error!"); 
    break;*/
  }
}
| R4 DOT r4configmfetch{
	     
		  if(flags[KI0F])
		      flagsort = 0x0;
		  else if(flags[KI1F])
		      flagsort = 0x1;
		  else if(flags[KI2F])
		      flagsort = 0x2;
		  else if(flags[KI3F])
		      flagsort = 0x3;
		  else if(flags[KI4F])
		      flagsort = 0x4;
		  else if(flags[KI5F])
		      flagsort = 0x5;
		  else if(flags[KI6F])
		      flagsort = 0x6;
		  else if(flags[KI7F])
		      flagsort = 0x7;
		  else {llvmerror(&@1, "Incorrect R4.configmfetch inst! OPT flags error!"); clear();YYABORT;}
	      f = OPERAND(Imm, flagsort, FlagS, FlagE);
switch ($3) {
     case 0:  
           flags.reset();
	   ADDOPERAND(Opc, UCPM::MR4ToConfigMFetch, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
     case 1: 
           flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
           sia = OPERAND(Imm, flagsort, FlagS, FlagE);	      
           flags.reset();
           ADDOPERAND(Opc, UCPM::MR4SIAToConfigMFetch, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
     case 2: 
           flagsort = (flags[SHIFTF]);
           dis = OPERAND(Imm, flagsort, FlagS, FlagE);	
           flags.reset();
           ADDOPERAND(Opc, UCPM::MR4DisToConfigMFetch, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
            break;   
          /*  default:
            llvmerror(&@1, " configmfetch only pass R1 or R4!"); 
             break;*/
  }
}
	   

| r4setcondInstr{   
	    isSetCond = true;
	    ADDOPERAND(Opc, UCPM::MR4SetCond, @$.S, @$.E);
	    Operands.push_back(nullptr);
	    condpos = Operands.size();
	    if (imm == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
	    if (imm1 == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));   
};

mr5code: R5 DOT r5inst {
  switch ($3) {
  case 0:
    //OS<<"MR5ToDestCom!!!!!!!!!!!!!!!!!!!\n";
    ADDOPERAND(Opc, UCPM::MR5ToDestCom, @$.S, @$.E);
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit2));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    break;
  case 1:
    flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
    sia = OPERAND(Imm, flagsort, FlagS, FlagE);	      
    flags.reset();
    ADDOPERAND(Opc, UCPM::MR5ToDestSIA, @$.S, @$.E);
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit2));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
     break;
    case 2:
    //r1inst: (m[dis(shift)]) -> r1dest 
    flagsort = (flags[SHIFTF]);
    dis = OPERAND(Imm, flagsort, FlagS, FlagE);	
    flags.reset();
     
    ADDOPERAND(Opc, UCPM::MR5ToDestDis, @$.S, @$.E);
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit2));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
  default:
  llvmerror(&@1, "mreg r5dest error!"); clear();YYABORT;
    break;
  }
  
}
| R5 DOT mregwait{           
      ADDOPERAND(Opc, UCPM::MR5Wait, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));  
}
| R5 DOT configbiu{
	     
		  if(flags[KMF])
		      flagsort = 0x0;
		  else if(flags[KGF])
		      flagsort = 0x1;
		  else if(flags[KGCURRENTF])
		      flagsort = 0x2;
		  else if(flags[BRF])
		      flagsort = 0x3;
		  else if(flags[L1F])
		      flagsort = 0x4;
		  else if(flags[L2F])
		      flagsort = 0x5;
		  else if(flags[L4F])
		      flagsort = 0x6;
		  else if(flags[ALLF])
		      flagsort = 0x7;
		  else {llvmerror(&@1, "Incorrect R5.configbiu inst! OPT flags error!"); clear();YYABORT;}
	      f = OPERAND(Imm, flagsort, FlagS, FlagE);
switch ($3) {
   case 0:
   flags.reset();
    //r5inst: mindexn -> MR5ConfigBIU	      
	   ADDOPERAND(Opc, UCPM::MR5ConfigBIU, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
  case 1:
    //r5inst: m[S++/I++/A++] -> MR5ConfigBIU
    flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
    sia = OPERAND(Imm, flagsort, FlagS, FlagE);	      
    flags.reset();
           ADDOPERAND(Opc, UCPM::MR5SIAConfigBIU, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;
  case 2:
    //r5inst: m[dis(shift)] -> MR5ConfigBIU
    flagsort = (flags[SHIFTF]);
    dis = OPERAND(Imm, flagsort, FlagS, FlagE);	
    flags.reset();
           ADDOPERAND(Opc, UCPM::MR5DisConfigBIU, @$.S, @$.E);
	   Operands.push_back(nullptr);
	   condpos = Operands.size();
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
	   Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	   break;   
 /*    default:
     llvmerror(&@1, "only R5 can configbiu5!!"); 
    break;*/
  }
}
| r5setcondInstr{   
	    isSetCond = true;
	    ADDOPERAND(Opc, UCPM::MR5SetCond, @$.S, @$.E);
	    Operands.push_back(nullptr);
	    condpos = Operands.size();
	    if (imm == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
	    if (imm1 == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));   
};	


mregwait: WAIT IMM5 {imm = OPERAND(Imm, $2, @2.S, @2.E);};

r0Toconfigmr: mindexn ASSIGNTO CONFIGMR LBRACKET configmrflag RBRACKET _flag siflag flag_{$$ = 0;}  |
              mindexsia ASSIGNTO CONFIGMR LBRACKET configmrflag RBRACKET _flag siflag flag_{$$ = 1;}  |
	      mindexdis ASSIGNTO CONFIGMR LBRACKET configmrflag RBRACKET _flag siflag flag_{$$ = 2;};

r0Toconfigmr: mindexn ASSIGNTO CONFIGMR LBRACKET error RBRACKET {llvmerror(&@5, "Incorrect M.r0 inst! OPT flags error!"); clear();YYABORT;}  |
              mindexsia ASSIGNTO CONFIGMR LBRACKET error RBRACKET {llvmerror(&@5, "Incorrect M.r0 inst! OPT flags error!"); clear();YYABORT;}  |
	      mindexdis ASSIGNTO CONFIGMR LBRACKET error RBRACKET {llvmerror(&@5, "Incorrect M.r0 inst! OPT flags error!"); clear();YYABORT;} |
	      mindexn ASSIGNTO CONFIGMR LBRACKET configmrflag RBRACKET  error {llvmerror(&@7, "Incorrect M.r0 inst! must have S or I flag!"); clear();YYABORT;}  |
              mindexsia ASSIGNTO CONFIGMR LBRACKET configmrflag RBRACKET error {llvmerror(&@7, "Incorrect M.r0 inst! must have S or I flag!"); clear();YYABORT;}  |
	      mindexdis ASSIGNTO CONFIGMR LBRACKET configmrflag RBRACKET error {llvmerror(&@7, "Incorrect M.r0 inst! must have S or I flag!"); clear();YYABORT;};
	      
r3Toconfigmw: mindexn ASSIGNTO CONFIGMW LBRACKET configmwflag RBRACKET _flag siflag flag_ {$$ = 0;} |
              mindexsia ASSIGNTO CONFIGMW LBRACKET configmwflag RBRACKET _flag siflag flag_  {$$ = 1;} |
              mindexdis ASSIGNTO CONFIGMW LBRACKET configmwflag RBRACKET _flag siflag flag_ {$$ = 2;} ;

r3Toconfigmw: mindexn ASSIGNTO CONFIGMW LBRACKET error RBRACKET  {llvmerror(&@5, "Incorrect M.r3 inst! OPT flags error!"); clear();YYABORT;} |
              mindexsia ASSIGNTO CONFIGMW LBRACKET error RBRACKET {llvmerror(&@5, "Incorrect M.r3 inst! OPT flags error!"); clear();YYABORT;} |
              mindexdis ASSIGNTO CONFIGMW LBRACKET error RBRACKET  {llvmerror(&@5, "Incorrect M.r3 inst! OPT flags error!"); clear();YYABORT;} |
              mindexn ASSIGNTO CONFIGMW LBRACKET configmwflag RBRACKET error {llvmerror(&@7, "Incorrect M.r3 inst! must have S or I flag!"); clear();YYABORT;} |
              mindexsia ASSIGNTO CONFIGMW LBRACKET configmwflag RBRACKET error  {llvmerror(&@7, "Incorrect M.r3 inst! must have S or I flag!"); clear();YYABORT;} |
              mindexdis ASSIGNTO CONFIGMW LBRACKET configmwflag RBRACKET error {llvmerror(&@7, "Incorrect M.r3 inst! must have S or I flag!"); clear();YYABORT;} ;

              
configmrTor0: CONFIGMR LBRACKET configmrflag RBRACKET  _flag siflag flag_ ASSIGNTO mindexn {$$ = 0;} |
              CONFIGMR LBRACKET configmrflag RBRACKET  _flag siflag flag_ ASSIGNTO mindexsia {$$ = 1;} |
	      CONFIGMR LBRACKET configmrflag RBRACKET  _flag siflag flag_ ASSIGNTO mindexdis {$$ = 2;} ;

configmrTor0: CONFIGMR LBRACKET error RBRACKET {llvmerror(&@3, "Incorrect M.r0 inst! OPT flags error!"); clear();YYABORT;} |
	      CONFIGMR LBRACKET configmrflag RBRACKET error {llvmerror(&@5, "Incorrect M.r0 inst! must have S or I flag!"); clear();YYABORT;} ;
	      
configmwTor3: CONFIGMW LBRACKET configmwflag RBRACKET  _flag siflag flag_  ASSIGNTO mindexn {$$ = 0;} |
	      CONFIGMW LBRACKET configmwflag RBRACKET  _flag siflag flag_  ASSIGNTO mindexsia {$$ = 1;} |
	      CONFIGMW LBRACKET configmwflag RBRACKET  _flag siflag flag_  ASSIGNTO mindexdis {$$ = 2;} ;

configmwTor3: CONFIGMW LBRACKET error RBRACKET {llvmerror(&@3, "Incorrect M.r3 inst! OPT flags error!"); clear();YYABORT;} |
	      CONFIGMW LBRACKET configmwflag RBRACKET error {llvmerror(&@5, "Incorrect M.r3 inst! must have S or I flag!"); clear();YYABORT;} ;
	      
r1configmfetch: mindexn ASSIGNTO CONFIGMFETCH LBRACKET configmflag RBRACKET {$$ = 0;}  |
                mindexsia ASSIGNTO CONFIGMFETCH LBRACKET configmflag RBRACKET {$$ = 1;}  |
                mindexdis ASSIGNTO CONFIGMFETCH LBRACKET configmflag RBRACKET {$$ = 2;} ;

r1configmfetch: mindexn ASSIGNTO CONFIGMFETCH LBRACKET error RBRACKET {llvmerror(&@5, "Incorrect M.r1 inst! OPT flags error!"); clear();YYABORT;}  |
                mindexsia ASSIGNTO CONFIGMFETCH LBRACKET error RBRACKET {llvmerror(&@5, "Incorrect M.r1 inst! OPT flags error!"); clear();YYABORT;}  |
                mindexdis ASSIGNTO CONFIGMFETCH LBRACKET error RBRACKET {llvmerror(&@5, "Incorrect M.r1 inst! OPT flags error!"); clear();YYABORT;} ;
                
r4configmfetch: mindexn ASSIGNTO CONFIGMFETCH LBRACKET configmflag RBRACKET{$$ = 0;} |
                mindexsia ASSIGNTO CONFIGMFETCH LBRACKET configmflag RBRACKET {$$ = 1;}  |
                mindexdis ASSIGNTO CONFIGMFETCH LBRACKET configmflag RBRACKET {$$ = 2;} ;
                
r4configmfetch: mindexn ASSIGNTO CONFIGMFETCH LBRACKET error RBRACKET{llvmerror(&@5, "Incorrect M.r4 inst! OPT flags error!"); clear();YYABORT;} |
                mindexsia ASSIGNTO CONFIGMFETCH LBRACKET error RBRACKET {llvmerror(&@5, "Incorrect M.r4 inst! OPT flags error!"); clear();YYABORT;}  |
                mindexdis ASSIGNTO CONFIGMFETCH LBRACKET error RBRACKET {llvmerror(&@5, "Incorrect M.r4 inst! OPT flags error!"); clear();YYABORT;} ;
                
configbiu: mindexn ASSIGNTO CONFIGBIU DOT t LBRACKET configflag RBRACKET {$$ = 0;} |
           mindexsia ASSIGNTO  CONFIGBIU DOT t LBRACKET configflag RBRACKET  {$$ = 1;}  |        
           mindexdis ASSIGNTO CONFIGBIU DOT t LBRACKET configflag RBRACKET {$$ = 2;};  //haoxb

configbiu: mindexn ASSIGNTO CONFIGBIU DOT t LBRACKET error RBRACKET {llvmerror(&@7, "Incorrect configbiu inst! OPT flags error!"); clear();YYABORT;} |
           mindexsia ASSIGNTO  CONFIGBIU DOT t LBRACKET error RBRACKET  {llvmerror(&@7, "Incorrect configbiu inst! OPT flags error!"); clear();YYABORT;}  |        
           mindexdis ASSIGNTO CONFIGBIU DOT t LBRACKET error RBRACKET {llvmerror(&@7, "Incorrect configbiu inst! OPT flags error!"); clear();YYABORT;};  

//configbiu: mindexn ASSIGNTO CONFIGBIU DOT t  {$$ = 0;} |
//           mindexsia ASSIGNTO  CONFIGBIU DOT t   {$$ = 1;}  |        
//           mindexdis ASSIGNTO CONFIGBIU DOT t  {$$ = 2;};  

           
configlatch: mindexn ASSIGNTO CONFIGLATCH  LBRACKET configlaflag RBRACKET {$$ = 0;} | mindexn ASSIGNTO CONFIGLATCH {$$ = 0;} |
             mindexsia ASSIGNTO CONFIGLATCH  LBRACKET configlaflag RBRACKET {$$ = 1;} | mindexsia ASSIGNTO CONFIGLATCH {$$ = 1;} |
             mindexdis ASSIGNTO CONFIGLATCH  LBRACKET configlaflag RBRACKET {$$ = 2;} | mindexdis ASSIGNTO CONFIGLATCH {$$ = 2;} ;
             
configlatch: mindexn ASSIGNTO CONFIGLATCH  LBRACKET error RBRACKET {llvmerror(&@5, "Incorrect configlatch inst! OPT flags error!"); clear();YYABORT;} |
             mindexsia ASSIGNTO CONFIGLATCH  LBRACKET error RBRACKET {llvmerror(&@5, "Incorrect configlatch inst! OPT flags error!"); clear();YYABORT;} |
             mindexdis ASSIGNTO CONFIGLATCH  LBRACKET error RBRACKET {llvmerror(&@5, "Incorrect configlatch inst! OPT flags error!"); clear();YYABORT;} ;//
             
r0setcondInstr: IMMSYM DOT IMM5 ASSIGNTO R0 DOT SETCOND LBRACKET IMM5 RBRACKET 
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $9, @9.S, @9.E);};  
r1setcondInstr: IMMSYM DOT IMM5 ASSIGNTO R1 DOT SETCOND LBRACKET IMM5 RBRACKET 
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $9, @9.S, @9.E);};  
r2setcondInstr: IMMSYM DOT IMM5 ASSIGNTO R2 DOT SETCOND LBRACKET IMM5 RBRACKET 
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $9, @9.S, @9.E);};  
r3setcondInstr: IMMSYM DOT IMM5 ASSIGNTO R3 DOT SETCOND LBRACKET IMM5 RBRACKET 
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $9, @9.S, @9.E);};  
r4setcondInstr: IMMSYM DOT IMM5 ASSIGNTO R4 DOT SETCOND LBRACKET IMM5 RBRACKET 
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $9, @9.S, @9.E);};  
r5setcondInstr: IMMSYM DOT IMM5 ASSIGNTO R5 DOT SETCOND LBRACKET IMM5 RBRACKET 
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $9, @9.S, @9.E);};  
	  
setCGInstr:   SETCG LPAREN setcgflag RPAREN |
              SETCG LPAREN error RPAREN {llvmerror(&@3, "Incorrect setCG inst! flag must be 'ON' or 'OFF' !"); clear();YYABORT;};

r0inst: mindexn ASSIGNTO r0dest {$$ = 0;} |
        M LBRACKET siaflags RBRACKET ASSIGNTO r0dest {$$ = 1;} |
        M ASSIGNTO r0dest {$$ = 1;} |
        M LBRACKET DIS _flag disflag flag_ RBRACKET ASSIGNTO r0dest {$$ = 2;} |
        M LBRACKET DIS RBRACKET ASSIGNTO r0dest {$$ = 2;};  //haoxb
        
r0inst: mindexn ASSIGNTO error {llvmerror(&@3, "invalid r0 dest!"); clear();YYABORT;} |
        M LBRACKET siaflags RBRACKET ASSIGNTO error {llvmerror(&@6, "invalid r0 dest!"); clear();YYABORT;} |
        M ASSIGNTO error {llvmerror(&@3, "invalid r0 dest!"); clear();YYABORT;} |
        M LBRACKET DIS _flag disflag flag_ RBRACKET ASSIGNTO error {llvmerror(&@9, "invalid r0 dest!"); clear();YYABORT;} |
        M LBRACKET DIS RBRACKET ASSIGNTO error {llvmerror(&@6, "invalid r0 dest!"); clear();YYABORT;} |       

	M LBRACKET error RBRACKET ASSIGNTO r0dest {llvmerror(&@3, "R0.M[flags] flags error! Available flags are t/(S++,I++,A++)/dis(shift)"); clear();YYABORT;};  //niuxx
	
r1inst: mindexn ASSIGNTO r1dest {$$ = 0;} |
        M LBRACKET siaflags RBRACKET ASSIGNTO r1dest {$$ = 1;} |
        M ASSIGNTO r1dest {$$ = 1;} |
        M LBRACKET DIS _flag disflag flag_ RBRACKET ASSIGNTO r1dest {$$ = 2;} |
        M LBRACKET DIS RBRACKET ASSIGNTO r1dest {$$ = 2;};//haoxb
        
r1inst: mindexn ASSIGNTO error {llvmerror(&@3, "invalid r1 dest!"); clear();YYABORT;} |
        M LBRACKET siaflags RBRACKET ASSIGNTO error {llvmerror(&@6, "invalid r1 dest!"); clear();YYABORT;} |
        M ASSIGNTO error {llvmerror(&@3, "invalid r1 dest!"); clear();YYABORT;} |
        M LBRACKET DIS _flag disflag flag_ RBRACKET ASSIGNTO error {llvmerror(&@9, "invalid r1 dest!"); clear();YYABORT;} |
        M LBRACKET DIS RBRACKET ASSIGNTO error {llvmerror(&@6, "invalid r1 dest!"); clear();YYABORT;} |        
           
	M LBRACKET error RBRACKET ASSIGNTO r1dest {llvmerror(&@3, "R1.M[flags] flags error! Available flags are t/(S++,I++,A++)/dis(shift)}"); clear();YYABORT;};  //niuxx
           
r2inst: mindexn ASSIGNTO r2dest {$$ = 0;} |
        M LBRACKET siaflags RBRACKET ASSIGNTO r2dest {$$ = 1;} |
        M ASSIGNTO r2dest {$$ = 1;} |
        M LBRACKET DIS _flag disflag flag_ RBRACKET ASSIGNTO r2dest {$$ = 2;} |
        M LBRACKET DIS RBRACKET ASSIGNTO r2dest {$$ = 2;};//haoxb
        
r2inst: mindexn ASSIGNTO error {llvmerror(&@3, "invalid r2 dest!"); clear();YYABORT;} |
        M LBRACKET siaflags RBRACKET ASSIGNTO error {llvmerror(&@6, "invalid r2 dest!"); clear();YYABORT;} |
        M ASSIGNTO error {llvmerror(&@3, "invalid r2 dest!"); clear();YYABORT;} |
        M LBRACKET DIS _flag disflag flag_ RBRACKET ASSIGNTO error {llvmerror(&@9, "invalid r2 dest!"); clear();YYABORT;} |
        M LBRACKET DIS RBRACKET ASSIGNTO error {llvmerror(&@6, "invalid r2 dest!"); clear();YYABORT;} |        

	M LBRACKET error RBRACKET ASSIGNTO r2dest {llvmerror(&@3, "R2.M[flags] flags error! Available flags are t/(S++,I++,A++)/dis(shift)}"); clear();YYABORT;};  //niuxx       
        
r3inst: mindexn ASSIGNTO r3dest {$$ = 0;} |
        M LBRACKET siaflags RBRACKET ASSIGNTO r3dest {$$ = 1;} |
        M ASSIGNTO r3dest {$$ = 1;} |
        M LBRACKET DIS _flag disflag flag_ RBRACKET ASSIGNTO r3dest {$$ = 2;} |
        M LBRACKET DIS RBRACKET ASSIGNTO r3dest {$$ = 2;};//haoxb
        
r3inst: mindexn ASSIGNTO error {llvmerror(&@3, "invalid r3 dest!"); clear();YYABORT;} |
        M LBRACKET siaflags RBRACKET ASSIGNTO error {llvmerror(&@6, "invalid r3 dest!"); clear();YYABORT;} |
        M ASSIGNTO error {llvmerror(&@3, "invalid r3 dest!"); clear();YYABORT;} |
        M LBRACKET DIS _flag disflag flag_ RBRACKET ASSIGNTO error {llvmerror(&@9, "invalid r3 dest!"); clear();YYABORT;} |
        M LBRACKET DIS RBRACKET ASSIGNTO error {llvmerror(&@6, "invalid r3 dest!"); clear();YYABORT;} |     

	M LBRACKET error RBRACKET ASSIGNTO r3dest {llvmerror(&@3, "R3.M[flags] flags error! Available flags are t/(S++,I++,A++)/dis(shift)}"); clear();YYABORT;};  //niuxx       
        
r4inst: mindexn ASSIGNTO r4dest {$$ = 0;} |
        M LBRACKET siaflags RBRACKET ASSIGNTO r4dest {$$ = 1;} |
        M ASSIGNTO r4dest {$$ = 1;} |
        M LBRACKET DIS _flag disflag flag_ RBRACKET ASSIGNTO r4dest {$$ = 2;} |
        M LBRACKET DIS RBRACKET ASSIGNTO r4dest {$$ = 2;};//haoxb
        
r4inst: mindexn ASSIGNTO error {llvmerror(&@3, "invalid r4 dest!"); clear();YYABORT;} |
        M LBRACKET siaflags RBRACKET ASSIGNTO error {llvmerror(&@6, "invalid r4 dest!"); clear();YYABORT;} |
        M ASSIGNTO error {llvmerror(&@3, "invalid r4 dest!"); clear();YYABORT;} |
        M LBRACKET DIS _flag disflag flag_ RBRACKET ASSIGNTO error {llvmerror(&@9, "invalid r4 dest!"); clear();YYABORT;} |
        M LBRACKET DIS RBRACKET ASSIGNTO error {llvmerror(&@6, "invalid r4 dest!"); clear();YYABORT;}|         

	M LBRACKET error RBRACKET ASSIGNTO r4dest {llvmerror(&@3, "R4.M[flags] flags error! Available flags are t/(S++,I++,A++)/dis(shift)}"); clear();YYABORT;};  //niuxx       
        
r5inst: mindexn ASSIGNTO r5dest {$$ = 0;} |
        M LBRACKET siaflags RBRACKET ASSIGNTO r5dest {$$ = 1;} |
        M ASSIGNTO r5dest {$$ = 1;} |
        M LBRACKET DIS _flag disflag flag_ RBRACKET ASSIGNTO r5dest {$$ = 2;} |
        M LBRACKET DIS RBRACKET ASSIGNTO r5dest {$$ = 2;};//haoxb
        
r5inst: mindexn ASSIGNTO error {llvmerror(&@3, "invalid r5 dest!"); clear();YYABORT;} |
        M LBRACKET siaflags RBRACKET ASSIGNTO error {llvmerror(&@6, "invalid r5 dest!"); clear();YYABORT;} |
        M ASSIGNTO error {llvmerror(&@3, "invalid r5 dest!"); clear();YYABORT;} |
        M LBRACKET DIS _flag disflag flag_ RBRACKET ASSIGNTO error {llvmerror(&@9, "invalid r5 dest!"); clear();YYABORT;} |
        M LBRACKET DIS RBRACKET ASSIGNTO error {llvmerror(&@6, "invalid r5 dest!"); clear();YYABORT;} |    

	M LBRACKET error RBRACKET ASSIGNTO r5dest {llvmerror(&@3, "R5.M[flags] flags error! Available flags are t/(S++,I++,A++)/dis(shift)}"); clear();YYABORT;};  //niuxx
        

mr012345slot: R0 DOT error { llvmerror(&@1, "Incorrect M.r0 inst."); clear();YYABORT;} |
           R1 DOT error { llvmerror(&@1, "Incorrect M.r1 inst."); clear();YYABORT;} |
           R2 DOT error { llvmerror(&@1, "Incorrect M.r2 inst."); clear();YYABORT;} |
           R3 DOT error { llvmerror(&@1, "Incorrect M.r3 inst."); clear();YYABORT;} |
           R4 DOT error { llvmerror(&@1, "Incorrect M.r4 inst."); clear();YYABORT;} |
           R5 DOT error { llvmerror(&@1, "Incorrect M.r5 inst."); clear();YYABORT;} ;
           

r0dest: ialut | imact | shu0t | biu0t ;
r1dest: ialut | imact | shu1t | biu1t;
r2dest: ialut | imact | shu2t | biu2t ;
r3dest: ifalut | ifmact | shu0t |biu0t;
r4dest: ifalut | ifmact | shu1t | biu1t ;
r5dest: ifalut | ifmact | shu2t | biu2t ;
biut: biu0t | biu1t | biu2t ;
shut: shu0t | shu1t | shu2t ;

//ialu_shut:ialu_shu0t | ialu_shu1t | ialu_shu2t ;//haoxb
//ialu_maccdest:ialu_ialut | ialu_ifalut | ialu_imact |ialu_ifmact ;//haoxb
//ialu_biut:ialu_biu0t | ialu_biu1t |ialu_biu2t ;



shubiut : sbiu0t | sbiu1t | sbiu2t ;
biushute : bshu0te | bshu1te | bshu2te ;
// end mreg -------------------------------------------------- 


// start shu --------------------------------------------------
shuslot: shu0code { if(hasErr)
                    {  hasErr = false;
                       llvmerror(&@1, "Incorrect SHU0 inst.");clear();YYABORT;
                    }
                    $$ = 0;
                  } 
       | shu1code { if(hasErr)
                    {  hasErr = false;
                       llvmerror(&@1, "Incorrect SHU1 inst.");clear();YYABORT;
                    }
                    $$ = 1;
                   } 
       | shu2code { if(hasErr)
                    {  hasErr = false;
                       llvmerror(&@1, "Incorrect SHU2 inst.");clear();YYABORT;
                    }
                    $$ = 2;
                   } ;
shu0code: SHU0 DOT shu0inst  | shu0setcondInstr;
shu1code: SHU1 DOT shu1inst  | shu1setcondInstr;
shu2code: SHU2 DOT shu2inst  | shu2setcondInstr;


shuslot:   SHU0 DOT error { llvmerror(&@1, "Incorrect SHU0 inst."); clear();YYABORT;} |
           SHU1 DOT error { llvmerror(&@1, "Incorrect SHU1 inst."); clear();YYABORT;} |
           SHU2 DOT error { llvmerror(&@1, "Incorrect SHU2 inst."); clear();YYABORT;} ;
shu0inst: ucpshuexp ASSIGNTO shu0destTol {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU0_IND inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_IND inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_IND inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_IND inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_IND inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }

      flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
      flagsort = flags[SHIFTF];
      dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
      flags.reset();
  
  switch ($3) {
    case 0://shu0
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TSetTBToSHU, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//ts
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TKSetTBToSHU, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//ts
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU0Ind_VTKSetTBToSHU, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//ts
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      break;    
   case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU0Ind_TNSetTBToSHU, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      break;
      
    default :
    llvmerror(&@1, "invalid SHU0Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU0Ind instruction");
    //break;
    }
    break;
    
  case 1://BIU
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TSetTBToBIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//ts
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TKSetTBToBIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU0Ind_VTKSetTBToBIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
   case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU0Ind_TNSetTBToBIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default :
    llvmerror(&@1, "invalid SHU0Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU0Ind instruction");
    //break;
    }
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TSetTBToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tp
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TKSetTBToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU0Ind_VTKSetTBToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tp
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU0Ind_TNSetTBToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU0Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU0Ind instruction");
    //break;
    }
    break;
    
  case 3://m[t]
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TSetTBToM, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tp
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TKSetTBToM, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU0Ind_VTKSetTBToM, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU0Ind_TNSetTBToM, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU0Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU0Ind instruction");
    //break;
    }
    break;
    
  case 4://m[s++,i++,a++]
    switch ($1) {
    case 0: //+=
      ADDOPERAND(Opc, UCPM::SHU0Ind_TSetTBToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TKSetTBToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU0Ind_VTKSetTBToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU0Ind_TNSetTBToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU0Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU0Ind instruction");
    //break;
    }
    break;
    
    case 5://m[dis]
    switch ($1) {
    case 0: //+=
      ADDOPERAND(Opc, UCPM::SHU0Ind_TSetTBToDis, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TKSetTBToDIS, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU0Ind_VTKSetTBToDIS, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU0Ind_TNSetTBToDis, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU0Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU0Ind instruction");
    //break;
    }
    break;
  default: 
  llvmerror(&@3, "invalid SHU0 dest!");clear();YYABORT;
    //llvm_unreachable("invalid SHU0 dest");
  //break;
  }

}
/*
|ucpshuexp1 ASSIGNTO shu0destTol {
	
	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
  case 0://shu0
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TSetTBToSHU_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TKSetTBToSHU_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU0Ind_VTKSetTBToSHU_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      break;    
   case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU0Ind_TNSetTBToSHU_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      break;
      
    default :
    llvmerror(&@1, "invalid SHU0Ind instruction!");
    //llvm_unreachable("invalid SHU0Ind instruction");
    //break;
    }
    break;
    
  case 1://BIU
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TSetTBToBIU_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TKSetTBToBIU_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU0Ind_VTKSetTBToBIU_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
   case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU0Ind_TNSetTBToBIU_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default :
    llvmerror(&@1, "invalid SHU0Ind instruction!");
    //llvm_unreachable("invalid SHU0Ind instruction");
    //break;
    }
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TSetTBToMACC_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tp
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TKSetTBToMACC_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU0Ind_VTKSetTBToMACC_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tp
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU0Ind_TNSetTBToMACC_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU0Ind instruction!");
    //llvm_unreachable("invalid SHU0Ind instruction");
    //break;
    }
    break;
    
  case 3://m[t]
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TSetTBToM_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tp
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TKSetTBToM_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU0Ind_VTKSetTBToM_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU0Ind_TNSetTBToM_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU0Ind instruction!");
    //llvm_unreachable("invalid SHU0Ind instruction");
    //break;
    }
    break;
    
  case 4://m[s++,i++,a++]
    switch ($1) {
    case 0: //+=
      ADDOPERAND(Opc, UCPM::SHU0Ind_TSetTBToMSIA_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TKSetTBToMSIA_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU0Ind_VTKSetTBToMSIA_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU0Ind_TNSetTBToMSIA_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU0Ind instruction!");
    //llvm_unreachable("invalid SHU0Ind instruction");
    //break;
    }
    break;
    
    case 5://m[dis]
    switch ($1) {
    case 0: //+=
      ADDOPERAND(Opc, UCPM::SHU0Ind_TSetTBToDis_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TKSetTBToDIS_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU0Ind_VTKSetTBToDIS_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU0Ind_TNSetTBToDis_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU0Ind instruction!");
    //llvm_unreachable("invalid SHU0Ind instruction");
    //break;
    }
    break;
  default: 
  llvmerror(&@1, "invalid SHU0 dest!");
    //llvm_unreachable("invalid SHU0 dest");
  //break;
  }

}*/
| t IND shuts {
      ADDOPERAND(Opc, UCPM::SHU0Ind_nodest, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
}
|ucpshuexp2 ASSIGNTO shu0destTol {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU0_IND inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_IND inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_IND inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_IND inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_IND inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
	
  flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
  sia = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = flags[SHIFTF];
  dis = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flags.reset();
        
  switch ($3) {
  case 0://shu0
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TSetTBToSHU_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TKSetTBToSHU_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU0Ind_VTKSetTBToSHU_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      break;    
   case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU0Ind_TNSetTBToSHU_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      break;
      
    default :
    llvmerror(&@1, "invalid SHU0Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU0Ind instruction");
    //break;
    }
    break;
    
  case 1://BIU
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TSetTBToBIU_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TKSetTBToBIU_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU0Ind_VTKSetTBToBIU_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
   case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU0Ind_TNSetTBToBIU_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default :
    llvmerror(&@1, "invalid SHU0Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU0Ind instruction");
    //break;
    }
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TSetTBToMACC_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tp
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TKSetTBToMACC_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU0Ind_VTKSetTBToMACC_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tp
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU0Ind_TNSetTBToMACC_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU0Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU0Ind instruction");
    //break;
    }
    break;
    
  case 3://m[t]
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TSetTBToM_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tp
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TKSetTBToM_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU0Ind_VTKSetTBToM_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU0Ind_TNSetTBToM_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU0Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU0Ind instruction");
    //break;
    }
    break;
    
  case 4://m[s++,i++,a++]
    switch ($1) {
    case 0: //+=
      ADDOPERAND(Opc, UCPM::SHU0Ind_TSetTBToMSIA_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TKSetTBToMSIA_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU0Ind_VTKSetTBToMSIA_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU0Ind_TNSetTBToMSIA_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU0Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU0Ind instruction");
    //break;
    }
    break;
    
    case 5://m[dis]
    switch ($1) {
    case 0: //+=
      ADDOPERAND(Opc, UCPM::SHU0Ind_TSetTBToDis_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU0Ind_TKSetTBToDIS_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU0Ind_VTKSetTBToDIS_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU0Ind_TNSetTBToDis_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU0Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU0Ind instruction");
    //break;
    }
    break;
  default: 
  llvmerror(&@3, "invalid SHU0 dest!");clear();YYABORT;
    //llvm_unreachable("invalid SHU0 dest");
  //break;
  }

}
| shuadd_tt ASSIGNTO shu0_shu0dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU0_Add inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Add inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Add inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Add inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Add inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
	           
    	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU0ADDToNo_VTt_Tm, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU0ADDToNo_Tt_Tm, @$.S, @$.E);} 
      
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    break;
    
  case 1://BIU
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU0ADDToBIU_VTt_Tm, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU0ADDToBIU_Tt_Tm, @$.S, @$.E);} 
      
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU0ADDToMACC_VTt_Tm, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU0ADDToMACC_Tt_Tm, @$.S, @$.E);} 
    
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    break;
    
  case 3://m[t]
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU0ADDToM_VTt_Tm, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU0ADDToM_Tt_Tm, @$.S, @$.E);} 
    
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    break;
    
  case 4://m[s++,i++,a++]
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU0ADDToMSIA_VTt_Tm, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU0ADDToMSIA_Tt_Tm, @$.S, @$.E);} 
    
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU0ADDToMDIS_VTt_Tm, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU0ADDToMDIS_Tt_Tm, @$.S, @$.E);} 
  
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU0 dest!");clear();YYABORT;
    //llvm_unreachable("invalid SHU0 dest");
  //break;
  }

}
| shuadd_tt ASSIGNTO shu0_shu0TBdest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU0_Add inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Add inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Add inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Add inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Add inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
    	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU0ADDToNo_VTt_TB, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU0ADDToNo_Tt_TB, @$.S, @$.E);} 
      
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt   
    break;
    
  case 1://BIU
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU0ADDToBIU_VTt_TB, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU0ADDToBIU_Tt_TB, @$.S, @$.E);} 
      
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt    
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU0ADDToMACC_VTt_TB, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU0ADDToMACC_Tt_TB, @$.S, @$.E);} 
    
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt    
    break;
    
  case 3://m[t]
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU0ADDToM_VTt_TB, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU0ADDToM_Tt_TB, @$.S, @$.E);} 
    
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt    
    break;
    
  case 4://m[s++,i++,a++]
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU0ADDToMSIA_VTt_TB, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU0ADDToMSIA_Tt_TB, @$.S, @$.E);} 
    
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt    
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU0ADDToMDIS_VTt_TB, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU0ADDToMDIS_Tt_TB, @$.S, @$.E);} 
  
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt    
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU0 dest!");clear();YYABORT;
    //llvm_unreachable("invalid SHU0 dest");
  //break;
  }

}
| shuadd_imm7 ASSIGNTO shu0_shu0dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU0_Add inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Add inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Add inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Add inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Add inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
    	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
    ADDOPERAND(Opc, UCPM::SHU0ADDToNo_imm7_Tm, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    break;
    
  case 1://BIU
    ADDOPERAND(Opc, UCPM::SHU0ADDToBIU_imm7_Tm, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    ADDOPERAND(Opc, UCPM::SHU0ADDToMACC_imm7_Tm, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    break;
    
  case 3://m[t]
    ADDOPERAND(Opc, UCPM::SHU0ADDToM_imm7_Tm, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    break;
    
  case 4://m[s++,i++,a++]
    ADDOPERAND(Opc, UCPM::SHU0ADDToMSIA_imm7_Tm, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
    ADDOPERAND(Opc, UCPM::SHU0ADDToMDIS_imm7_Tm, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU0 dest!");clear();YYABORT;
    //llvm_unreachable("invalid SHU0 dest");
  //break;
  }

}
| shuadd_imm7 ASSIGNTO shu0_shu0TBdest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU0_Add inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Add inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Add inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Add inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Add inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
    	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
    ADDOPERAND(Opc, UCPM::SHU0ADDToNo_imm7_TB, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    break;
    
  case 1://BIU
    ADDOPERAND(Opc, UCPM::SHU0ADDToBIU_imm7_TB, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    ADDOPERAND(Opc, UCPM::SHU0ADDToMACC_imm7_TB, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    break;
    
  case 3://m[t]
    ADDOPERAND(Opc, UCPM::SHU0ADDToM_imm7_TB, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    break;
    
  case 4://m[s++,i++,a++]
    ADDOPERAND(Opc, UCPM::SHU0ADDToMSIA_imm7_TB, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
    ADDOPERAND(Opc, UCPM::SHU0ADDToMDIS_imm7_TB, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU0 dest!");clear();YYABORT;
    //llvm_unreachable("invalid SHU0 dest");
  //break;
  }

}
| shustepextclause ASSIGNTO shu0_shu0dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU0_StepExt inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_StepExt inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_StepExt inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_StepExt inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_StepExt inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }	     
	     
      if(flags[ODDF])
      {
	if(flags[TF])
	  flagsort = 0b0101;
	else if(flags[FF])
	  flagsort = 0b1001;   
	else if(flags[EF])
	  flagsort = 0b1101; 
	else
	  flagsort = 0b0001;
      }
      else if(flags[HF])
      {
	if(flags[TF])
	  flagsort = 0b0101;
	else if(flags[FF])
	  flagsort = 0b1001;  
	else if(flags[EF])
	  flagsort = 0b1101; 
	else
	  flagsort = 0b0001;  
      }
      else
      {
	if(flags[TF])
	  flagsort = 0b0100;
	else if(flags[FF])
	  flagsort = 0b1000;
	else if(flags[EF])
	  flagsort = 0b1100; 
	else
	  flagsort = 0b0000;     
      }
        
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
    	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
    ADDOPERAND(Opc, UCPM::SHU0StepExtToNo, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 1://BIU
    ADDOPERAND(Opc, UCPM::SHU0StepExtToBIU, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    ADDOPERAND(Opc, UCPM::SHU0StepExtToMACC, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 3://m[t]
    ADDOPERAND(Opc, UCPM::SHU0StepExtToM, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 4://m[s++,i++,a++]
    ADDOPERAND(Opc, UCPM::SHU0StepExtToMSIA, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
    ADDOPERAND(Opc, UCPM::SHU0StepExtToDIS, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU0 dest!");clear();YYABORT;
    //llvm_unreachable("invalid SHU0 dest");
  //break;
  }

}
| shushift_Tclause ASSIGNTO shu0_shu0dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU0_Shift inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Shift inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Shift inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Shift inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Shift inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
      if(flags[RF])
      {
      if(flags[OF])
        flagsort = 0b00;      
      else
        flagsort = 0b10;     
      }
      else
      {
        flagsort = 0b11;
      }
        
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
    	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
    ADDOPERAND(Opc, UCPM::SHU0shiftToNo_T, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 1://BIU
    ADDOPERAND(Opc, UCPM::SHU0shiftToBIU_T, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    ADDOPERAND(Opc, UCPM::SHU0shiftToMACC_T, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 3://m[t]
    ADDOPERAND(Opc, UCPM::SHU0shiftToM_T, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 4://m[s++,i++,a++]
    ADDOPERAND(Opc, UCPM::SHU0shiftToMSIA_T, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
    ADDOPERAND(Opc, UCPM::SHU0shiftToDIS_T, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU0 dest!");clear();YYABORT;
    //llvm_unreachable("invalid SHU0 dest");
  //break;
  }

}
| shushift_IMMclause ASSIGNTO shu0_shu0dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU0_Shift inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Shift inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Shift inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Shift inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Shift inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
      if(flags[RF])
      {
      if(flags[OF])
        flagsort = 0b00;      
      else
        flagsort = 0b10;     
      }
      else
      {
      if(flags[OF])
        flagsort = 0b11;
      else
        flagsort = 0b01;     
      }
        
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
    	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
    ADDOPERAND(Opc, UCPM::SHU0shiftToNo_IMM, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 1://BIU
    ADDOPERAND(Opc, UCPM::SHU0shiftToBIU_IMM, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    ADDOPERAND(Opc, UCPM::SHU0shiftToMACC_IMM, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 3://m[t]
    ADDOPERAND(Opc, UCPM::SHU0shiftToM_IMM, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 4://m[s++,i++,a++]
    ADDOPERAND(Opc, UCPM::SHU0shiftToMSIA_IMM, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
    ADDOPERAND(Opc, UCPM::SHU0shiftToDIS_IMM, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU0 dest!");clear();YYABORT;
    //llvm_unreachable("invalid SHU0 dest");
  //break;
  }

}
| shubyteclause ASSIGNTO shu0_shu0dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU0_Byte inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Byte inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Byte inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Byte inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Byte inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }

	flagsort = (~(flags[UF]) << 4) ;
      
      if(flags[BF])
      {
      if(flags[TF])
        flagsort |= 0b00100;
      else if(flags[FF])
	flagsort |= 0b01000;
      else
        flagsort |= 0b00000;     
      }
      else if(flags[SF])
      {
      if(flags[TF])
        flagsort |= 0b00101;
      else if(flags[FF])
	flagsort |= 0b01001;
      else
        flagsort |= 0b00001;     
      }
      else
      {
      if(flags[TF])
        flagsort |= 0b00110;
      else if(flags[FF])
	flagsort |= 0b01010;
      else
        flagsort |= 0b00010;     
      }
        
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
    	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
    ADDOPERAND(Opc, UCPM::SHU0ByteToNo, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 1://BIU
    ADDOPERAND(Opc, UCPM::SHU0ByteToBIU, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    ADDOPERAND(Opc, UCPM::SHU0ByteToMACC, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 3://m[t]
    ADDOPERAND(Opc, UCPM::SHU0ByteToM, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 4://m[s++,i++,a++]
    ADDOPERAND(Opc, UCPM::SHU0ByteToMSIA, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
    ADDOPERAND(Opc, UCPM::SHU0ByteToDIS, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU0 dest!");clear();YYABORT;
    //llvm_unreachable("invalid SHU0 dest");
  //break;
  }

}
| shubitclause ASSIGNTO shu0_shu0dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU0_Bit inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Bit inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Bit inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Bit inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Bit inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
      if(flags[BF])
      {
      if(flags[TF])
        flagsort = 0b0100;
      else if(flags[FF])
	flagsort = 0b1000;
      else
        flagsort = 0b0000;     
      }
      else if(flags[SF])
      {
      if(flags[TF])
        flagsort = 0b0101;
      else if(flags[FF])
	flagsort = 0b1001;
      else
        flagsort = 0b0001;     
      }
      else
      {
      if(flags[TF])
        flagsort = 0b0110;
      else if(flags[FF])
	flagsort = 0b1010;
      else
        flagsort = 0b0010;     
      }
        
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
    	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
    ADDOPERAND(Opc, UCPM::SHU0BitToNo, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    break;
    
  case 1://BIU
    ADDOPERAND(Opc, UCPM::SHU0BitToBIU, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    ADDOPERAND(Opc, UCPM::SHU0BitToMACC, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    break;
    
  case 3://m[t]
    ADDOPERAND(Opc, UCPM::SHU0BitToM, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    break;
    
  case 4://m[s++,i++,a++]
    ADDOPERAND(Opc, UCPM::SHU0BitToMSIA, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
    ADDOPERAND(Opc, UCPM::SHU0BitToDIS, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU0 dest!");clear();YYABORT;
    //llvm_unreachable("invalid SHU0 dest");
  //break;
  }

}
| shunotclause ASSIGNTO shu0_shu0dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU0_Not inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Not inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Not inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Not inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Not inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
    ADDOPERAND(Opc, UCPM::SHU0NOTToNo, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    break;
    
  case 1://BIU
    ADDOPERAND(Opc, UCPM::SHU0NOTToBIU, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    ADDOPERAND(Opc, UCPM::SHU0NOTToMACC, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts    
    break;
    
  case 3://m[t]
    ADDOPERAND(Opc, UCPM::SHU0NOTToM, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));      
    break;
    
  case 4://m[s++,i++,a++]
    ADDOPERAND(Opc, UCPM::SHU0NOTToMSIA, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));      
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
    ADDOPERAND(Opc, UCPM::SHU0NOTToDIS, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));      
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU0 dest!");clear();YYABORT;
  //break;
  }

}
| shulogicclause ASSIGNTO shu0_shu0dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU0_Logic inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Logic inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Logic inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Logic inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU0_Logic inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
    ADDOPERAND(Opc, UCPM::SHU0LogicToNo, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
    break;
   
  case 1://BIU
    ADDOPERAND(Opc, UCPM::SHU0LogicToSHU_BIU, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    ADDOPERAND(Opc, UCPM::SHU0LogicToSHU_MACC, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
    break;
    
  case 3://m[t]
    ADDOPERAND(Opc, UCPM::SHU0LogicToSHU_M, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));      
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
    break;
    
  case 4://m[s++,i++,a++]
    ADDOPERAND(Opc, UCPM::SHU0LogicToSHU_MSIA, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));      
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
    ADDOPERAND(Opc, UCPM::SHU0LogicToSHU_DIS, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));      
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU0 dest!");clear();YYABORT;
  //break;
  }

}
| shuimm_tbInstr{
      
      
      if(flags[OF])
        flagsort = 0b0001;
      else if(flags[TF])
	flagsort = 0b0010;
      else if(flags[FF])
	flagsort = 0b0011;
      else if(flags[ZF])
	flagsort = 0b0100;
      else
        flagsort = 0b0000;          
        
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();
      
      ADDOPERAND(Opc, UCPM::SHU0ImmTB, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
}
| shuimm_immInstr{
      
      
      if(flags[OF])
        flagsort = 0b0001;
      else if(flags[TF])
	flagsort = 0b0010;
      else if(flags[FF])
	flagsort = 0b0011;
      else if(flags[ZF])
	flagsort = 0b0100;
      else
        flagsort = 0b0000;          
        
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();
      
      ADDOPERAND(Opc, UCPM::SHU0ImmImm, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm2));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
}
| shuwaitInstr{
            
      ADDOPERAND(Opc, UCPM::SHU0Wait, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    
}
| setCGInstr{
            
          flagsort = (flags[ONF]);
          f = OPERAND(Imm, flagsort, FlagS, FlagE);	
	  flags.reset();
	   
	    ADDOPERAND(Opc, UCPM::SHU0SetCG, @$.S, @$.E);
	    Operands.push_back(nullptr);
	    condpos = Operands.size();
	    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));  
    
};

shu1inst: ucpshuexp ASSIGNTO shu1destTol {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU1_IND inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_IND inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_IND inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_IND inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_IND inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }

	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://shu1
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU1Ind_TSetTBToSHU, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//ts
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU1Ind_TKSetTBToSHU, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//ts
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU1Ind_VTKSetTBToSHU, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//ts
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      break;    
   case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU1Ind_TNSetTBToSHU, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      break;
      
    default :
    llvmerror(&@1, "invalid SHU1Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU1Ind instruction");
    //break;
    }
    break;
    
  case 1://BIU
       switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU1Ind_TSetTBToBIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
     /*  if (ipath == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));*/
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tp
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU1Ind_TKSetTBToBIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    /*  if (ipath == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));*/
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));   
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU1Ind_VTKSetTBToBIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    /*  if (ipath == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));*/
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));//tp
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU1Ind_TNSetTBToBIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
  /*    if (ipath == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));*/
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU1Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU1Ind instruction");
    //break;
    }
    break;
  
  case 2://ialut, imact, ifalut, ifmacct
    switch ($1) {
    case 0: //+=
      ADDOPERAND(Opc, UCPM::SHU1Ind_TSetTBToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tp
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU1Ind_TKSetTBToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU1Ind_VTKSetTBToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU1Ind_TNSetTBToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU1Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU1Ind instruction");
    //break;
    }
    break;
    
  case 3://m[t]
    switch ($1) {
    case 0: //+=
      ADDOPERAND(Opc, UCPM::SHU1Ind_TSetTBToM, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tp
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU1Ind_TKSetTBToM, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU1Ind_VTKSetTBToM, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU1Ind_TNSetTBToM, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU1Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU1Ind instruction");
    //break;
    }
    break;
    
  case 4://m[s++,i++,a++]
    switch ($1) {
    case 0: //+=
      ADDOPERAND(Opc, UCPM::SHU1Ind_TSetTBToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU1Ind_TKSetTBToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU1Ind_VTKSetTBToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU1Ind_TNSetTBToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU1Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU1Ind instruction");
    //break;
    }
    break;
    
  case 5://m[dis]
    switch ($1) {
    case 0: //+=
      ADDOPERAND(Opc, UCPM::SHU1Ind_TSetTBToDis, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //=+
      ADDOPERAND(Opc, UCPM::SHU1Ind_TKSetTBToDIS, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //tb,no imm
      ADDOPERAND(Opc, UCPM::SHU1Ind_VTKSetTBToDIS, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU1Ind_TNSetTBToDis, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU1Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU1Ind instruction");
    //break;
    }
    break;
  default: 
  llvmerror(&@3, "invalid SHU1 dest!");clear();YYABORT;
    //llvm_unreachable("invalid SHU1 dest");
  //break;
  }

}
/*
|ucpshuexp1 ASSIGNTO shu1destTol {
	
	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
  case 0://shu1
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU1Ind_TSetTBToSHU_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU1Ind_TKSetTBToSHU_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU1Ind_VTKSetTBToSHU_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      break;    
   case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU1Ind_TNSetTBToSHU_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      break;
      
    default :
    llvmerror(&@1, "invalid SHU1Ind instruction!");
    //llvm_unreachable("invalid SHU1Ind instruction");
    //break;
    }
    break;
    
  case 1://BIU
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU1Ind_TSetTBToBIU_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU1Ind_TKSetTBToBIU_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU1Ind_VTKSetTBToBIU_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
   case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU1Ind_TNSetTBToBIU_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default :
    llvmerror(&@1, "invalid SHU1Ind instruction!");
    //llvm_unreachable("invalid SHU1Ind instruction");
    //break;
    }
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU1Ind_TSetTBToMACC_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tp
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU1Ind_TKSetTBToMACC_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU1Ind_VTKSetTBToMACC_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tp
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU1Ind_TNSetTBToMACC_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU1Ind instruction!");
    //llvm_unreachable("invalid SHU1Ind instruction");
    //break;
    }
    break;
    
  case 3://m[t]
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU1Ind_TSetTBToM_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tp
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU1Ind_TKSetTBToM_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU1Ind_VTKSetTBToM_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU1Ind_TNSetTBToM_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU1Ind instruction!");
    //llvm_unreachable("invalid SHU1Ind instruction");
    //break;
    }
    break;
    
  case 4://m[s++,i++,a++]
    switch ($1) {
    case 0: //+=
      ADDOPERAND(Opc, UCPM::SHU1Ind_TSetTBToMSIA_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU1Ind_TKSetTBToMSIA_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU1Ind_VTKSetTBToMSIA_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU1Ind_TNSetTBToMSIA_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU1Ind instruction!");
    //llvm_unreachable("invalid SHU1Ind instruction");
    //break;
    }
    break;
    
    case 5://m[dis]
    switch ($1) {
    case 0: //+=
      ADDOPERAND(Opc, UCPM::SHU1Ind_TSetTBToDis_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU1Ind_TKSetTBToDIS_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU1Ind_VTKSetTBToDIS_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU1Ind_TNSetTBToDis_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU1Ind instruction!");
    //llvm_unreachable("invalid SHU1Ind instruction");
    //break;
    }
    break;
  default: 
  llvmerror(&@1, "invalid SHU1 dest!");
    //llvm_unreachable("invalid SHU1 dest");
  //break;
  }

}*/
| t IND shuts {
      ADDOPERAND(Opc, UCPM::SHU1Ind_nodest, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
}
|ucpshuexp2 ASSIGNTO shu1destTol {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU1_IND inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_IND inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_IND inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_IND inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_IND inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }

	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://shu1
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU1Ind_TSetTBToSHU_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU1Ind_TKSetTBToSHU_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU1Ind_VTKSetTBToSHU_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      break;    
   case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU1Ind_TNSetTBToSHU_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      break;
      
    default :
    llvmerror(&@1, "invalid SHU1Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU1Ind instruction");
    //break;
    }
    break;
    
  case 1://BIU
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU1Ind_TSetTBToBIU_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU1Ind_TKSetTBToBIU_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU1Ind_VTKSetTBToBIU_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
   case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU1Ind_TNSetTBToBIU_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default :
    llvmerror(&@1, "invalid SHU1Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU1Ind instruction");
    //break;
    }
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU1Ind_TSetTBToMACC_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tp
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU1Ind_TKSetTBToMACC_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU1Ind_VTKSetTBToMACC_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tp
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU1Ind_TNSetTBToMACC_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU1Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU1Ind instruction");
    //break;
    }
    break;
    
  case 3://m[t]
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU1Ind_TSetTBToM_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tp
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU1Ind_TKSetTBToM_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU1Ind_VTKSetTBToM_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU1Ind_TNSetTBToM_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU1Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU1Ind instruction");
    //break;
    }
    break;
    
  case 4://m[s++,i++,a++]
    switch ($1) {
    case 0: //+=
      ADDOPERAND(Opc, UCPM::SHU1Ind_TSetTBToMSIA_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU1Ind_TKSetTBToMSIA_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU1Ind_VTKSetTBToMSIA_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU1Ind_TNSetTBToMSIA_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU1Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU1Ind instruction");
    //break;
    }
    break;
    
    case 5://m[dis]
    switch ($1) {
    case 0: //+=
      ADDOPERAND(Opc, UCPM::SHU1Ind_TSetTBToDis_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU1Ind_TKSetTBToDIS_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU1Ind_VTKSetTBToDIS_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU1Ind_TNSetTBToDis_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU1DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU1Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU1Ind instruction");
    //break;
    }
    break;
  default: 
  llvmerror(&@3, "invalid SHU1 dest!");clear();YYABORT;
    //llvm_unreachable("invalid SHU1 dest");
  //break;
  }

}
| shuadd_tt ASSIGNTO shu1_shu1dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU1_Add inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Add inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Add inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Add inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Add inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
    	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU1ADDToNo_VTt_Tm, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU1ADDToNo_Tt_Tm, @$.S, @$.E);} 
      
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    break;
    
  case 1://BIU
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU1ADDToBIU_VTt_Tm, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU1ADDToBIU_Tt_Tm, @$.S, @$.E);} 
      
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU1ADDToMACC_VTt_Tm, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU1ADDToMACC_Tt_Tm, @$.S, @$.E);} 
    
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    break;
    
  case 3://m[t]
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU1ADDToM_VTt_Tm, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU1ADDToM_Tt_Tm, @$.S, @$.E);} 
    
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    break;
    
  case 4://m[s++,i++,a++]
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU1ADDToMSIA_VTt_Tm, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU1ADDToMSIA_Tt_Tm, @$.S, @$.E);} 
    
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU1ADDToMDIS_VTt_Tm, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU1ADDToMDIS_Tt_Tm, @$.S, @$.E);} 
  
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU1 dest!");clear();YYABORT;
  //llvm_unreachable("invalid SHU1 dest");
  //break;
  }

}
| shuadd_tt ASSIGNTO shu1_shu1TBdest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU1_Add inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Add inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Add inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Add inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Add inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
    	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU1ADDToNo_VTt_TB, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU1ADDToNo_Tt_TB, @$.S, @$.E);} 
      
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt   
    break;
    
  case 1://BIU
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU1ADDToBIU_VTt_TB, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU1ADDToBIU_Tt_TB, @$.S, @$.E);} 
      
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt    
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU1ADDToMACC_VTt_TB, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU1ADDToMACC_Tt_TB, @$.S, @$.E);} 
    
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt    
    break;
    
  case 3://m[t]
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU1ADDToM_VTt_TB, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU1ADDToM_Tt_TB, @$.S, @$.E);} 
    
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt    
    break;
    
  case 4://m[s++,i++,a++]
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU1ADDToMSIA_VTt_TB, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU1ADDToMSIA_Tt_TB, @$.S, @$.E);} 
    
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt    
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU1ADDToMDIS_VTt_TB, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU1ADDToMDIS_Tt_TB, @$.S, @$.E);} 
  
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt    
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU1 dest!");clear();YYABORT;
  //llvm_unreachable("invalid SHU1 dest");
  //break;
  }

}
| shuadd_imm7 ASSIGNTO shu1_shu1dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU1_Add inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Add inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Add inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Add inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Add inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
    	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
    ADDOPERAND(Opc, UCPM::SHU1ADDToNo_imm7_Tm, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    break;
    
  case 1://BIU
    ADDOPERAND(Opc, UCPM::SHU1ADDToBIU_imm7_Tm, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    ADDOPERAND(Opc, UCPM::SHU1ADDToMACC_imm7_Tm, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    break;
    
  case 3://m[t]
    ADDOPERAND(Opc, UCPM::SHU1ADDToM_imm7_Tm, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    break;
    
  case 4://m[s++,i++,a++]
    ADDOPERAND(Opc, UCPM::SHU1ADDToMSIA_imm7_Tm, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
    ADDOPERAND(Opc, UCPM::SHU1ADDToMDIS_imm7_Tm, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU1 dest!");clear();YYABORT;
  //llvm_unreachable("invalid SHU1 dest");
  //break;
  }

}
| shuadd_imm7 ASSIGNTO shu1_shu1TBdest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU1_Add inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Add inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Add inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Add inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Add inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
    	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
    ADDOPERAND(Opc, UCPM::SHU1ADDToNo_imm7_TB, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    break;
    
  case 1://BIU
    ADDOPERAND(Opc, UCPM::SHU1ADDToBIU_imm7_TB, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    ADDOPERAND(Opc, UCPM::SHU1ADDToMACC_imm7_TB, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    break;
    
  case 3://m[t]
    ADDOPERAND(Opc, UCPM::SHU1ADDToM_imm7_TB, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    break;
    
  case 4://m[s++,i++,a++]
    ADDOPERAND(Opc, UCPM::SHU1ADDToMSIA_imm7_TB, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
    ADDOPERAND(Opc, UCPM::SHU1ADDToMDIS_imm7_TB, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU1 dest!");clear();YYABORT;
  //llvm_unreachable("invalid SHU1 dest");
  //break;
  }

}
| shustepextclause ASSIGNTO shu1_shu1dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU1_StepExt inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_StepExt inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_StepExt inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_StepExt inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_StepExt inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }

      if(flags[ODDF])
      {
	if(flags[TF])
	  flagsort = 0b0101;
	else if(flags[FF])
	  flagsort = 0b1001;   
	else if(flags[EF])
	  flagsort = 0b1101; 
	else
	  flagsort = 0b0001;
      }
      else if(flags[HF])
      {
	if(flags[TF])
	  flagsort = 0b0101;
	else if(flags[FF])
	  flagsort = 0b1001; 
	else if(flags[EF])
	  flagsort = 0b1101; 
	else
	  flagsort = 0b0001;  
      }
      else
      {
	if(flags[TF])
	  flagsort = 0b0100;
	else if(flags[FF])
	  flagsort = 0b1000;
	else if(flags[EF])
	  flagsort = 0b1100; 
	else
	  flagsort = 0b0000;     
      }
        
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
    	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
    ADDOPERAND(Opc, UCPM::SHU1StepExtToNo, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 1://BIU
    ADDOPERAND(Opc, UCPM::SHU1StepExtToBIU, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    ADDOPERAND(Opc, UCPM::SHU1StepExtToMACC, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 3://m[t]
    ADDOPERAND(Opc, UCPM::SHU1StepExtToM, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 4://m[s++,i++,a++]
    ADDOPERAND(Opc, UCPM::SHU1StepExtToMSIA, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
    ADDOPERAND(Opc, UCPM::SHU1StepExtToDIS, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU1 dest!");clear();YYABORT;
  //llvm_unreachable("invalid SHU1 dest");
  //break;
  }

}
| shushift_Tclause ASSIGNTO shu1_shu1dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU1_Shift inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Shift inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Shift inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Shift inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Shift inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
      if(flags[RF])
      {
      if(flags[OF])
        flagsort = 0b00;      
      else
        flagsort = 0b10;     
      }
      else
      {
      if(flags[OF])
        flagsort = 0b11;
      else
        flagsort = 0b01;     
      }
        
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
    	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
    ADDOPERAND(Opc, UCPM::SHU1shiftToNo_T, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 1://BIU
    ADDOPERAND(Opc, UCPM::SHU1shiftToBIU_T, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    ADDOPERAND(Opc, UCPM::SHU1shiftToMACC_T, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 3://m[t]
    ADDOPERAND(Opc, UCPM::SHU1shiftToM_T, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 4://m[s++,i++,a++]
    ADDOPERAND(Opc, UCPM::SHU1shiftToMSIA_T, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
    ADDOPERAND(Opc, UCPM::SHU1shiftToDIS_T, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU1 dest!");clear();YYABORT;
  //llvm_unreachable("invalid SHU1 dest");
  //break;
  }

}
| shushift_IMMclause ASSIGNTO shu1_shu1dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU1_Shift inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Shift inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Shift inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Shift inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Shift inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
      if(flags[RF])
      {
      if(flags[OF])
        flagsort = 0b00;      
      else
        flagsort = 0b10;     
      }
      else
      {
      if(flags[OF])
        flagsort = 0b11;
      else
        flagsort = 0b01;     
      }
        
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
    	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
    ADDOPERAND(Opc, UCPM::SHU1shiftToNo_IMM, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 1://BIU
    ADDOPERAND(Opc, UCPM::SHU1shiftToBIU_IMM, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    ADDOPERAND(Opc, UCPM::SHU1shiftToMACC_IMM, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 3://m[t]
    ADDOPERAND(Opc, UCPM::SHU1shiftToM_IMM, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 4://m[s++,i++,a++]
    ADDOPERAND(Opc, UCPM::SHU1shiftToMSIA_IMM, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
    ADDOPERAND(Opc, UCPM::SHU1shiftToDIS_IMM, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU1 dest!");clear();YYABORT;
  //llvm_unreachable("invalid SHU1 dest");
  //break;
  }

}
| shubyteclause ASSIGNTO shu1_shu1dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU1_Byte inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Byte inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Byte inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Byte inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Byte inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
	flagsort = (~(flags[UF]) << 4) ;
      
      if(flags[BF])
      {
      if(flags[TF])
        flagsort |= 0b00100;
      else if(flags[FF])
	flagsort |= 0b01000;
      else
        flagsort |= 0b00000;     
      }
      else if(flags[SF])
      {
      if(flags[TF])
        flagsort |= 0b00101;
      else if(flags[FF])
	flagsort |= 0b01001;
      else
        flagsort |= 0b00001;     
      }
      else
      {
      if(flags[TF])
        flagsort |= 0b00110;
      else if(flags[FF])
	flagsort |= 0b01010;
      else
        flagsort |= 0b00010;     
      }
        
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
    	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
    ADDOPERAND(Opc, UCPM::SHU1ByteToNo, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 1://BIU
    ADDOPERAND(Opc, UCPM::SHU1ByteToBIU, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    ADDOPERAND(Opc, UCPM::SHU1ByteToMACC, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 3://m[t]
    ADDOPERAND(Opc, UCPM::SHU1ByteToM, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 4://m[s++,i++,a++]
    ADDOPERAND(Opc, UCPM::SHU1ByteToMSIA, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
    ADDOPERAND(Opc, UCPM::SHU1ByteToDIS, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU1 dest!");clear();YYABORT;
  //llvm_unreachable("invalid SHU1 dest");
  //break;
  }

}
| shubitclause ASSIGNTO shu1_shu1dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU1_Bit inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Bit inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Bit inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Bit inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Bit inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
      if(flags[BF])
      {
      if(flags[TF])
        flagsort = 0b0100;
      else if(flags[FF])
	flagsort = 0b1000;
      else
        flagsort = 0b0000;     
      }
      else if(flags[SF])
      {
      if(flags[TF])
        flagsort = 0b0101;
      else if(flags[FF])
	flagsort = 0b1001;
      else
        flagsort = 0b0001;     
      }
      else
      {
      if(flags[TF])
        flagsort = 0b0110;
      else if(flags[FF])
	flagsort = 0b1010;
      else
        flagsort = 0b0010;     
      }
        
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
    	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
    ADDOPERAND(Opc, UCPM::SHU1BitToNo, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    break;
    
  case 1://BIU
    ADDOPERAND(Opc, UCPM::SHU1BitToBIU, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    ADDOPERAND(Opc, UCPM::SHU1BitToMACC, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    break;
    
  case 3://m[t]
    ADDOPERAND(Opc, UCPM::SHU1BitToM, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    break;
    
  case 4://m[s++,i++,a++]
    ADDOPERAND(Opc, UCPM::SHU1BitToMSIA, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
    ADDOPERAND(Opc, UCPM::SHU1BitToDIS, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU1 dest!");clear();YYABORT;
  //llvm_unreachable("invalid SHU1 dest");
  //break;
  }

}
| shunotclause ASSIGNTO shu1_shu1dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU1_Not inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Not inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Not inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Not inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Not inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
    ADDOPERAND(Opc, UCPM::SHU1NOTToNo, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    break;
 
  case 1://BIU
    ADDOPERAND(Opc, UCPM::SHU1NOTToBIU, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    ADDOPERAND(Opc, UCPM::SHU1NOTToMACC, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts    
    break;
    
  case 3://m[t]
    ADDOPERAND(Opc, UCPM::SHU1NOTToM, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));      
    break;
    
  case 4://m[s++,i++,a++]
    ADDOPERAND(Opc, UCPM::SHU1NOTToMSIA, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));      
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
    ADDOPERAND(Opc, UCPM::SHU1NOTToDIS, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));      
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default:
  llvmerror(&@3, "invalid SHU1 dest!");clear();YYABORT;
  //break;
  }

}
| shulogicclause ASSIGNTO shu1_shu1dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU1_Logic inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Logic inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Logic inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Logic inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU1_Logic inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
    ADDOPERAND(Opc, UCPM::SHU1LogicToNo, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
    break;
 
  case 1://BIU
    ADDOPERAND(Opc, UCPM::SHU1LogicToSHU_BIU, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    ADDOPERAND(Opc, UCPM::SHU1LogicToSHU_MACC, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
    break;
    
  case 3://m[t]
    ADDOPERAND(Opc, UCPM::SHU1LogicToSHU_M, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));      
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
    break;
    
  case 4://m[s++,i++,a++]
    ADDOPERAND(Opc, UCPM::SHU1LogicToSHU_MSIA, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));      
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
    ADDOPERAND(Opc, UCPM::SHU1LogicToSHU_DIS, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));      
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default:
  llvmerror(&@3, "invalid SHU1 dest!");clear();YYABORT;
  //break;
  }

}
| shuimm_tbInstr{
      
      
      if(flags[OF])
        flagsort = 0b0001;
      else if(flags[TF])
	flagsort = 0b0010;
      else if(flags[FF])
	flagsort = 0b0011;
      else if(flags[ZF])
	flagsort = 0b0100;
      else
        flagsort = 0b0000;          
        
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();
      
      ADDOPERAND(Opc, UCPM::SHU1ImmTB, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
}
| shuimm_immInstr{
      
      
      if(flags[OF])
        flagsort = 0b0001;
      else if(flags[TF])
	flagsort = 0b0010;
      else if(flags[FF])
	flagsort = 0b0011;
      else if(flags[ZF])
	flagsort = 0b0100;
      else
        flagsort = 0b0000;          
        
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();
      
      ADDOPERAND(Opc, UCPM::SHU1ImmImm, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm2));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
}
| shuwaitInstr{
            
      ADDOPERAND(Opc, UCPM::SHU1Wait, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    
}
| setCGInstr{
            
          flagsort = (flags[ONF]);
          f = OPERAND(Imm, flagsort, FlagS, FlagE);	
	  flags.reset();
	   
	    ADDOPERAND(Opc, UCPM::SHU1SetCG, @$.S, @$.E);
	    Operands.push_back(nullptr);
	    condpos = Operands.size();
	    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));  
    
};

shu2inst: ucpshuexp ASSIGNTO shu2destTol {
    
     if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU2_IND inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_IND inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_IND inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_IND inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_IND inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }   
    
  flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
  sia = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = flags[SHIFTF];
  dis = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flags.reset();
        
  switch ($3) {
    case 0://shu2
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TSetTBToSHU, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//ts
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TKSetTBToSHU, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//ts
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU2Ind_VTKSetTBToSHU, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//ts
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      break;    
   case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU2Ind_TNSetTBToSHU, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      break;
      
    default :
    llvmerror(&@1, "invalid SHU2Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU2Ind instruction");
    //break;
    }
    break;
    
  case 1://BIU
     switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TSetTBToBIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
     /*  if (ipath == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));*/
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tp
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TKSetTBToBIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
   /*    if (ipath == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));*/
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU2Ind_VTKSetTBToBIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    /*   if (ipath == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));*/
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tp
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU2Ind_TNSetTBToBIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    /*   if (ipath == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));*/
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU2Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU2Ind instruction");
    //break;
    }
    
    break;
  
  case 2://ialut, imact, ifalut, ifmacct
    switch ($1) {
    case 0: //+=
      ADDOPERAND(Opc, UCPM::SHU2Ind_TSetTBToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tp
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TKSetTBToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU2Ind_VTKSetTBToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tp
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU2Ind_TNSetTBToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
        llvmerror(&@1, "invalid SHU2Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU2Ind instruction");
        //break;
    }
    break;
case 3://m[t]
    switch ($1) {
    case 0: //+=
      ADDOPERAND(Opc, UCPM::SHU2Ind_TSetTBToM, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tp
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TKSetTBToM, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU2Ind_VTKSetTBToM, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU2Ind_TNSetTBToM, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
        llvmerror(&@1, "invalid SHU2Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU2Ind instruction");
        //break;
    }
    break;
    
  case 4://m[s++,i++,a++]
    switch ($1) {
    case 0: //+=
      ADDOPERAND(Opc, UCPM::SHU2Ind_TSetTBToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tp
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TKSetTBToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU2Ind_VTKSetTBToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU2Ind_TNSetTBToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
        llvmerror(&@1, "invalid SHU2Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU2Ind instruction");
        //break;
    }
    break;
    
  case 5://m[dis]
    switch ($1) {
    case 0: //+=
      ADDOPERAND(Opc, UCPM::SHU2Ind_TSetTBToDis, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TKSetTBToDIS, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU2Ind_VTKSetTBToDIS, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ts));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU2Ind_TNSetTBToDis, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
        llvmerror(&@1, "invalid SHU2Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU2Ind instruction");
        //break;
    }
    break;
    
  default: 
      llvmerror(&@3, "invalid SHU2 dest!");clear();YYABORT;
    //llvm_unreachable("invalid SHU2 dest");
      //break;
  }

}
/*
|ucpshuexp1 ASSIGNTO shu2destTol {
	
	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
  case 0://shu2
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TSetTBToSHU_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TKSetTBToSHU_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU2Ind_VTKSetTBToSHU_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      break;    
   case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU2Ind_TNSetTBToSHU_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      break;
      
    default :
    llvmerror(&@1, "invalid SHU2Ind instruction!");
    //llvm_unreachable("invalid SHU2Ind instruction");
    //break;
    }
    break;
    
  case 1://BIU
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TSetTBToBIU_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TKSetTBToBIU_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU2Ind_VTKSetTBToBIU_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
   case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU2Ind_TNSetTBToBIU_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default :
    llvmerror(&@1, "invalid SHU2Ind instruction!");
    //llvm_unreachable("invalid SHU2Ind instruction");
    //break;
    }
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TSetTBToMACC_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tp
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TKSetTBToMACC_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU2Ind_VTKSetTBToMACC_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tp
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU2Ind_TNSetTBToMACC_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU2Ind instruction!");
    //llvm_unreachable("invalid SHU2Ind instruction");
    //break;
    }
    break;
    
  case 3://m[t]
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TSetTBToM_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tp
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TKSetTBToM_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU2Ind_VTKSetTBToM_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU2Ind_TNSetTBToM_2, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU2Ind instruction!");
    //llvm_unreachable("invalid SHU2Ind instruction");
    //break;
    }
    break;
    
  case 4://m[s++,i++,a++]
    switch ($1) {
    case 0: //+=
      ADDOPERAND(Opc, UCPM::SHU2Ind_TSetTBToMSIA_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TKSetTBToMSIA_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU2Ind_VTKSetTBToMSIA_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU2Ind_TNSetTBToMSIA_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU2Ind instruction!");
    //llvm_unreachable("invalid SHU2Ind instruction");
    //break;
    }
    break;
    
    case 5://m[dis]
    switch ($1) {
    case 0: //+=
      ADDOPERAND(Opc, UCPM::SHU2Ind_TSetTBToDis_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TKSetTBToDIS_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU2Ind_VTKSetTBToDIS_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU2Ind_TNSetTBToDis_2, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU0DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU2Ind instruction!");
    //llvm_unreachable("invalid SHU2Ind instruction");
    //break;
    }
    break;
  default: 
  llvmerror(&@1, "invalid SHU2 dest!");
    //llvm_unreachable("invalid SHU2 dest");
  //break;
  }

}*/
| t IND shuts {
      ADDOPERAND(Opc, UCPM::SHU2Ind_nodest, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
}
|ucpshuexp2 ASSIGNTO shu2destTol {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU2_IND inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_IND inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_IND inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_IND inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_IND inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://shu2
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TSetTBToSHU_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TKSetTBToSHU_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU2Ind_VTKSetTBToSHU_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      break;    
   case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU2Ind_TNSetTBToSHU_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      break;
      
    default :
    llvmerror(&@1, "invalid SHU2Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU2Ind instruction");
    //break;
    }
    break;
    
  case 1://BIU
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TSetTBToBIU_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TKSetTBToBIU_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU2Ind_VTKSetTBToBIU_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
   case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU2Ind_TNSetTBToBIU_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default :
    llvmerror(&@1, "invalid SHU2Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU2Ind instruction");
    //break;
    }
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TSetTBToMACC_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tp
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TKSetTBToMACC_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU2Ind_VTKSetTBToMACC_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tp
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU2Ind_TNSetTBToMACC_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU2Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU2Ind instruction");
    //break;
    }
    break;
    
  case 3://m[t]
    switch ($1) {
    case 0: //(TB=Ts+imm7)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TSetTBToM_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tp
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TKSetTBToM_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU2Ind_VTKSetTBToM_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU2Ind_TNSetTBToM_1, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU2Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU2Ind instruction");
    //break;
    }
    break;
    
  case 4://m[s++,i++,a++]
    switch ($1) {
    case 0: //+=
      ADDOPERAND(Opc, UCPM::SHU2Ind_TSetTBToMSIA_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TKSetTBToMSIA_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU2Ind_VTKSetTBToMSIA_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU2Ind_TNSetTBToMSIA_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU2Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU2Ind instruction");
    //break;
    }
    break;
    
    case 5://m[dis]
    switch ($1) {
    case 0: //+=
      ADDOPERAND(Opc, UCPM::SHU2Ind_TSetTBToDis_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 1: //(TB=Ts+Tk)
      ADDOPERAND(Opc, UCPM::SHU2Ind_TKSetTBToDIS_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
    case 2: //(TB=Ts+V(Tk))
      ADDOPERAND(Opc, UCPM::SHU2Ind_VTKSetTBToDIS_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;    
    case 3: //tk,no imm
      ADDOPERAND(Opc, UCPM::SHU2Ind_TNSetTBToDis_1, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isSHU2DoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::SHU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    default : 
    llvmerror(&@1, "invalid SHU2Ind instruction!");clear();YYABORT;
    //llvm_unreachable("invalid SHU2Ind instruction");
    //break;
    }
    break;
  default: 
  llvmerror(&@3, "invalid SHU2 dest!");clear();YYABORT;
    //llvm_unreachable("invalid SHU2 dest");
  //break;
  }

}
| shuadd_tt ASSIGNTO shu2_shu2dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU2_Add inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Add inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Add inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Add inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Add inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
    	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU2ADDToNo_VTt_Tm, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU2ADDToNo_Tt_Tm, @$.S, @$.E);} 
      
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    break;
    
  case 1://BIU
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU2ADDToBIU_VTt_Tm, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU2ADDToBIU_Tt_Tm, @$.S, @$.E);} 
      
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU2ADDToMACC_VTt_Tm, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU2ADDToMACC_Tt_Tm, @$.S, @$.E);} 
    
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    break;
    
  case 3://m[t]
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU2ADDToM_VTt_Tm, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU2ADDToM_Tt_Tm, @$.S, @$.E);} 
    
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    break;
    
  case 4://m[s++,i++,a++]
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU2ADDToMSIA_VTt_Tm, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU2ADDToMSIA_Tt_Tm, @$.S, @$.E);} 
    
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU2ADDToMDIS_VTt_Tm, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU2ADDToMDIS_Tt_Tm, @$.S, @$.E);} 
  
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU2 dest!");clear();YYABORT;
  //llvm_unreachable("invalid SHU2 dest");
  //break;
  }

}
| shuadd_tt ASSIGNTO shu2_shu2TBdest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU2_Add inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Add inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Add inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Add inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Add inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }	           
    	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU2ADDToNo_VTt_TB, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU2ADDToNo_Tt_TB, @$.S, @$.E);} 
      
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt   
    break;
    
  case 1://BIU
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU2ADDToBIU_VTt_TB, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU2ADDToBIU_Tt_TB, @$.S, @$.E);} 
      
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt    
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU2ADDToMACC_VTt_TB, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU2ADDToMACC_Tt_TB, @$.S, @$.E);} 
    
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt    
    break;
    
  case 3://m[t]
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU2ADDToM_VTt_TB, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU2ADDToM_Tt_TB, @$.S, @$.E);} 
    
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt    
    break;
    
  case 4://m[s++,i++,a++]
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU2ADDToMSIA_VTt_TB, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU2ADDToMSIA_Tt_TB, @$.S, @$.E);} 
    
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt    
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
  switch ($1) {
    case 1: //V(Tt)
      ADDOPERAND(Opc, UCPM::SHU2ADDToMDIS_VTt_TB, @$.S, @$.E);
      break;
    case 0: //Tt
      ADDOPERAND(Opc, UCPM::SHU2ADDToMDIS_Tt_TB, @$.S, @$.E);} 
  
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tt    
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU2 dest!");clear();YYABORT;
  //llvm_unreachable("invalid SHU2 dest");
  //break;
  }

}
| shuadd_imm7 ASSIGNTO shu2_shu2dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU2_Add inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Add inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Add inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Add inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Add inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
    	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
    ADDOPERAND(Opc, UCPM::SHU2ADDToNo_imm7_Tm, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    break;
    
  case 1://BIU
    ADDOPERAND(Opc, UCPM::SHU2ADDToBIU_imm7_Tm, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    ADDOPERAND(Opc, UCPM::SHU2ADDToMACC_imm7_Tm, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    break;
    
  case 3://m[t]
    ADDOPERAND(Opc, UCPM::SHU2ADDToM_imm7_Tm, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    break;
    
  case 4://m[s++,i++,a++]
    ADDOPERAND(Opc, UCPM::SHU2ADDToMSIA_imm7_Tm, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
    ADDOPERAND(Opc, UCPM::SHU2ADDToMDIS_imm7_Tm, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU2 dest!");clear();YYABORT;
  //llvm_unreachable("invalid SHU2 dest");
  //break;
  }

}
| shuadd_imm7 ASSIGNTO shu2_shu2TBdest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU2_Add inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Add inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Add inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Add inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Add inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
    	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
    ADDOPERAND(Opc, UCPM::SHU2ADDToNo_imm7_TB, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    break;
    
  case 1://BIU
    ADDOPERAND(Opc, UCPM::SHU2ADDToBIU_imm7_TB, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    ADDOPERAND(Opc, UCPM::SHU2ADDToMACC_imm7_TB, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    break;
    
  case 3://m[t]
    ADDOPERAND(Opc, UCPM::SHU2ADDToM_imm7_TB, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    break;
    
  case 4://m[s++,i++,a++]
    ADDOPERAND(Opc, UCPM::SHU2ADDToMSIA_imm7_TB, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
    ADDOPERAND(Opc, UCPM::SHU2ADDToMDIS_imm7_TB, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU2 dest!");clear();YYABORT;
  //llvm_unreachable("invalid SHU2 dest");
  //break;
  }

}
| shustepextclause ASSIGNTO shu2_shu2dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU2_StepExt inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_StepExt inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_StepExt inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_StepExt inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_StepExt inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }	     
	     
      if(flags[ODDF])
      {
	if(flags[TF])
	  flagsort = 0b0101;
	else if(flags[FF])
	  flagsort = 0b1001;   
	else if(flags[EF])
	  flagsort = 0b1101; 
	else
	  flagsort = 0b0001;
      }
      else if(flags[HF])
      {
	if(flags[TF])
	  flagsort = 0b0101;
	else if(flags[FF])
	  flagsort = 0b1001; 
	else if(flags[EF])
	  flagsort = 0b1101; 
	else
	  flagsort = 0b0001;  
      }
      else
      {
	if(flags[TF])
	  flagsort = 0b0100;
	else if(flags[FF])
	  flagsort = 0b1000;
	else if(flags[EF])
	  flagsort = 0b1100; 
	else
	  flagsort = 0b0000;     
      }
        
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
    	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
    ADDOPERAND(Opc, UCPM::SHU2StepExtToNo, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 1://BIU
    ADDOPERAND(Opc, UCPM::SHU2StepExtToBIU, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    ADDOPERAND(Opc, UCPM::SHU2StepExtToMACC, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 3://m[t]
    ADDOPERAND(Opc, UCPM::SHU2StepExtToM, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 4://m[s++,i++,a++]
    ADDOPERAND(Opc, UCPM::SHU2StepExtToMSIA, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
    ADDOPERAND(Opc, UCPM::SHU2StepExtToDIS, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU2 dest!");clear();YYABORT;
  //llvm_unreachable("invalid SHU2 dest");
  //break;
  }

}
| shushift_Tclause ASSIGNTO shu2_shu2dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU2_Shift inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Shift inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Shift inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Shift inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Shift inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
      if(flags[RF])
      {
      if(flags[OF])
        flagsort = 0b00;      
      else
        flagsort = 0b10;     
      }
      else
      {
      if(flags[OF])
        flagsort = 0b11;
      else
        flagsort = 0b01;     
      }
        
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
    	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
    ADDOPERAND(Opc, UCPM::SHU2shiftToNo_T, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 1://BIU
    ADDOPERAND(Opc, UCPM::SHU2shiftToBIU_T, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    ADDOPERAND(Opc, UCPM::SHU2shiftToMACC_T, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 3://m[t]
    ADDOPERAND(Opc, UCPM::SHU2shiftToM_T, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 4://m[s++,i++,a++]
    ADDOPERAND(Opc, UCPM::SHU2shiftToMSIA_T, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
    ADDOPERAND(Opc, UCPM::SHU2shiftToDIS_T, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//tn
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU2 dest!");clear();YYABORT;
  //llvm_unreachable("invalid SHU2 dest");
  //break;
  }

}
| shushift_IMMclause ASSIGNTO shu2_shu2dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU2_Shift inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Shift inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Shift inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Shift inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Shift inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
      if(flags[RF])
      {
      if(flags[OF])
        flagsort = 0b00;      
      else
        flagsort = 0b10;     
      }
      else
      {
      if(flags[OF])
        flagsort = 0b11;
      else
        flagsort = 0b01;     
      }
        
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
    	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
    ADDOPERAND(Opc, UCPM::SHU2shiftToNo_IMM, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 1://BIU
    ADDOPERAND(Opc, UCPM::SHU2shiftToBIU_IMM, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    ADDOPERAND(Opc, UCPM::SHU2shiftToMACC_IMM, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 3://m[t]
    ADDOPERAND(Opc, UCPM::SHU2shiftToM_IMM, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 4://m[s++,i++,a++]
    ADDOPERAND(Opc, UCPM::SHU2shiftToMSIA_IMM, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
    ADDOPERAND(Opc, UCPM::SHU2shiftToDIS_IMM, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU2 dest!");clear();YYABORT;
  //llvm_unreachable("invalid SHU2 dest");
  //break;
  }

}
| shubyteclause ASSIGNTO shu2_shu2dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU2_Byte inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Byte inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Byte inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Byte inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Byte inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
	flagsort = (~(flags[UF]) << 4) ;
      
      if(flags[BF])
      {
      if(flags[TF])
        flagsort |= 0b00100;
      else if(flags[FF])
	flagsort |= 0b01000;
      else
        flagsort |= 0b00000;     
      }
      else if(flags[SF])
      {
      if(flags[TF])
        flagsort |= 0b00101;
      else if(flags[FF])
	flagsort |= 0b01001;
      else
        flagsort |= 0b00001;     
      }
      else
      {
      if(flags[TF])
        flagsort |= 0b00110;
      else if(flags[FF])
	flagsort |= 0b01010;
      else
        flagsort |= 0b00010;     
      }
        
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
    	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
    ADDOPERAND(Opc, UCPM::SHU2ByteToNo, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 1://BIU
    ADDOPERAND(Opc, UCPM::SHU2ByteToBIU, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    ADDOPERAND(Opc, UCPM::SHU2ByteToMACC, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 3://m[t]
    ADDOPERAND(Opc, UCPM::SHU2ByteToM, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    break;
    
  case 4://m[s++,i++,a++]
    ADDOPERAND(Opc, UCPM::SHU2ByteToMSIA, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
    ADDOPERAND(Opc, UCPM::SHU2ByteToDIS, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU2 dest!");clear();YYABORT;
  //llvm_unreachable("invalid SHU2 dest");
  //break;
  }

}
| shubitclause ASSIGNTO shu2_shu2dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU2_Bit inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Bit inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Bit inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Bit inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Bit inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
      if(flags[BF])
      {
      if(flags[TF])
        flagsort = 0b0100;
      else if(flags[FF])
	flagsort = 0b1000;
      else
        flagsort = 0b0000;     
      }
      else if(flags[SF])
      {
      if(flags[TF])
        flagsort = 0b0101;
      else if(flags[FF])
	flagsort = 0b1001;
      else
        flagsort = 0b0001;     
      }
      else
      {
      if(flags[TF])
        flagsort = 0b0110;
      else if(flags[FF])
	flagsort = 0b1010;
      else
        flagsort = 0b0010;     
      }
        
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
    	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
    ADDOPERAND(Opc, UCPM::SHU2BitToNo, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    break;
    
  case 1://BIU
    ADDOPERAND(Opc, UCPM::SHU2BitToBIU, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    ADDOPERAND(Opc, UCPM::SHU2BitToMACC, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    break;
    
  case 3://m[t]
    ADDOPERAND(Opc, UCPM::SHU2BitToM, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    break;
    
  case 4://m[s++,i++,a++]
    ADDOPERAND(Opc, UCPM::SHU2BitToMSIA, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
    ADDOPERAND(Opc, UCPM::SHU2BitToDIS, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//tm
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default: 
  llvmerror(&@3, "invalid SHU2 dest!");clear();YYABORT;
  //llvm_unreachable("invalid SHU2 dest");
  //break;
  }

}
| shunotclause ASSIGNTO shu2_shu2dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU2_Not inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Not inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Not inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Not inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Not inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
    ADDOPERAND(Opc, UCPM::SHU2NOTToNo, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    break;
    
  case 1://BIU
    ADDOPERAND(Opc, UCPM::SHU2NOTToBIU, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    ADDOPERAND(Opc, UCPM::SHU2NOTToMACC, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts    
    break;
    
  case 3://m[t]
    ADDOPERAND(Opc, UCPM::SHU2NOTToM, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));      
    break;
    
  case 4://m[s++,i++,a++]
    ADDOPERAND(Opc, UCPM::SHU2NOTToMSIA, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));      
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
    ADDOPERAND(Opc, UCPM::SHU2NOTToDIS, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));      
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default:
  llvmerror(&@3, "invalid SHU2 dest!");clear();YYABORT;
  //break;
  }

}
| shulogicclause ASSIGNTO shu2_shu2dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::shuBIU0: 
	    case UCPMReg::shuBIU1: 
	    case UCPMReg::shuBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect SHU2_Logic inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::IALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Logic inst! IALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::sIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Logic inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::sIFALU:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Logic inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::IFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect SHU2_Logic inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }
      
	flagsort = (flags[SPPF] << 2) | (flags[IPPF] << 1) | flags[APPF2];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
  switch ($3) {
  case 0://No
    ADDOPERAND(Opc, UCPM::SHU2LogicToNo, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//ts
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
    break;
 
  case 1://BIU
    ADDOPERAND(Opc, UCPM::SHU2LogicToSHU_BIU, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
    break;
    
  case 2://ialut, imact, ifalut, ifmacct
    ADDOPERAND(Opc, UCPM::SHU2LogicToSHU_MACC, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ipath));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
    break;
    
  case 3://m[t]
    ADDOPERAND(Opc, UCPM::SHU2LogicToSHU_M, @$.S, @$.E); 
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));      
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
    break;
    
  case 4://m[s++,i++,a++]
    ADDOPERAND(Opc, UCPM::SHU2LogicToSHU_MSIA, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));      
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
    break;    
    
  case 5://m[dis]
    ADDOPERAND(Opc, UCPM::SHU2LogicToSHU_DIS, @$.S, @$.E); 
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));      
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
    break;
    
  default:
  llvmerror(&@3, "invalid SHU2 dest!");clear();YYABORT;
  //break;
  }

}
| shuimm_tbInstr{
      
      
      if(flags[OF])
        flagsort = 0b0001;
      else if(flags[TF])
	flagsort = 0b0010;
      else if(flags[FF])
	flagsort = 0b0011;
      else if(flags[ZF])
	flagsort = 0b0100;
      else
        flagsort = 0b0000;          
        
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();
      
      ADDOPERAND(Opc, UCPM::SHU2ImmTB, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
}
| shuimm_immInstr{
      
      
      if(flags[OF])
        flagsort = 0b0001;
      else if(flags[TF])
	flagsort = 0b0010;
      else if(flags[FF])
	flagsort = 0b0011;
      else if(flags[ZF])
	flagsort = 0b0100;
      else
        flagsort = 0b0000;          
        
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();
      
      ADDOPERAND(Opc, UCPM::SHU2ImmImm, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm2));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
}
| shuwaitInstr{
            
      ADDOPERAND(Opc, UCPM::SHU2Wait, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    
}
| setCGInstr{
            
          flagsort = (flags[ONF]);
          f = OPERAND(Imm, flagsort, FlagS, FlagE);	
	  flags.reset();
	   
	    ADDOPERAND(Opc, UCPM::SHU2SetCG, @$.S, @$.E);
	    Operands.push_back(nullptr);
	    condpos = Operands.size();
	    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));  
    
};

//tn:t0-t3
ucpshuexp: LPAREN t COMMA t RPAREN IND ucpindclause {$$ = $7;} ; 
//ucpshuexp2: constt IND ucpindclause {$$ = $3;} ;
ucpshuexp2: t IND ucpindclause {$$ = $3;} ;
//ucpshuexp1: t IND ucpindclause {$$ = $3;} ;
ucpshusrcTm: t;
/*ucpshusrcTn: t {$$ = 1;}| 
             constt {$$ = 2;};*/
ucpindclause: ucpindtkclause | ucpindtbclause ;
ucpindtkclause: shutsrct _flag TB ASSIGNMENT shutsrct ADD t flag_ {$$ = 1;}//(TB=Ts+Tk)
|               shutsrct {$$ = 3;};
ucpindtkclause: shutsrct _flag error flag_ { llvmerror(&@3, "SHU IND Ts must be followed by (TB = Ts+Tt) or (TB = Ts+V(Imm7)) or (TB = Ts+V(Tt))"); clear();YYABORT;};
ucpindtbclause: shutsrct _flag TB ASSIGNMENT shutsrct ADD V _flag IMM5 flag_ flag_ {$$ = 0; imm = OPERAND(Imm, $9, @9.S, @9.E);}//(TB=Ts+imm7)
|            	shutsrct _flag TB ASSIGNMENT shutsrct ADD V _flag t flag_ flag_ {$$ = 2;};//(TB=Ts+V(Tk))

ucpshusrcTk: t {$$ = 1;}| 
             constt {$$ = 2;};

//tn:TSQ/TBB/...

/*ucpshuexp2: _flag t COMMA t flag_ IND ucpindclause2 {$$ = $7}; 
ucpindclause2: ucpindtkclause2 | ucpindtbclause2 ;
ucpindtkclause2: t {$$ = 1;};
ucpindtbclause2: TB {$$ = 0; unsigned treg = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(0);//tp is unused
                revt = OPERAND(Reg, treg, @$.S, @$.E)};*/

//dcx
//shu0dest: biu0t | biu2t | maccdestp | sshu0t | mindexn | mindexsia;
//shu1dest: biu0t | s1biu1t | maccdestp | sshu1t | mindexn | mindexsia;
//shu2dest: s2biu1t | biu2t | maccdestp | sshu2t | mindexn | mindexsia;
shu0dest: shubiut | maccdestp | mindexn | mindexsia | mindexdis ;
shu1dest: shubiut | maccdestp | mindexn | mindexsia | mindexdis ;
shu2dest: shubiut | maccdestp | mindexn | mindexsia | mindexdis ;

shu0_shu0dest: SHU0 DOT t AND shu0dest {$$ = $5;} 
	      | SHU0 DOT t{$$ = 0;}
	      | SHU0 DOT t AND SHU0 DOT t{llvmerror(&@1, "invalid SHUx dest!");clear();YYABORT;};//niuxx 
		
shu1_shu1dest: SHU1 DOT t AND shu1dest {$$ = $5;} 
	      | SHU1 DOT t{$$ = 0;}
	      | SHU1 DOT t AND SHU1 DOT t{llvmerror(&@1, "invalid SHUx dest!");clear();YYABORT;};//niuxx       

shu2_shu2dest: SHU2 DOT t AND shu2dest {$$ = $5;} 
	      | SHU2 DOT t{$$ = 0;}
	      | SHU2 DOT t AND SHU2 DOT t{llvmerror(&@1, "invalid SHUx dest!");clear();YYABORT;};//niuxx 	      

shu0_shu0TBdest: SHU0 DOT TB AND shu0dest {$$ = $5;} 
		| SHU0 DOT TB{$$ = 0;}
		| SHU0 DOT TB AND SHU0 DOT t{llvmerror(&@1, "invalid SHUx dest!");clear();YYABORT;};//niuxx 
		
shu1_shu1TBdest: SHU1 DOT TB AND shu1dest {$$ = $5;} 
		| SHU1 DOT TB{$$ = 0;}
		| SHU1 DOT TB AND SHU1 DOT t{llvmerror(&@1, "invalid SHUx dest!");clear();YYABORT;};//niuxx
		
shu2_shu2TBdest: SHU2 DOT TB AND shu2dest {$$ = $5;} 
		| SHU2 DOT TB{$$ = 0;}
		| SHU2 DOT TB AND SHU2 DOT t{llvmerror(&@1, "invalid SHUx dest!");clear();YYABORT;};//niuxx		
		
mindexsia: M LBRACKET siaflags RBRACKET {$$=4;} | M {$$=4;} |
	   MPP LBRACKET siaflags RBRACKET {$$=4;}| MPP {$$=4;}| 
	   M LBRACKET error RBRACKET  {llvmerror(&@3, "flags error! Available flags are S++,I++,A++");clear();YYABORT;}|//niuxx
	   MPP LBRACKET error RBRACKET {llvmerror(&@3, "flags error! Available flags are S++,I++,A++");clear();YYABORT;};//niuxx
	   
mindexdis: M LBRACKET DIS _flag disflag flag_ RBRACKET {$$=5;}| | M LBRACKET DIS RBRACKET{$$=5;} |
	   MDIS LBRACKET DIS _flag disflag flag_ RBRACKET {$$=5;}| MDIS LBRACKET DIS RBRACKET{$$=5;}|
	   
	   M LBRACKET DIS _flag error flag_ RBRACKET {llvmerror(&@5, "flags error! Available flags are dis(shift)");clear();YYABORT;}|//niuxx
	   MDIS LBRACKET DIS _flag error flag_ RBRACKET {llvmerror(&@5, "flags error! Available flags are dis(shift)");clear();YYABORT;};//niuxx
//ialu_mindexsia: IALU DOT t AND M LBRACKET siaflags RBRACKET {$$=4;} | IALU DOT t AND M {$$=4;} ;	   
//ialu_mindexdis: IALU DOT t AND M LBRACKET DIS _flag disflag flag_ RBRACKET {$$=5;}| | IALU DOT t AND M LBRACKET DIS RBRACKET{$$=5;} ;	   
	   
//shu0dest: maccdestp {
//               /*if(ipath->getImm() >= 3) {
//                 llvmerror(&@1, "SHU to Macc must use port 'I0 -I2'"); 
//                 clear();YYABORT;
//               }*/
//             };

// ducx 20170913
maccdestp: ialut LPAREN IPATH RPAREN {$$ = $1; ipath = OPERAND(Imm, $3, @3.S, @3.E);if(ipath->getImm() >= 3) {llvmerror(&@3, "SHU to IALU must use port 'I0 -I2'");clear();YYABORT;};}
	  | imact LPAREN IPATH RPAREN {$$ = $1; ipath = OPERAND(Imm, $3, @3.S, @3.E);if(ipath->getImm() >= 3) {llvmerror(&@3, "SHU to IMAC must use port 'I0 -I2'");clear();YYABORT;};}
	  | ifalut LPAREN IPATH RPAREN {$$ = $1; ipath = OPERAND(Imm, $3-3, @3.S, @3.E);if( (ipath->getImm() < 0) || (ipath->getImm() >=3) ) {llvmerror(&@3, "SHU to IFALU must use port 'I3 -I5'");clear();YYABORT;};}
	  | ifmact LPAREN IPATH RPAREN {$$ = $1; ipath = OPERAND(Imm, $3-3, @3.S, @3.E);if( (ipath->getImm() < 0) || (ipath->getImm() >=3) ) {llvmerror(&@3, "SHU to IFMAC must use port 'I3 -I5'");clear();YYABORT;};};
//maccdestp: maccdest LPAREN IPATH RPAREN {$$ = $1; ipath = OPERAND(Imm, $3, @3.S, @3.E);};
maccdestp: maccdest error {llvmerror(&@2, "SHU -> MACC must have (Ipath)"); clear();YYABORT;};
maccdest: ialut | imact | ifalut | ifmact;



// dcx
shuwaitInstr: WAIT IMM5 {imm = OPERAND(Imm, $2, @2.S, @2.E);};

shu0setcondInstr: shu0cond{   
	    isSetCond = true;
	    ADDOPERAND(Opc, UCPM::SHU0SetCond, @$.S, @$.E);
	    Operands.push_back(nullptr);
	    condpos = Operands.size();
	    if (imm == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
	    if (imm1 == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));   
	  };
shu1setcondInstr: shu1cond{   
	    isSetCond = true;
	    ADDOPERAND(Opc, UCPM::SHU1SetCond, @$.S, @$.E);
	    Operands.push_back(nullptr);
	    condpos = Operands.size();
	    if (imm == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
	    if (imm1 == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));   
	  };
shu2setcondInstr: shu2cond{   
	    isSetCond = true;
	    ADDOPERAND(Opc, UCPM::SHU2SetCond, @$.S, @$.E);
	    Operands.push_back(nullptr);
	    condpos = Operands.size();
	    if (imm == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
	    if (imm1 == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));   
	  };

shu0cond: IMMSYM DOT IMM5 ASSIGNTO SHU0 DOT SETCOND LBRACKET IMM5 RBRACKET 
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $9, @9.S, @9.E);};      
shu1cond: IMMSYM DOT IMM5 ASSIGNTO SHU1 DOT SETCOND LBRACKET IMM5 RBRACKET 
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $9, @9.S, @9.E);};
shu2cond: IMMSYM DOT IMM5 ASSIGNTO SHU2 DOT SETCOND LBRACKET IMM5 RBRACKET 
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $9, @9.S, @9.E);};
	  
//huhh:SHU -> {SHU.Tt & }shudest
shu0destTol: shu0dest{$$=$1;} | shu0_shu0dest{$$=$1;isSHU0DoubleDest = true;};
shu1destTol: shu1dest{$$=$1;} | shu1_shu1dest{$$=$1;isSHU1DoubleDest = true;}; 
shu2destTol: shu2dest{$$=$1;} | shu2_shu2dest{$$=$1;isSHU2DoubleDest = true;}; 

//huhh:SHULogic(&|^~)
shulogicclause: sandclause {opc = OPERAND(Reg, UCPMReg::shu_AND, @$.S, @$.E);} | 
                sorclause {opc = OPERAND(Reg, UCPMReg::shu_OR, @$.S, @$.E);} | 
                sxorclause {opc = OPERAND(Reg, UCPMReg::shu_XOR, @$.S, @$.E);} ; 
shunotclause: snotclause {opc = OPERAND(Reg, UCPMReg::shu_NOT, @$.S, @$.E);} ;
sandclause: shusrct AND shutsrct ;
sorclause : shusrct OR shutsrct ;
sxorclause : shusrct XOR shutsrct ;
snotclause : NOT2 shutsrct ;

//huhh:SHUByte/Bit
shubyteclause:  BYTE shutsrct _flag shubyteflags flag_ |
		BYTE shutsrct |//shutsrct:T0-7 and TC1-7 and TB
		
		BYTE shutsrct _flag error flag_ { llvmerror(&@4, "SHUx.Byte flags error! Available flags are U,B/S,T/F"); clear();YYABORT;};//niuxx
shubitclause: BIT  shutsrct _flag shubitflags flag_ BY IMM5 {imm = OPERAND(Imm, $7, @7.S, @7.E);} |
	      BIT  shutsrct BY IMM5 {imm = OPERAND(Imm, $4, @4.S, @4.E);} |//shutsrct:T0-7 and TC1-7 and TB
	      
	      BIT  shutsrct _flag error flag_ BY IMM5 { llvmerror(&@4, "SHUx.Bit flags error! Available flags are B/S,T/F"); clear();YYABORT;};//niuxx
//shubyteclause: BYTE shutsrct _flag error flag_ {llvmerror(&@4, "SHUByte flags error! Available flags are U, B/S, T/F"); clear();YYABORT;};
//shubitclause:  BIT  shutsrct _flag error flag_ {llvmerror(&@4, "SHUBit flags error! Available flags are B/S, T/F"); clear();YYABORT;};

//huhh:SHUStepExt
shustepextclause: stepextclause {opc = OPERAND(Reg, UCPMReg::shu_STEP, @$.S, @$.E);} | 
                  restepextclause {opc = OPERAND(Reg, UCPMReg::shu_RESTEP, @$.S, @$.E);} ;
stepextclause:    STEPEXT LBRACE shusrct COMMA shutsrct RBRACE _flag shustepextflags flag_ | 
		  STEPEXT LBRACE shusrct COMMA shutsrct RBRACE |

		  STEPEXT LBRACE shusrct COMMA shutsrct RBRACE _flag error flag_ { llvmerror(&@8, "SHUx.StepExt flags error! Available flags are Odd,T/F/E"); clear();YYABORT;};//niuxx
restepextclause : RESTEPEXT LBRACE shusrct COMMA shutsrct RBRACE _flag shurestepextflags flag_ |
		  RESTEPEXT LBRACE shusrct COMMA shutsrct RBRACE |
		  
		  RESTEPEXT LBRACE shusrct COMMA shutsrct RBRACE _flag error flag_ { llvmerror(&@8, "SHUx.ReStepExt flags error! Available flags are H,T/F/E"); clear();YYABORT;};//niuxx

//huhh:SHUByte/Bit
shuadd_imm7:  shutsrct ADD V _flag IMM5 flag_  {imm = OPERAND(Imm, $5, @5.S, @5.E);};
shuadd_tt:  shutsrct ADD V _flag t flag_ {$$=1;} | shutsrct ADD t {$$=0;};           
              
//huhh:SHU SHIFT
shushift_Tclause:   SHIFT LPAREN shutsrct COMMA t RPAREN _flag shushiftflags flag_ |
		    SHIFT LPAREN shutsrct COMMA t RPAREN |//shutsrct:T0-7 and TC1-7 and TB
		    
		    SHIFT LPAREN shutsrct COMMA t RPAREN _flag error flag_ { llvmerror(&@8, "SHUx.Shift flags error! Available flags are R,O"); clear();YYABORT;};//niuxx
shushift_IMMclause: SHIFT LPAREN shutsrct COMMA IMM5 RPAREN _flag shushiftflags flag_ {imm = OPERAND(Imm, $5, @5.S, @5.E);}| 
                    SHIFT LPAREN shutsrct COMMA IMM5 RPAREN {imm = OPERAND(Imm, $5, @5.S, @5.E);}|

                    SHIFT LPAREN shutsrct COMMA IMM5 RPAREN _flag error flag_ { llvmerror(&@8, "SHUx.Shift flags error! Available flags are R,O"); clear();YYABORT;};//niuxx
//huhh:SHU Imm
shuimm_tbInstr: IMM5 TO t BY TB _flag shuimmtbflags flag_ {imm = OPERAND(Imm, $1, @1.S, @1.E);} |
                IMM5 TO t BY TB {imm = OPERAND(Imm, $1, @1.S, @1.E);} |
                
                IMM5 TO t BY TB _flag error flag_ { llvmerror(&@7, "SHUx.Imm8 flags error! Available flags are O/T/F/Z"); clear();YYABORT;};//niuxx
shuimm_immInstr: IMM5 TO t BY IMM5 _flag shuimmtbflags flag_ {imm = OPERAND(Imm, $1, @1.S, @1.E); imm2 = OPERAND(Imm, $5, @5.S, @5.E);}
                |IMM5 TO t BY IMM5 {imm = OPERAND(Imm, $1, @1.S, @1.E); imm2 = OPERAND(Imm, $5, @5.S, @5.E);} |
                
                IMM5 TO t BY IMM5 _flag error flag_ { llvmerror(&@7, "SHUx.Imm8 flags error! Available flags are O/T/F/Z"); clear();YYABORT;};//niuxx

 
// end shu -------------------------------------------------- 


// start ialu -------------------------------------------------- 
ialuslot: IALU DOT ialuinst | ialusetcondInstr;
ialuslot: IALU DOT error { llvmerror(&@1, "Incorrect IALU inst."); clear();YYABORT;} ;

ialuinst: ialuindclause ASSIGNTO ialudest {
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{ llvmerror(&@3, "IALUInd can not assign to IFMAC!");clear();YYABORT;
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
	else if(unit3->getReg() == UCPMReg::IALUIFALU)//IFALU
	  {llvmerror(&@3, "IALUInd can not assign to IFALU!");clear();YYABORT;}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_Index inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	     {llvmerror(&@3, "IALU_Index can not assign to IFMAC!");clear();YYABORT;}//niuxu
	  break;
	  case UCPMReg::IALUSHU0 :
	  case UCPMReg::IALUSHU1 :
	  case UCPMReg::IALUSHU2 :
	    llvmerror(&@3, "IALU_Index can not assign to SHU!");clear();YYABORT;//niuxu
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    llvmerror(&@3, "IALU_Index can not assign to BIU!");clear();YYABORT;//niuxu
	  break;  
	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	      if(ut->getReg() > UCPMReg::T5)
		{llvmerror(&@3, "Incorrect IFALU_Index inst! _IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	    {llvmerror(&@3, "IALU_Index can not assign to IFALU!");clear();YYABORT;}//niuxu
	  break;
	}
      }       
      
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Index inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Index inst! Tl should be T0-T5!");clear();YYABORT;}//niuxu  
      if(tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Index inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tk->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Index inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu  
      
switch ($3) {
    case 0://to shu
      //llvmerror(&@3, "IALUInd can not assign to SHU!");clear();YYABORT;
      ADDOPERAND(Opc, UCPM::IALUIndToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      break;     
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUIndToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      break;     
    case 2://to biu    
      //llvmerror(&@3, "IALUInd can not assign to BIU!");clear();YYABORT;
      ADDOPERAND(Opc, UCPM::IALUIndToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      break;      
    case 3://to M[t]
      ADDOPERAND(Opc, UCPM::IALUIndToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      break;     
    case 4://to m[s++/i++/a++] 
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);	      
      flags.reset();
      ADDOPERAND(Opc, UCPM::IALUIndToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;      
    case 5://to m[dis(shift)] 
      flagsort = (flags[SHIFTF]);
      dis = OPERAND(Imm, flagsort, FlagS, FlagE);	
      flags.reset();	      
      ADDOPERAND(Opc, UCPM::IALUIndToDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break;
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IALUIndToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      break;
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
       //llvm_unreachable("invalid IALU dest");
      //break;
  }

}
| ialuindclause ASSIGNTO ialu_dest {
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{ llvmerror(&@3, "IALUInd can not assign to IFMAC!");clear();YYABORT;
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
	else if(unit3->getReg() == UCPMReg::IALUIFALU)//IFALU
	  {llvmerror(&@3, "IALUInd can not assign to IFALU!");clear();YYABORT;}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_Index inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	     {llvmerror(&@3, "IALU_Index can not assign to IFMAC!");clear();YYABORT;}//niuxu
	  break;
	  case UCPMReg::IALUSHU0 :
	  case UCPMReg::IALUSHU1 :
	  case UCPMReg::IALUSHU2 :
	    llvmerror(&@3, "IALU_Index can not assign to SHU!");clear();YYABORT;//niuxu
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    llvmerror(&@3, "IALU_Index can not assign to BIU!");clear();YYABORT;//niuxu
	  break;  
/*	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	      if(ut->getReg() > UCPMReg::T5)
		{llvmerror(&@3, "Incorrect IFALU_Index inst! Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	    {llvmerror(&@3, "IALU_Indxe can not assign to IFALU!");clear();YYABORT;}//niuxu
	  break;*/
	}
      }       
      
      
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Index inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Index inst! Tl should be T0-T5!");clear();YYABORT;}//niuxu  
      if(tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Index inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tk->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Index inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu   
      if(tl->getReg() > UCPMReg::T5)
	 {llvmerror(&@3, "Incorrect IALU_Index inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu  
            
switch ($3) {
    case 0://to shu
     //llvmerror(&@3, "IALUInd can not assign to SHU!");clear();YYABORT;
      ADDOPERAND(Opc, UCPM::IALUIndToIALU_SHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
       break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUIndToIALU_MACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      break;
      
    case 2://to biu
      //llvmerror(&@3, "IALUInd can not assign to BIU!");clear();YYABORT;
      ADDOPERAND(Opc, UCPM::IALUIndToIALU_BIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      break;
      
    case 3://to M[t]
      ADDOPERAND(Opc, UCPM::IALUIndToIALU_M, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      break;
      
    case 4://to m[s++/i++/a++] 
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);	      
      flags.reset();
      ADDOPERAND(Opc, UCPM::IALUIndToIALU_MSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
      
    case 5://to m[dis(shift)] 
      flagsort = (flags[SHIFTF]);
      dis = OPERAND(Imm, flagsort, FlagS, FlagE);	
      flags.reset();	      
      ADDOPERAND(Opc, UCPM::IALUIndToIALU_Dis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break;
      
      default:
       llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
   }
   }


|ialuasclause ASSIGNTO ialudest  {

      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	     unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	     ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_Add/Sub inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_Add/Sub inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_Add/Sub inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Add/Sub inst! _IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu	  
	  break;    
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Add/Sub inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      } 
       
      if (opc->getReg() == UCPMReg::f_IADD) 
      {
         if(tm->getReg() > UCPMReg::T5)
	    {llvmerror(&@1, "Incorrect IALU_Add/Sub inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
	 if(tn->getReg() > UCPMReg::T6)
	    {llvmerror(&@1, "Incorrect IALU_Add/Sub inst! Tn should be T0-T6!");clear();YYABORT;}//niuxu
      }
      else if (opc->getReg() == UCPMReg::f_ISUB)
      {
         if(tm->getReg() == UCPMReg::T6)
	    {llvmerror(&@1, "Incorrect IALU_Add/Sub inst! Tm should be T0-T5,T7!");clear();YYABORT;}//niuxu
	 if(tn->getReg() > UCPMReg::T5)
	    {llvmerror(&@1, "Incorrect IALU_Add/Sub inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu      
      }
      
      	 
/*    //ducx,20171206
      if(tm->getReg() == UCPMReg::T6 )
         {llvmerror(&@1, "Incorrect IALU add/sub inst! Tm should not be T6!");clear();YYABORT;}
      if(tn->getReg() == UCPMReg::T7)
         {llvmerror(&@1, "Incorrect IALU add/sub inst! Tn should not be T7!");clear();YYABORT;}
*/		          
      switch($1)
      {
	case 0 : flagsort = 0;break;
	//case 1 : flagsort = 6;break;
	//case 2 : flagsort = 4;break;
	//case 3 : flagsort = 3;break;
	case 4 : flagsort = 1;break;
	//case 5 : flagsort = 7;break;
	case 6 : flagsort = 1;break;
	//case 7 : flagsort = 4;break;	
      }
      ff = OPERAND(Imm, flagsort, FlagS, FlagE);
      
      if(flagsort != 0 && flags[CIF])
      {
         llvmerror(&@1, "Incorrect IALU add/sub inst! Should not have CI flag!"); 
         clear();YYABORT;
      }
      if( ($1 != 0 && $1 != 7 && flags[UF]) )
      {
         llvmerror(&@1, "Incorrect IALU add/sub inst! Should not have U flag!"); 
         clear();YYABORT;
      }
       
      flagsort = (~(flags[UF]) << 5) | (flags[BF] << 4) | (flags[SF] << 3) | (flags[TF] << 2) | (flags[CIF] << 1) | flags[FF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE);

      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      flagsort = flags[SHIFTF];
      dis = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();
        
  switch ($3) {
    case 0://to shu	 
      ADDOPERAND(Opc, UCPM::IALUASToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ADD or SUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
       break;
    case 1://to macc	
      ADDOPERAND(Opc, UCPM::IALUASToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ADD or SUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break;    
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALUASToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ADD or SUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break;           
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUASToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ADD or SUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break;     
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUASToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ADD or SUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
    case 5://to m[dis{shift}]
      ADDOPERAND(Opc, UCPM::IALUASToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ADD or SUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break;
    case 6://to ialu	
      ADDOPERAND(Opc, UCPM::IALUASToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ADD or SUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break;
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
       //break;
  }

}
|ialuasclause ASSIGNTO ialu_dest  {
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_Add/Sub inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_Add/Sub inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_Add/Sub inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Add/Sub inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }      
 
      if (opc->getReg() == UCPMReg::f_IADD) 
      {
         if(tm->getReg() > UCPMReg::T5)
	    {llvmerror(&@1, "Incorrect IALU_Add/Sub inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
	 if(tn->getReg() > UCPMReg::T6)
	    {llvmerror(&@1, "Incorrect IALU_Add/Sub inst! Tn should be T0-T6!");clear();YYABORT;}//niuxu
      }
      else if (opc->getReg() == UCPMReg::f_ISUB)
      {
         if(tm->getReg() == UCPMReg::T6)
	    {llvmerror(&@1, "Incorrect IALU_Add/Sub inst! Tm should be T0-T5,T7!");clear();YYABORT;}//niuxu
	 if(tn->getReg() > UCPMReg::T5)
	    {llvmerror(&@1, "Incorrect IALU_Add/Sub inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu      
      } 
      if(tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@3, "Incorrect IALU_Add/Sub inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu 
 
/*    //ducx,20171206
      if(tm->getReg() == UCPMReg::T6 )
         {llvmerror(&@1, "Incorrect IALU add/sub inst! Tm should not be T6!");clear();YYABORT;}
      if(tn->getReg() == UCPMReg::T7)
         {llvmerror(&@1, "Incorrect IALU add/sub inst! Tn should not be T7!");clear();YYABORT;}
*/         
      switch($1)
      {
	case 0 : flagsort = 0;break;
	//case 1 : flagsort = 6;break;
	//case 2 : flagsort = 4;break;
	//case 3 : flagsort = 3;break;
	case 4 : flagsort = 1;break;
	//case 5 : flagsort = 7;break;
	case 6 : flagsort = 1;break;
	//case 7 : flagsort = 4;break;
	
      }
      ff = OPERAND(Imm, flagsort, FlagS, FlagE);
      
      if(flagsort != 0 && flags[CIF])
      {
         llvmerror(&@1, "Incorrect IALU add/sub inst! Should not have CI flag!"); 
         clear();YYABORT;
      }
      if( ($1 != 0 && $1 != 7 && flags[UF]) )
      {
         llvmerror(&@1, "Incorrect IALU add/sub inst! Should not have U flag!"); 
         clear();YYABORT;
      }
      
      flagsort = (~(flags[UF]) << 5) | (flags[BF] << 4) | (flags[SF] << 3) | (flags[TF] << 2) | (flags[CIF] << 1) | flags[FF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE);

     	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALUASToIALU_SHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ADD or SUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break;
    case 1://to macc  
      ADDOPERAND(Opc, UCPM::IALUASToIALU_MACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ADD or SUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break;      
    case 2://to biu          
      ADDOPERAND(Opc, UCPM::IALUASToIALU_BIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ADD or SUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break;
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUASToIALU_M, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ADD or SUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break;
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUASToIALU_MSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ADD or SUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;     
    case 5://to m[dis{shift}]
      ADDOPERAND(Opc, UCPM::IALUASToIALU_MDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ADD or SUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break;
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }

}
| ialurasclause ASSIGNTO ialudest{
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_RAdd/RSub inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_RAdd/RSub inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_RAdd/RSub inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_RAdd/RSub inst! _IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu	
	  break;    
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_RAdd/RSub inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }              	      
      
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_RAdd/RSub inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu      
      
     
/*         if(flags[A1F])
		flagsort = 0b001;
        else if(flags[A2F])
		flagsort = 0b100;	
	else    flagsort = 0b000;*/
	ff = OPERAND(Imm, 0, FlagS, FlagE);
		
      if(flags[CIF])
      {
         llvmerror(&@1, "Incorrect IALU radd/rsub inst! Should not have CI flag!"); 
         clear();YYABORT;
      }
      if(flags[UF] && flags[A1F])
      {
         llvmerror(&@1, "Incorrect IALU radd/rsub inst! U and A1 should not coexist!"); 
         clear();YYABORT;
      }
      
         flagsort = (~(flags[UF]) << 5) | (flags[TF] << 2) | (0 << 1) | flags[FF];
         if(flags[BF])
	   flagsort |= 0b001000;
	 else if(flags[SF])
	   flagsort |= 0b000000;
	 else
	   flagsort |= 0b011000;
	   
         f = OPERAND(Imm, flagsort, FlagS, FlagE);

     	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
switch ($3) {
    case 0://to shu          
      ADDOPERAND(Opc, UCPM::IALURASToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
       break;
    case 1://to macc     
      ADDOPERAND(Opc, UCPM::IALURASToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
       break; 
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALURASToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
       break;  
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALURASToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
       break;  
    case 4://to m[s++|i++|a++]
      ADDOPERAND(Opc, UCPM::IALURASToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
       break;  
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALURASToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
       break;
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IALURASToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
       break;
     default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
 }
}
| ialurasclause ASSIGNTO ialu_dest{
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/

      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_RAdd/RSub inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_RAdd/RSub inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_RAdd/RSub inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_RAdd/RSub inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }        
      
      if(tm->getReg() > UCPMReg::T5)
	  {llvmerror(&@1, "Incorrect IALU RAdd/RSub inst! Tn should be T0-T5!");clear();YYABORT;} //niuxx
      if(tn->getReg() > UCPMReg::T5)
	  {llvmerror(&@1, "Incorrect IALU RAdd/RSub inst! IALU.Tt should be T0-T5!");clear();YYABORT;} //niuxx 
	  
/*         if(flags[A1F])
		flagsort = 0b001;
	else if(flags[A2F])
		flagsort = 0b100;	
	else    flagsort = 0b000;*/
	ff = OPERAND(Imm, 0, FlagS, FlagE);
         
      if(flags[CIF])
      {
         llvmerror(&@1, "Incorrect IALU RAdd/RSub inst! Should not have CI flag!"); 
         clear();YYABORT;
      }
      if(flags[UF] && flags[A1F])
      {
         llvmerror(&@1, "Incorrect IALU RAdd/RSub inst! U and A1 should not coexist!"); 
         clear();YYABORT;
      }
      
         flagsort = (~(flags[UF]) << 5) | (flags[TF] << 2) | (0 << 1) | flags[FF];
         if(flags[BF])
	   flagsort |= 0b001000;
	 else if(flags[SF])
	   flagsort |= 0b000000;
	 else
	   flagsort |= 0b011000;
         f = OPERAND(Imm, flagsort, FlagS, FlagE);

     	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALURASToIALU_SHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
       break;
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALURASToIALU_MACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
       break;
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALURASToIALU_BIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
       break;
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALURASToIALU_M, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
       break;  
    case 4://to m[s++|i++|a++]
      ADDOPERAND(Opc, UCPM::IALURASToIALU_MSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
       break;  
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALURASToIALU_MDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
       break; 
      default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
}
}
| ialulogicclause ASSIGNTO ialudest {
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_And/Or/Xor inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_And/Or/Xor inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_And/Or/Xor inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_And/Or/Xor inst! _IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	  
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_And/Or/Xor inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_And/Or/Xor inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu    
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_And/Or/Xor inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu         
      
        if(flags[BF])
		flagsort = 0b00;
	else if	(flags[SF])
	        flagsort = 0b01;
	else if	(flags[NF])
	        flagsort = 0b11;
	else    flagsort = 0b10;
	f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALULogicToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//AND OR XOR
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALULogicToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//AND OR XOR
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALULogicToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//AND OR XOR
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALULogicToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//AND OR XOR
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALULogicToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//AND OR XOR
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
      case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALULogicToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
       break;   
      case 6://to ialu
      ADDOPERAND(Opc, UCPM::IALULogicToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//AND OR XOR
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
}
| ialulogicclause ASSIGNTO ialu_dest {
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_And/Or/Xor inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_And/Or/Xor inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_And/Or/Xor inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_And/Or/Xor inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_And/Or/Xor inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_And/Or/Xor inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
      if(tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@3, "Incorrect IALU_And/Or/Xor inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu	 
     
        if(flags[BF])
		flagsort = 0b00;
	else if	(flags[SF])
	        flagsort = 0b01;
	else if	(flags[NF])
	        flagsort = 0b11;
	else    flagsort = 0b10;
	f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALULogicToIALU_SHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//AND OR XOR
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALULogicToIALU_MACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//AND OR XOR
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALULogicToIALU_BIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//AND OR XOR
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALULogicToIALU_M, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//AND OR XOR
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALULogicToIALU_MSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//AND OR XOR
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
      case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALULogicToIALU_MDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
       break;   
      
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
}

| ialuequclause ASSIGNTO ialudest{
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_Equ inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_Equ inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_Equ inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Equ inst! _IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	  
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Equ inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Equ inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Equ inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu            
     
      flagsort = ((flags[BF]) << 3) | (flags[SF] << 2) | (flags[NF] << 1) | flags[FF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      flagsort = flags[SHIFTF];
      dis = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();
    switch ($3) {
    case 0://to shu //????
      ADDOPERAND(Opc, UCPM::IALUEquToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUEquToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALUEquToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
     case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUEquToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUEquToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
      case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALUEquToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
       break;   
      case 6://to ialu
      ADDOPERAND(Opc, UCPM::IALUEquToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
}

| ialuequclause ASSIGNTO ialu_dest{
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_Equ inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_Equ inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_Equ inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Equ inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Equ inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Equ inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu  
      if(tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@3, "Incorrect IALU_Equ inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu  	 
     
      flagsort = ((flags[BF]) << 3) | (flags[SF] << 2) | (flags[NF] << 1) | flags[FF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      flagsort = flags[SHIFTF];
      dis = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();
    switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALUEquToIALU_SHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUEquToIALU_MACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALUEquToIALU_BIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
     case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUEquToIALU_M, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUEquToIALU_MSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
      case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALUEquToIALU_MDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
       break;   
      
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
}
| ialushiftclause ASSIGNTO ialudest{
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_L/Rshift inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_L/Rshift inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_L/Rshift inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_L/Rshift inst! _IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	  
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_L/Rshift inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_L/Rshift inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_L/Rshift inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu	      
      
      ff = OPERAND(Imm, flagsort, FlagS, FlagE);
      flagsort = (~(flags[UF]) << 2) | (flags[BF] << 1) | (flags[SF]);
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      flagsort = flags[SHIFTF];
      dis = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALUShiftToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUShiftToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
     break;      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALUShiftToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break;
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUShiftToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
       break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUShiftToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
      case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALUShiftToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
       break;   
      case 6://to ialu
      ADDOPERAND(Opc, UCPM::IALUShiftToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
     break; 
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
}
| ialushiftclause ASSIGNTO ialu_dest{
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_L/Rshift inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_L/Rshift inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_L/Rshift inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_L/Rshift inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_L/Rshift inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_L/Rshift inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu	
      if(tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@3, "Incorrect IALU_L/Rshift inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu		 
      
      ff = OPERAND(Imm, flagsort, FlagS, FlagE);
      flagsort = (~(flags[UF]) << 2) | (flags[BF] << 1) | (flags[SF]);
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      flagsort = flags[SHIFTF];
      dis = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALUShiftToIALU_SHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUShiftToIALU_MACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
     break;      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALUShiftToIALU_BIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break;
case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUShiftToIALU_M, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
       break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUShiftToIALU_MSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
      case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALUShiftToIALU_MDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
       break;   
      
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
     // break;
  }
}
/*| ialurlshiclause ASSIGNTO ialudest{
      if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }
      
      flagsort = (flags[BF] << 1) | (flags[SF]);
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
    	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	flagsort = flags[SHIFTF];
        dis = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALURLShiToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALURLShiToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALURLShiToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
 case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALURLShiToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
       break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALURLShiToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
      case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALURLShiToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
       break; 
       case 6://to ialu
      ADDOPERAND(Opc, UCPM::IALURLShiToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
}
| ialurlshiclause ASSIGNTO ialu_dest{
      if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }
      
      flagsort = (flags[BF] << 1) | (flags[SF]);
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
    	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	flagsort = flags[SHIFTF];
        dis = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALURLShiToIALU_SHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALURLShiToIALU_MACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALURLShiToIALU_BIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
 case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALURLShiToIALU_M, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
       break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALURLShiToIALU_MSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
      case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALURLShiToIALU_MDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
       break;   
      default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
}*/
| ialuurynotclause ASSIGNTO ialudest{
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_Not inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_Not inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_Not inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Not inst! _IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	  
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Not inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Not inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
	      
      
    	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALUNOTToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));// NOT	
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUNOTToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALUNOTToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      break;
     
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUNOTToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUNOTToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
     case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALUNOTToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break; 
      case 6://to ialu
      ADDOPERAND(Opc, UCPM::IALUNOTToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      break;
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }

}
| ialuurynotclause ASSIGNTO ialu_dest{
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_Not inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_Not inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_Not inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Not inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Not inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@3, "Incorrect IALU_Not inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu	      
      
    	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALUNOTToIALU_SHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));// NOT	
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUNOTToIALU_MACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALUNOTToIALU_BIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
     
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUNOTToIALU_M, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUNOTToIALU_MSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
     case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALUNOTToIALU_MDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break; 
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }

}
| ialurshimmclause  ASSIGNTO ialudest{
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_RshiftI inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_RshiftI inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_RshiftI inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_RshiftI inst! _IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	  
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_RshiftI inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_RshiftI inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu	      
      
      flagsort = (~(flags[UF]) << 3) | (flags[BF] << 2) | (flags[SF] << 1 ) | (flags[ROUNDF] << 0 ) ;
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
    	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
        
        
        flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALURShiImmToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));// LSHI RSHI	
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 1://to macc
      ADDOPERAND(Opc, UCPM::IALURShiImmToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));// LSHI RSHI	
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 2://to biu
      ADDOPERAND(Opc, UCPM::IALURShiImmToBIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));// LSHI RSHI	
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALURShiImmToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALURShiImmToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
     case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALURShiImmToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break; 
      case 6://to ialu
      ADDOPERAND(Opc, UCPM::IALURShiImmToIALU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));// LSHI RSHI	
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }

}  
| ialurshimmclause  ASSIGNTO ialu_dest{
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_RshiftI inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_RshiftI inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_RshiftI inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_RshiftI inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_RshiftI inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@3, "Incorrect IALU_RshiftI inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu	      
      
      flagsort = (~(flags[UF]) << 3) | (flags[BF] << 2) | (flags[SF] << 1 ) | (flags[ROUNDF] << 0 ) ;
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
    	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
        
        
        flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALURShiImmToIALU_SHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));// LSHI RSHI	
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
      case 1://to macc
      ADDOPERAND(Opc, UCPM::IALURShiImmToIALU_MACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));// LSHI RSHI	
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
      case 2://to biu
      ADDOPERAND(Opc, UCPM::IALURShiImmToIALU_BIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));// LSHI RSHI	
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALURShiImmToIALU_M, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALURShiImmToIALU_MSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
     case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALURShiImmToIALU_MDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break; 
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }

}    
| ialulshimmclause  ASSIGNTO ialudest{
       /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_LshiftI inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_LshiftI inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_LshiftI inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_LshiftI inst! _IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	  
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_LshiftI inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_LshiftI inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu	      
      
      flagsort = (~(flags[UF]) << 4) | (flags[BF] << 3) | (flags[SF] << 2 ) | (flags[TF] << 1 ) | (flags[FF] << 0 ) ;
     
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
    	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
        
        
        flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALULShiImmToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 1://to macc
      ADDOPERAND(Opc, UCPM::IALULShiImmToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 2://to biu
      ADDOPERAND(Opc, UCPM::IALULShiImmToBIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALULShiImmToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALULShiImmToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
     case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALULShiImmToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break; 
      case 6://to ialu
      ADDOPERAND(Opc, UCPM::IALULShiImmToIALU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }

}    
| ialulshimmclause  ASSIGNTO ialu_dest{
       /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_LshiftI inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_LshiftI inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_LshiftI inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_LshiftI inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_LshiftI inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@3, "Incorrect IALU_LshiftI inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu	      
      
      flagsort = (~(flags[UF]) << 4) | (flags[BF] << 3) | (flags[SF] << 2 ) | (flags[TF] << 1 ) | (flags[FF] << 0 ) ;
     
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
    	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
        
        
        flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALULShiImmToIALU_SHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
      case 1://to macc
      ADDOPERAND(Opc, UCPM::IALULShiImmToIALU_MACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
      case 2://to biu
      ADDOPERAND(Opc, UCPM::IALULShiImmToIALU_BIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
      case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALULShiImmToIALU_M, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
      case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALULShiImmToIALU_MSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
     case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALULShiImmToIALU_MDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break; 
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
} 
| ialucprsclause  ASSIGNTO ialudest{
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_Cprs inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_Cprs inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_Cprs inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Cprs inst! _IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	  
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Cprs inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Cprs inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Cprs inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu	      
      
      flagsort = (~(flags[UF]) << 4) | (flags[TF] << 1 ) | flags[FF];
      if(flags[SF])
	 flagsort |= 0b01000;
      else
	 flagsort |= 0b00100;
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
        flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();
 switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALUCPRSToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUCPRSToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 2://to biu
      ADDOPERAND(Opc, UCPM::IALUCPRSToBIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUCPRSToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUCPRSToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
     case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALUCPRSToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break; 
      case 6://to ialu
      ADDOPERAND(Opc, UCPM::IALUCPRSToToIALU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
} 
| ialucprsclause  ASSIGNTO ialu_dest{
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_Cprs inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_Cprs inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_Cprs inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Cprs inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Cprs inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Cprs inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
      if(tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@3, "Incorrect IALU_Cprs inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu	 
      
      flagsort = (~(flags[UF]) << 4) | (flags[TF] << 1 ) | flags[FF];
      if(flags[SF])
	 flagsort |= 0b01000;
      else
	 flagsort |= 0b00100;
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
      flags.reset();
 switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALUCPRSToIALU_SHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUCPRSToIALU_MACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 2://to biu
      ADDOPERAND(Opc, UCPM::IALUCPRSToIALU_BIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUCPRSToIALU_M, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUCPRSToIALU_MSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
     case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALUCPRSToIALU_MDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break; 
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
}
  |  ialuexpdclause ASSIGNTO ialudest{
        /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_Expd inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_Expd inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_Expd inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Expd inst! _IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	  
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Expd inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
    }
	
	if(tm->getReg() > UCPMReg::T5)
	    {llvmerror(&@1, "Incorrect IALU_Expd inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu        	
        
      flagsort = (~(flags[UF]) <<2) ;
      if(flags[BF])
	flagsort |= 0b001;
	
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();
 switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALUEXPDToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUEXPDToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 2://to biu
      ADDOPERAND(Opc, UCPM::IALUEXPDToBIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUEXPDToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUEXPDToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
     case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALUEXPDToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break; 
      case 6://to ialu
      ADDOPERAND(Opc, UCPM::IALUEXPDToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
} 
 |  ialuexpdclause ASSIGNTO ialu_dest{
        /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_Expd inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_Expd inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_Expd inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Expd inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
     
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Expd inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu        
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@3, "Incorrect IALU_Expd inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu      
      
      flagsort = (~(flags[UF]) <<2) ;
      if(flags[BF])
	flagsort |= 0b001;
	
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
 
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();
 switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALUEXPDToIALU_SHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUEXPDToIALU_MACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 2://to biu
      ADDOPERAND(Opc, UCPM::IALUEXPDToIALU_BIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUEXPDToIALU_M, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUEXPDToIALU_MSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
     case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALUEXPDToIALU_MDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break; 
       default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
} 
      
  | ialureadqrclause ASSIGNTO ialudestTol {

      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_ReadQ/R inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_ReadQ/R inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_ReadQ/R inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;}//niuxx
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_ReadQ inst! _IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu  
	  break;    
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_ReadQ inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_ReadQ/R inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_ReadQ/R inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
      if (isIALUDoubleDest)
      {
	if (tp->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IALU_ReadQ/R inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }
	 
	 
      
        flagsort = (~flags[UF] << 4) | (flags[BF] << 3) |(flags[SF] << 2) | (flags[TF] << 1) | (flags[FF] << 0);
	f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALUReadQRToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUReadQRToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALUReadQRToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUReadQRToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUReadQRToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALUReadQRToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IALUReadQRToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
}
     
  | ialudivscclause {
  
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_DivStart inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_DivStart inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu	  
  
      ff = OPERAND(Imm, flagsort, FlagS, FlagE);
      flagsort = (~(flags[UF]) << 2) | (flags[BF] << 1) | (flags[SF] ) ;
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();

      ADDOPERAND(Opc, UCPM::IALUDivSC, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));// DIVSTART, DIVCONT
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
 
 }
| ialuwaitInstr{
            
      ADDOPERAND(Opc, UCPM::IALUWait, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    
}
| ialusendflagclause ASSIGNTO ialudestTol {

      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_Flag inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_Flag inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_Flag inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;}//niuxx
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Flag inst! _IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu	 
	  break;
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Flag inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if (isIALUDoubleDest)
      {
	if (tm->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IALU_Flag inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }      
      
      
 /*            if(flags[UF])
		flagsort = 0b10000;
	     else if(flags[NF])
		flagsort = 0b100;
	     else if(flags[CF])
		flagsort = 0b010;
	     else if(flags[VF])
		flagsort = 0b001;
		
	        
	     if(flags[ERASEF])
		flagsort |= 0b01000;*/
		
	flagsort = (flags[ERASEF] << 4) | (flags[UF] << 3) | (flags[NF] << 2) | (flags[CF] << 1) | flags[VF];
	
	f = OPERAND(Imm, flagsort, FlagS, FlagE);
	      	
	      	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALUSendFlagToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUSendFlagToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALUSendFlagToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUSendFlagToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUSendFlagToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALUSendFlagToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IALUSendFlagToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
}
| ialuwriteflagclause{

      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_WriteFlag inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
            
 /*            if(flags[UF])
		flagsort = 0b011;
	     else if(flags[NF])
		flagsort = 0b010;
	     else if(flags[CF])
		flagsort = 0b001;
	     else if(flags[VF])
		flagsort = 0b000;
	     else if(flags[AF])
	        flagsort = 0b10000;
	       
	        
	     if(flags[ERASEF])
		flagsort |= 0b01000;*/
		
             if(flags[UF])
		flagsort = 0b11;
	     else if(flags[NF])
		flagsort = 0b10;
	     else if(flags[CF])
		flagsort = 0b01;
	     else if(flags[VF])
		flagsort = 0b00;
	     else if(flags[AF])
	        flagsort = 0b100;
	        
	     if(flags[ERASEF])
		flagsort |= 0b1000;
		
		
      	f = OPERAND(Imm, flagsort, FlagS, FlagE);
      	flags.reset();
        
      ADDOPERAND(Opc, UCPM::IALUWriteFlag, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    
}
/*| ialuSetTIsFlagclause{

            
             if(flags[UF])
		flagsort = 0b100000;
	     else if(flags[NF])
		flagsort = 0b100;
	     else if(flags[CF])
		flagsort = 0b010;
	     else if(flags[VF])
		flagsort = 0b001;
	        
	     if(flags[LF])
		flagsort |= 0b011000;
	     else if(flags[CRF])
		flagsort &= 0b100111;
	     else
		flagsort |= 0b010000;
		
      	f = OPERAND(Imm, flagsort, FlagS, FlagE);
      	flags.reset();
        
      ADDOPERAND(Opc, UCPM::IALUSetTIsFlag, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    
}*/
| ialumodasclause ASSIGNTO ialudestTol {

      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_ModAdd/ModSub inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_ModAdd/ModSub inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_ModAdd/ModSub inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;}//niuxx
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_ModAdd/ModSub inst! _IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	      
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx	  
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_ModAdd/ModSub inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_ModAdd/ModSub inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_ModAdd/ModSub inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
      if (isIALUDoubleDest)
      {
	if (tp->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IALU_ModAdd/ModSub inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }      
      
        flagsort = (~flags[UF] << 2) | (flags[BF] << 1) | flags[SF];
	f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALUMODASToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUMODASToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALUMODASToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUMODASToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUMODASToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALUMODASToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IALUMODASToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
}
| ialuSignedasclause ASSIGNTO ialudestTol {

      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_Signed inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_Signed inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_Signed inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;}//niuxx
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Signed inst! _IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	      
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;}//niuxx	  
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Signed inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Signed inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Signed inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
      if (isIALUDoubleDest)
      {
	if (tp->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IALU_Signed inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }	       
      
        flagsort =  (flags[BF] << 1) | flags[SF];
	f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALUSIGNEDToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUSIGNEDToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALUSIGNEDToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUSIGNEDToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUSIGNEDToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALUSIGNEDToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IALUSIGNEDToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
      
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
}
| ialuMaskgenclause ASSIGNTO ialudestTol {//niu???

      if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }
      
        flagsort = flags[SF];
	f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALUMASKGENToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUMASKGENToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALUMASKGENToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUMASKGENToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUMASKGENToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALUMASKGENToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IALUMASKGENToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
      
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
}
| t ASSIGNTO ialudestTol {

      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_Mov inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_Mov inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_Mov inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;}//niuxx
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Mov inst! _IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	      
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;}//niuxx	  
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Mov inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Mov inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
      if (isIALUDoubleDest)
      {
	if (tn->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IALU_Mov inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }	       
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALUMOVToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUMOVToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALUMOVToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUMOVToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUMOVToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALUMOVToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IALUMOVToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      break;
      
      
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
}
| ialuBitFEclause ASSIGNTO ialudestTol {

      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_BitFilter/BitExpd inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_BitFilter/BitExpd inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_BitFilter/BitExpd inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;}//niuxx
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_BitFilter/BitExpd inst! _IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	      
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;}//niuxx	  
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_BitFilter/BitExpd inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_BitFilter/BitExpd inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_BitFilter/BitExpd inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
      if (isIALUDoubleDest)
      {
	if (tp->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IALU_BitFilter/BitExpd inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }	      
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALUBITFEToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUBITFEToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALUBITFEToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUBITFEToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUBITFEToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALUBITFEToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IALUBITFEToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
      
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
}
| ialuShiftTpclause ASSIGNTO ialudestTol {

      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_Shift inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_Shift inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_Shift inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;}//niuxx
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Shift inst! _IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	      
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;}//niuxx	  
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Shift inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Shift inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Shift inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
      if (tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Shift inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu	 
      if (isIALUDoubleDest)
      {
	if (tk->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IALU_Shift inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }	      
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALUShiftTpToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUShiftTpToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALUShiftTpToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUShiftTpToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUShiftTpToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALUShiftTpToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IALUShiftTpToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      break;
      
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
}
| ialucountfirstclause ASSIGNTO ialudestTol {

      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_First/Count inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_First/Count inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_First/Count inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;}//niuxx
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_First/Count inst! _IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	      
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;}//niuxx	  
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_First/Count inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_First/Count inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
      if (isIALUDoubleDest)
      {
	if (tn->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IALU_First/Count inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }	      
      
        flagsort = (flags[NF] << 2) | (flags[BF] << 1) | flags[SF];
	f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALUCountFirstToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUCountFirstToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALUCountFirstToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUCountFirstToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUCountFirstToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALUCountFirstToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IALUCountFirstToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
}
| ialuCompSelclause ASSIGNTO ialudestTol {

      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_CompSel0 inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_CompSel0 inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_CompSel0 inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;}//niuxx
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_CompSel0 inst! _IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	      
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;}//niuxx	  
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_CompSel0 inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T6)
	 {llvmerror(&@1, "Incorrect IALU_CompSel0 inst! Tm should be T0-T6!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T6)
	 {llvmerror(&@1, "Incorrect IALU_CompSel0 inst! Tn should be T0-T6!");clear();YYABORT;}//niuxu
      if(tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_CompSel0 inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu
      if(tk->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_CompSel0 inst! Tl should be T0-T5!");clear();YYABORT;}//niuxu	 
      if (isIALUDoubleDest)
      {
	if (tl->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IALU_CompSel0 inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }	      
      
/*           //ducx,20171205
      if(tp->getReg() == UCPMReg::T6 && tk->getReg() != UCPMReg::T7)
         {llvmerror(&@1, "Incorrect IALU CompSel0 inst! T6 must be followed by T7!");clear();YYABORT;}
      if(tp->getReg() == UCPMReg::T7 && tk->getReg() != UCPMReg::T6)
         {llvmerror(&@1, "Incorrect IALU CompSel0 inst! T7 must be followed by T6!");clear();YYABORT;}
      if( (tp->getReg() <= UCPMReg::T5 && tp->getReg() >= UCPMReg::T0) && (tk->getReg() == UCPMReg::T6 || tk->getReg() == UCPMReg::T7) )
         {llvmerror(&@1, "Incorrect IALU CompSel0 inst! Tl must be T0-T5!");clear();YYABORT;}
         
         //ducx,20171206
      if(tm->getReg() == UCPMReg::T7 || tn->getReg() == UCPMReg::T7)
         {llvmerror(&@1, "Incorrect IALU CompSel0 inst! Tm/Tn should not be T7!");clear();YYABORT;}*/
         
      flagsort =  (flags[GF] << 4) | (flags[AF] << 6) | (flags[XF] << 5) | (flags[BF] << 3) | (flags[SF] << 2) | (flags[TF] << 1) | flags[FF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALUCompSelToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUCompSelToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALUCompSelToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUCompSelToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUCompSelToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALUCompSelToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IALUCompSelToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
}
| ialuCompSel1clause ASSIGNTO ialudestTol {

      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_CompSel1 inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_CompSel1 inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_CompSel1 inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;}//niuxx
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_CompSel1 inst! _IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	      
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;}//niuxx	  
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_CompSel1 inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T6)
	 {llvmerror(&@1, "Incorrect IALU_CompSel1 inst! Tm should be T0-T6!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T6)
	 {llvmerror(&@1, "Incorrect IALU_CompSel1 inst! Tn should be T0-T6!");clear();YYABORT;}//niuxu
      if(tp->getReg() == UCPMReg::T6 && tk->getReg() != UCPMReg::T7)
         {llvmerror(&@1, "Incorrect IALU_CompSel1 inst! Tp = T6 then Tl = T7!");clear();YYABORT;}//niuxu
      if(tp->getReg() == UCPMReg::T7 && tk->getReg() != UCPMReg::T6)
         {llvmerror(&@1, "Incorrect IALU_CompSel1 inst! Tp = T7 then Tl = T6!");clear();YYABORT;}//niuxu    
      if (isIALUDoubleDest)
      {
	if (tl->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IALU_CompSel1 inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }	      
      
/*           //ducx,20171205
      if(tp->getReg() == UCPMReg::T6 && tk->getReg() != UCPMReg::T7)
         {llvmerror(&@1, "Incorrect IALU CompSel1 inst! T6 must be followed by T7!");clear();YYABORT;}
      if(tp->getReg() == UCPMReg::T7 && tk->getReg() != UCPMReg::T6)
         {llvmerror(&@1, "Incorrect IALU CompSel1 inst! T7 must be followed by T6!");clear();YYABORT;}
      if( (tp->getReg() <= UCPMReg::T5 && tp->getReg() >= UCPMReg::T0) && (tk->getReg() == UCPMReg::T6 || tk->getReg() == UCPMReg::T7) )
         {llvmerror(&@1, "Incorrect IALU CompSel1 inst! Tl must be T0-T5!");clear();YYABORT;}
         
      //ducx,20171206
      if(tm->getReg() == UCPMReg::T7 || tn->getReg() == UCPMReg::T7)
         {llvmerror(&@1, "Incorrect IALU CompSel1 inst! Tm/Tn should not be T7!");clear();YYABORT;}*/
         
      //flagsort =  (flags[GF] << 5) | (flags[AF] << 4) | (flags[NF] << 3) | (~flags[UF] << 2) | (flags[BF] << 1) | (flags[SF]) ;
      flagsort =  (flags[AF] << 3) | (~flags[UF] << 2) | (flags[BF] << 1) | (flags[SF]) ;
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALUCompSel1ToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUCompSel1ToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALUCompSel1ToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUCompSel1ToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUCompSel1ToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALUCompSel1ToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IALUCompSel1ToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
}
| ialuCompSel2clause ASSIGNTO ialudestTol {

      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_CompSel2 inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_CompSel2 inst! IFMAC..Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_CompSel2 inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;}//niuxx
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_CompSel2 inst! _IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;}//niuxx	  
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_CompSel2 inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_CompSel2 inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_CompSel2 inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
      if(tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_CompSel2 inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tk->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_CompSel2 inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu	 
      if (isIALUDoubleDest)
      {
	if (tl->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IALU_CompSel2 inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }	      
      
/*           //ducx,20171205
      if(tp->getReg() == UCPMReg::T6 && tk->getReg() != UCPMReg::T7)
         llvmerror(&@1, "T6 must be followed by T7!");
      if(tp->getReg() == UCPMReg::T7 && tk->getReg() != UCPMReg::T6)
         llvmerror(&@1, "T7 must be followed by T6!");
      if( (tp->getReg() <= UCPMReg::T5 && tp->getReg() >= UCPMReg::T0) && (tk->getReg() == UCPMReg::T6 || tk->getReg() == UCPMReg::T7) )
         llvmerror(&@1, "Tl must be T0-T5!");
         
      //ducx,20171206
      if(tm->getReg() == UCPMReg::T7 || tn->getReg() == UCPMReg::T7)
         llvmerror(&@1, "Tm/Tn should not be T7!");  */
         
      //flagsort =  (flags[GF] << 5) | (flags[AF] << 4) | (flags[NF] << 3) | (~flags[UF] << 2) | (flags[BF] << 1) | (flags[SF]) ;
      flagsort =  (flags[AF] << 3) | (flags[LF] << 2) | (flags[BF] << 1) | (flags[SF]) ;
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALUCompSel2ToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUCompSel2ToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALUCompSel2ToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUCompSel2ToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUCompSel2ToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALUCompSel2ToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IALUCompSel2ToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
}
| ialuSelclause ASSIGNTO ialudestTol {

      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_Sel0 inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_Sel0 inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_Sel0 inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;}//niuxx
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Sel0 inst! _IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	      
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;}//niuxx	  
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Sel0 inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Sel0 inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
 
      if (isIALUDoubleDest)
      {
	if (tk->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IALU_Sel0 inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }	      
      
      flagsort =  (flags[PF] << 6) | (~flags[UF] << 5) | (flags[BF] << 4) | (flags[SF] << 3) | (flags[TF] << 2) |(flags[FF] << 1) | flags[LF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALUSelToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUSelToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALUSelToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUSelToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUSelToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALUSelToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IALUSelToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
}
| ialuSel1clause ASSIGNTO ialudestTol {

      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_Sel1 inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_Sel1 inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_Sel1 inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;}//niuxx
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Sel1 inst! _IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	      
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;}//niuxx	  
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Sel1 inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Sel1 inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Sel1 inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Sel1 inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu	 
      if (isIALUDoubleDest)
      {
	if (tk->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IALU_Sel1 inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }	      
      
/*      //ducx,20171206
      if(tm->getReg() == UCPMReg::T6 || tn->getReg() == UCPMReg::T6)
         {llvmerror(&@1, "Incorrect IALU Sel1 inst! Tm/Tn should not be T6!");clear();YYABORT;}*/
         
      flagsort =  (flags[NF] << 6) | (~flags[UF] << 5) | (flags[BF] << 4) | (flags[SF] << 3) | (flags[TF] << 2) |(flags[FF] << 1) | flags[CIF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALUSel1ToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUSel1ToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALUSel1ToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUSel1ToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUSel1ToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALUSel1ToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IALUSel1ToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
}
| ialuConjclause ASSIGNTO ialudestTol {

      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_Conj inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_Conj inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_Conj inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;}//niuxx
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Conj inst! _IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	      
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;}//niuxx	  
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Conj inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Conj inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu
      if (isIALUDoubleDest)
      {
	if (tn->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IALU_Conj inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }	      
      
      flagsort = (flags[BF] << 3) | (flags[SF] << 2) | (flags[TF] << 1) |(flags[FF] << 0) ;
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALUConjToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUConjToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALUConjToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUConjToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUConjToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALUConjToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IALUConjToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
}
| ialuFindclause ASSIGNTO ialudestTol {

      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IALU_Find inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IALU_Find inst! IFALU.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IALU_Find inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;}//niuxx
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Find inst! _IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	      
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;}//niuxx	  
	  //case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IALU_Find inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Find inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IALU_Find inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
      if (isIALUDoubleDest)
      {
	if (tp->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IALU_Find inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }	      
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IALUFindToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IALUFindToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IALUFindToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IALUFindToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IALUFindToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IALUFindToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IALUFindToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
      
    default:
      llvmerror(&@3, "invalid IALU dest!");clear();YYABORT;
      //break;
  }
}
| setCGInstr{
            
          flagsort = (flags[ONF]);
          f = OPERAND(Imm, flagsort, FlagS, FlagE);	
	  flags.reset();
	   
	    ADDOPERAND(Opc, UCPM::IALUSetCG, @$.S, @$.E);
	    Operands.push_back(nullptr);
	    condpos = Operands.size();
	    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));  
    
};

ialusetcondInstr: ialucond{   
	    isSetCond = true;
	    ADDOPERAND(Opc, UCPM::IALUSetCond, @$.S, @$.E);
	    Operands.push_back(nullptr);
	    condpos = Operands.size();
	    if (imm == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
	    if (imm1 == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));   
	  };
ialucond: IMMSYM DOT IMM5 ASSIGNTO IALU DOT SETCOND LBRACKET IMM5 RBRACKET 
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $9, @9.S, @9.E);};   
	  
ialuasclause: iaddclause {$$ = $1; opc = OPERAND(Reg, UCPMReg::f_IADD, @$.S, @$.E);} |
              isubclause {$$ = $1; opc = OPERAND(Reg, UCPMReg::f_ISUB, @$.S, @$.E);};
iaddclause: addexp _flag ialuaddflags flag_ {$$ = $1;} |
	    addexp {$$ = $1;};
           
iaddclause: addexp _flag error flag_ {llvmerror(&@3, "IALU/IFALU_Add flags error! Available flags are T,CI,F,B/S,U"); clear();YYABORT;};//niuxx
isubclause: subexp _flag ialusubflags flag_ {$$ = $1;} |
	    subexp {$$ = $1;};
	    
isubclause: subexp _flag error flag_ {llvmerror(&@3, "IALU/IFALU_Sub flags error! Available flags are T,CI,F,B/S,U"); clear();YYABORT;};//niuxx
addexp: t ADD t {$$=0;} |
        //ABS _flag OR t OR ADD t flag_ {$$=1;}|
        //ABS _flag t ADD t flag_ {$$=2;} |
        //OR t OR ADD OR t OR {$$=3;} |       
	OR t OR ADD t  {$$=4;};
subexp: t SUB t {$$=0;} |
	//ABS _flag OR t OR SUB t flag_ {$$=1;}|
        //ABS _flag t SUB t flag_ {$$=7;} |
        //OR t OR SUB OR t OR {$$=3;} |       
	//OR t OR SUB t  {$$=4;} |
	//ABS _flag OR t OR SUB OR t OR flag_ {$$=5;} |
	t SUB OR t OR {$$=6;} ;
	
	
ialulogicclause: iandclause {opc = OPERAND(Reg, UCPMReg::m_AND, @$.S, @$.E);} | 
                 iorclause {opc = OPERAND(Reg, UCPMReg::m_OR, @$.S, @$.E);} | 
                 ixorclause {opc = OPERAND(Reg, UCPMReg::m_XOR, @$.S, @$.E);} ;
//haoxb
iandclause: andexp | andexp _flag ialulogicflags flag_ |
	    andexp _flag error flag_ {llvmerror(&@3, "IALU/IFALU_And flags error! Available flags are B/S/N"); clear();YYABORT;};//niuxx
 andexp:  t AND t  ;
iorclause : orexp | orexp _flag ialulogicflags flag_ |
	    orexp _flag error flag_ {llvmerror(&@3, "IALU/IFALU_Or flags error! Available flags are B/S/N"); clear();YYABORT;};//niuxx
orexp:  t OR t  ;
ixorclause : xorexp | xorexp _flag ialulogicflags flag_ |
	     xorexp _flag error flag_ {llvmerror(&@3, "IALU/IFALU_Xor flags error! Available flags are B/S/N"); clear();YYABORT;};//niuxx
xorexp:  t XOR t  ;

//haoxb
ialuequclause:iequclause {opc = OPERAND(Reg, UCPMReg::m_IEQU, @$.S, @$.E);};
iequclause:  t EQU t  |  t EQU t  _flag ialuequflags flag_ |

	     t EQU t  _flag error flag_ {llvmerror(&@5, "IALU/IFALU_Equ flags error! Available flags are B/S,F,N"); clear();YYABORT;};//niuxx
//equexp:  t EQU t  ;



              //haoxb//
ialuindclause : LPAREN t COMMA t RPAREN IND t _flag t flag_ {opc = OPERAND(Reg, UCPMReg::m_INDEX, @$.S, @$.E);};
ialuindclause : LPAREN t COMMA t RPAREN IND t error {llvmerror(&@8, "IALU/IFALU IND tm must be followed by (tn)"); clear();YYABORT;};



ialushiftclause:  ifm_LSHTclause  {opc = OPERAND(Reg, UCPMReg::m_LSHT, @$.S, @$.E);
                  flagsort = (flags[TF]<<1) | flags[ROUNDF];}  |
                  ifm_RSHTclause {opc = OPERAND(Reg, UCPMReg::m_RSHT, @$.S, @$.E);
                   if (flags[ROUNDF]) flagsort=0b01;else flagsort=0b00;} ;
//ifm_LSHTclause: t LSHT t _flag ialushiftflags flag_ | t LSHT t;
ifm_LSHTclause: t LSHT t _flag ialulshflags flag_ | t LSHT t |
		
		t LSHT t _flag error flag_ {llvmerror(&@5, "IALU/IFALU_Lshift flags error! Available flags are B/S,U,T,Round"); clear();YYABORT;};//niuxx
ifm_RSHTclause: t RSHT t _flag ialurshflags flag_ | t RSHT t |

		t RSHT t _flag error flag_ {llvmerror(&@5, "IALU/IFALU_Rshift flags error! Available flags are B/S,U,Round"); clear();YYABORT;};//niuxx
//lshiexp :t LSHT t;
//rshiexp :t RSHT t;

/*ialurlshiclause: ifm_RLSHTclause {opc = OPERAND(Reg, UCPMReg::m_LSHT, @$.S, @$.E);} ;
ifm_RLSHTclause: rlshiexp _flag ialuflags flag_ | rlshiexp ;
rlshiexp : t LSHT t _flag ROUND flag_ ;*/

            
ialucprsclause: ifm_CPRSclause  {opc = OPERAND(Reg, UCPMReg::m_CPRS, @$.S, @$.E);}  ;    
ifm_CPRSclause : cprsexp _flag ialucprsflags flag_ | cprsexp |

		 cprsexp _flag error flag_ {llvmerror(&@3, "IALU/IFALU_Cprs flags error! Available flags are U,S,T,F"); clear();YYABORT;};//niuxx
cprsexp : CPRS _flag dupara flag_;



ialuexpdclause:  ifm_EXPDclause {opc = OPERAND(Reg, UCPMReg::m_EXPD, @$.S, @$.E);} ;
ifm_EXPDclause: EXPD t _flag ialuubsflags flag_ | EXPD t |
    
		EXPD t _flag error flag_ {llvmerror(&@4, "IALU/IFALU_Expd flags error! Available flags are U,B/S"); clear();YYABORT;};//niuxx
ialuurynotclause: ifm_NOTclause {opc = OPERAND(Reg, UCPMReg::m_NOT, @$.S, @$.E); };
ifm_NOTclause: NOT t;


//haoxb
ialurasclause: ifm_RADDclause {opc = OPERAND(Reg, UCPMReg::m_RADD, @$.S, @$.E);} |
               ifm_RSUBclause {opc = OPERAND(Reg, UCPMReg::m_RSUB, @$.S, @$.E);};
ifm_RADDclause: RADD t _flag ialuraddflags flag_ | RADD t |

		RADD t _flag error flag_ {llvmerror(&@4, "IALU/IFALU_RAdd flags error! Available flags are T,F,B/S,U"); clear();YYABORT;};//niuxx
ifm_RSUBclause: RSUB t _flag ialursubflags flag_ | RSUB t |

		RSUB t _flag error flag_ {llvmerror(&@4, "IALU/IFALU_RSub flags error! Available flags are T,F,B/S,U"); clear();YYABORT;};//niuxx
ialulshimmclause:  if_LSHTIclause  {opc = OPERAND(Reg, UCPMReg::f_LSHTI, @$.S, @$.E);}  ;		    
ialurshimmclause:  if_RSHTIclause  {opc = OPERAND(Reg, UCPMReg::f_RSHTI, @$.S, @$.E);}  ;		    
		    
if_LSHTIclause: t LSHT IMM5 _flag ialulshiflags flag_ {imm = OPERAND(Imm, $3, @3.S, @3.E);}|
	        t LSHT IMM5 {imm = OPERAND(Imm, $3, @3.S, @3.E);} |
	      
	        t LSHT IMM5 _flag error flag_ {llvmerror(&@5, "IALU/IFALU_LshiftI flags error! Available flags are U,B/S,T"); clear();YYABORT;};//niuxx
if_RSHTIclause: t RSHT IMM5 _flag ialuubsflags flag_ {imm = OPERAND(Imm, $3, @3.S, @3.E);}|
	        t RSHT IMM5 {imm = OPERAND(Imm, $3, @3.S, @3.E);} |

	        t RSHT IMM5 _flag error flag_ {llvmerror(&@5, "IALU/IFALU_RshiftI flags error! Available flags are U,B/S"); clear();YYABORT;};//niuxx
ialureadqrclause: if_READQclause  {opc = OPERAND(Reg, UCPMReg::READQ, @$.S, @$.E);}  |
                  if_READRclause {opc = OPERAND(Reg, UCPMReg::READR, @$.S, @$.E);};
if_READQclause :  readqexp _flag ialureadqflags flag_ | readqexp |
		  
		  readqexp _flag error flag_ {llvmerror(&@3, "IALU/IFALU_ReadQ flags error! Available flags are U,B/S,T,F"); clear();YYABORT;};//niuxx
if_READRclause : readrexp _flag ialuubsflags flag_ | readrexp |

		 readrexp _flag error flag_ {llvmerror(&@3, "IALU/IFALU_ReadR flags error! Available flags are U,B/S"); clear();YYABORT;};//niuxx
readqexp : READQ LPAREN dupara RPAREN;
readrexp : READR LPAREN dupara RPAREN;

ialudivscclause:  if_DIVSTARTclause  {opc = OPERAND(Reg, UCPMReg::DIVSTART, @$.S, @$.E);flagsort=flags[TF];}  |
                  if_DIVCONTclause {opc = OPERAND(Reg, UCPMReg::DIVCONT, @$.S, @$.E);flagsort=0;};
if_DIVSTARTclause :  divstartexp _flag ialuubsflags flag_ | divstartexp |   
      
		     divstartexp _flag error flag_ {llvmerror(&@3, "IALU/IFALU_DivStart flags error! Available flags are U,B/S"); clear();YYABORT;};//niuxx
if_DIVCONTclause : divcontexp _flag ialuubsflags flag_ | divcontexp | 

		   divcontexp _flag error flag_ {llvmerror(&@3, "IALU/IFALU_DivCont flags error! Available flags are U,B/S"); clear();YYABORT;};//niuxx
divstartexp : DIVSTART LPAREN dupara RPAREN;
divcontexp : DIVCONT LPAREN dupara RPAREN;               
                  


ialuwaitInstr: WAIT IMM5 {imm = OPERAND(Imm, $2, @2.S, @2.E);};


ialusendflagclause: FLAG _flag ialuflagflags flag_ | FLAG |

		    FLAG _flag error flag_ {llvmerror(&@3, "IALU/IFALU_Flag flags error! Available flags are U/N/C/V,Erased"); clear();YYABORT;};//niuxx
//ialuSetTIsFlagclause: SETTISFLAG _flag ialusendflags flag_ | SETTISFLAG;
ialuwriteflagclause: writeflagexp _flag ialuwriteflagflags flag_ | writeflagexp |

		     writeflagexp _flag error flag_ {llvmerror(&@3, "IALU/IFALU_WriteFlag flags error! Available flags are U/N/C/V/A,Erased"); clear();YYABORT;};//niuxx
writeflagexp: t ASSIGNTO WRITEFLAG;

ialudest: shut {$$ = 0;} | maccdest {$$ = 1;} | biut {$$ = 2;} | mindexn | mindexsia | mindexdis | _ialut;
ialu_dest:IALU DOT t AND ialudest {$$ = $5;};
ifaludest: shut {$$ = 0;} | maccdest {$$ = 1;} | biut {$$ = 2;} | mindexn | mindexsia | mindexdis | _ifalut;
ifalu_dest:IFALU DOT t AND ifaludest {$$ = $5;};//haoxb



ialumodasclause:  ModAddclause {opc = OPERAND(Reg, UCPMReg::MODADD, @$.S, @$.E);} |
                  ModSubclause {opc = OPERAND(Reg, UCPMReg::MODSUB, @$.S, @$.E);};
ModAddclause :  MODADD _flag dupara flag_ _flag ialuubsflags flag_ | MODADD _flag dupara flag_ |  

		MODADD _flag dupara flag_ _flag error flag_ {llvmerror(&@6, "IALU/IFALU_ModAdd flags error! Available flags are U,B/S"); clear();YYABORT;};//niuxx
ModSubclause :  MODSUB _flag dupara flag_ _flag ialuubsflags flag_ | MODSUB _flag dupara flag_ |

		MODSUB _flag dupara flag_ _flag error flag_ {llvmerror(&@6, "IALU/IFALU_ModSub flags error! Available flags are U,B/S"); clear();YYABORT;};//niuxx
ialuSignedasclause: SIGNED _flag dupara flag_ _flag ialusignedflags flag_ | SIGNED _flag dupara flag_ | 

		    SIGNED _flag dupara flag_ _flag error flag_ {llvmerror(&@6, "IALU/IFALU_Signed flags error! Available flags are B/S"); clear();YYABORT;};//niuxx
ialuMaskgenclause: MASKGEN t _flag ialuflags flag_ | MASKGEN t;

ialuBitFEclause:  bitfilterclause {opc = OPERAND(Reg, UCPMReg::BITFILTER, @$.S, @$.E);} |
                  bitexpdclause {opc = OPERAND(Reg, UCPMReg::BITEXPD, @$.S, @$.E);};
bitfilterclause :   BITFILTER _flag dupara flag_;               
bitexpdclause : BITEXPD _flag dupara flag_;  

ialuShiftTpclause: SHIFT _flag dupara flag_ RSHT t;

ialucountfirstclause: countclause {opc = OPERAND(Reg, UCPMReg::COUNT, @$.S, @$.E);} |
		      firstclause {opc = OPERAND(Reg, UCPMReg::FIRST, @$.S, @$.E);};
countclause :  COUNT t _flag ialucfflags flag_ | COUNT t |

	       COUNT t _flag error flag_ {llvmerror(&@4, "IALU/IFALU_Count flags error! Available flags are B/S,N"); clear();YYABORT;};//niuxx 
firstclause :  FIRST t _flag ialucfflags flag_ | FIRST t |  

	       FIRST t _flag error flag_ {llvmerror(&@4, "IALU/IFALU_First flags error! Available flags are B/S,N"); clear();YYABORT;};//niuxx 
ialuCompSelclause: COMPSEL _flag tripara COMMA t flag_ LPAREN SIGN RPAREN _flag ialucompsel0flags flag_ |
		   COMPSEL _flag tripara COMMA t flag_ LPAREN SIGN RPAREN |
		  
		   COMPSEL _flag tripara COMMA t flag_ LPAREN SIGN RPAREN _flag error flag_ {llvmerror(&@11, "IALU/IFALU_CompSel flags error! Available flags are B/S,A,X,T"); clear();YYABORT;};//niuxx
ialuCompSel1clause: COMPSEL _flag tripara COMMA t flag_  _flag ialucompsel1flags flag_ | 
		    COMPSEL _flag tripara COMMA t flag_ |
		    
		    COMPSEL _flag tripara COMMA t flag_  _flag error flag_ {llvmerror(&@8, "IALU/IFALU_CompSel flags error! Available flags are U,B/S,A"); clear();YYABORT;};//niuxx
ialuCompSel2clause: COMPSEL _flag tripara COMMA t flag_ LPAREN SIGNEDT RPAREN _flag ialucompsel2flags flag_ |
		    COMPSEL _flag tripara COMMA t flag_ LPAREN SIGNEDT RPAREN |
		    
		    COMPSEL _flag tripara COMMA t flag_ LPAREN SIGNEDT RPAREN _flag error flag_ {llvmerror(&@11, "IALU/IFALU_Compsel flags error! Available flags are L,B/S,A"); clear();YYABORT;};//niuxx
ialuSelclause: SEL _flag tripara flag_ _flag ialusel0flags flag_ | SEL _flag tripara flag_ |

	       SEL _flag tripara flag_ _flag error flag_ {llvmerror(&@6, "IALU/IFALU_Sel flags error! Available flags are T,F,B/S,U,P,L"); clear();YYABORT;};//niuxx
ialuSel1clause: SEL _flag tripara flag_ LPAREN COMP RPAREN _flag ialusel1flags flag_ |
	        SEL _flag tripara flag_ LPAREN COMP RPAREN |

		SEL _flag tripara flag_ LPAREN COMP RPAREN _flag error flag_ {llvmerror(&@9, "IALU/IFALU_Sel flags error! Available flags are N,T,CI,F,B/S,U"); clear();YYABORT;};//niuxx
ialuConjclause: CONJ t | CONJ t _flag ialuconjflags flag_ |

		CONJ t _flag error flag_ {llvmerror(&@4, "IALU/IFALU_Conj flags error! Available flags are B/S,T,F"); clear();YYABORT;};//niuxx
ialuFindclause: FIND _flag dupara flag_;

ialudestTol: ialudest{$$=$1;} | ialu_dest{$$=$1;isIALUDoubleDest = true;};//ducx
ifaludestTol: ifaludest{$$=$1;} | ifalu_dest{$$=$1;isIALUDoubleDest = true;};//haoxb
// end ialu -------------------------------------------------- 



imacbiut0:BIU0 DOT TREG {treg = OPERAND(Imm, $3, @3.S, @3.E);  if(treg->getImm() == 0)
		          ut = OPERAND(Reg, UCPMReg::BIU0T0, @3.S, @3.E);
		        else if(treg->getImm() == 1)
		          ut = OPERAND(Reg, UCPMReg::BIU0T1, @3.S, @3.E);
		        else if(treg->getImm() == 2)
		          ut = OPERAND(Reg, UCPMReg::BIU0T2, @3.S, @3.E);
		        else if(treg->getImm() == 3)
		          ut = OPERAND(Reg, UCPMReg::BIU0T3, @3.S, @3.E);
		        else
			  {llvmerror(&@3, "Incorrect IMAC/IFMAC inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
		        };
		       
imacbiut1:BIU1 DOT TREG {treg = OPERAND(Imm, $3, @3.S, @3.E);  if(treg->getImm() == 0)
		          ut = OPERAND(Reg, UCPMReg::BIU1T0, @3.S, @3.E);
		        else if(treg->getImm() == 1)
		          ut = OPERAND(Reg, UCPMReg::BIU1T1, @3.S, @3.E);
		        else if(treg->getImm() == 2)
		          ut = OPERAND(Reg, UCPMReg::BIU1T2, @3.S, @3.E);
		        else if(treg->getImm() == 3)
		          ut = OPERAND(Reg, UCPMReg::BIU1T3, @3.S, @3.E);
		        else
			  {llvmerror(&@3, "Incorrect IMAC/IFMAC inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
		        };
imacbiut2:BIU2 DOT TREG {treg = OPERAND(Imm, $3, @3.S, @3.E);  if(treg->getImm() == 0)
		          ut = OPERAND(Reg, UCPMReg::BIU2T0, @3.S, @3.E);
		        else if(treg->getImm() == 1)
		          ut = OPERAND(Reg, UCPMReg::BIU2T1, @3.S, @3.E);
		        else if(treg->getImm() == 2)
		          ut = OPERAND(Reg, UCPMReg::BIU2T2, @3.S, @3.E);
		        else if(treg->getImm() == 3)
		          ut = OPERAND(Reg, UCPMReg::BIU2T3, @3.S, @3.E);
		        else   
		          {llvmerror(&@3, "Incorrect IMAC/IFMAC inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
		        };
		          
		          
// start ifalu --------------------------------------------------
ifaluslot: IFALU DOT ifaluinst | ifaluurytran | ifalusetcondInstr;
ifaluslot: IFALU DOT error { llvmerror(&@1, "Incorrect IFALU inst."); clear();YYABORT;} ;

ifaluinst:  ialuindclause ASSIGNTO ifaludest {
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{ llvmerror(&@3, "IFALUInd can not assign to IMAC!"); clear();YYABORT;
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
	else if(unit3->getReg() == UCPMReg::IALUIALU)//IALU
	  {llvmerror(&@3, "IFALUInd can not assign to IALU!"); clear();YYABORT;}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	      {llvmerror(&@3, "IFALU_Index can not assign to IMAC!");clear();YYABORT;}//niuxu
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_Add/Sub inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUSHU0 :
	  case UCPMReg::IALUSHU1 :
	  case UCPMReg::IALUSHU2 :
	    llvmerror(&@3, "IFALU_Index can not assign to SHU!");clear();YYABORT;//niuxu
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    llvmerror(&@3, "IFALU_Index can not assign to BIU!");clear();YYABORT;//niuxu
	  break;  
	  /*case UCPMReg::_IALUIALU :   //IALU->IALU 
	    {llvmerror(&@3, "IFALU_Indxe can not assign to IALU!");clear();YYABORT;}//niuxu
	  break;*/
	  case UCPMReg::_IFALUIFALU :   //IFALU->IFALU	    
	    if(ut->getReg() > UCPMReg::T5)
		{llvmerror(&@3, "Incorrect IFALU_Index inst! _IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }       
      
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Index inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Index inst! Tl should be T0-T5!");clear();YYABORT;}//niuxu  
      if(tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Index inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tk->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Index inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu                      
      
switch ($3) {
    case 0://to shu
    //llvmerror(&@3, "IFALUInd can not assign to SHU!"); clear();YYABORT;
      ADDOPERAND(Opc, UCPM::IFALUIndToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
       break;
      
    case 1://to macc
     ADDOPERAND(Opc, UCPM::IFALUIndToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      break;
      
    case 2://to biu
    //llvmerror(&@3, "IFALUInd can not assign to BIU!"); clear();YYABORT;
      ADDOPERAND(Opc, UCPM::IFALUIndToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      break;
      
      case 3://to M[t]
      ADDOPERAND(Opc, UCPM::IFALUIndToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      break;
      
      case 4://to m[s++/i++/a++] 
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);	      
      flags.reset();
      ADDOPERAND(Opc, UCPM::IFALUIndToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
      
      case 5://to m[dis(shift)] 
      flagsort = (flags[SHIFTF]);
      dis = OPERAND(Imm, flagsort, FlagS, FlagE);	
      flags.reset();	      
      ADDOPERAND(Opc, UCPM::IFALUIndToDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break;
      case 6://to ialu
     ADDOPERAND(Opc, UCPM::IFALUIndToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      break;
       default:
      llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }

}
| ialuindclause ASSIGNTO ifalu_dest {
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{llvmerror(&@3, "IFALUInd can not assign to IMAC!"); clear();YYABORT;
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
	else if(unit3->getReg() == UCPMReg::IALUIALU)//IFALU
	  {llvmerror(&@3, "IFALUInd can not assign to IALU!"); clear();YYABORT;}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	     {llvmerror(&@3, "IFALU_Index can not assign to IMAC!");clear();YYABORT;}//niuxu
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_Index inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUSHU0 :
	  case UCPMReg::IALUSHU1 :
	  case UCPMReg::IALUSHU2 :
	    llvmerror(&@3, "IFALU_Index can not assign to SHU!");clear();YYABORT;//niuxu
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    llvmerror(&@3, "IFALU_Index can not assign to BIU!");clear();YYABORT;//niuxu
	  break;  
/*	  case UCPMReg::_IALUIALU :   //IALU->IALU 
	      if(ut->getReg() > UCPMReg::T5)
		{llvmerror(&@3, "Incorrect IFALU_Index inst! Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	  case UCPMReg::IALUIFALU :   //IALU->IFALU
	    {llvmerror(&@3, "IFALU_Indxe can not assign to IFALU!");clear();YYABORT;}//niuxu
	  break;*/
	}
      }       
      
      
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Index inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Index inst! Tl should be T0-T5!");clear();YYABORT;}//niuxu  
      if(tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Index inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tk->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Index inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu   
      if(tl->getReg() > UCPMReg::T5)
	 {llvmerror(&@3, "Incorrect IFALU_Index inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu 

	 
switch ($3) {
    case 0://to shu
    //llvmerror(&@3, "IFALUInd can not assign to SHU!"); clear();YYABORT;
      ADDOPERAND(Opc, UCPM::IFALUIndToIALU_SHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
       break;
      
    case 1://to macc
     ADDOPERAND(Opc, UCPM::IFALUIndToIALU_MACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      break;
      
    case 2://to biu
    //llvmerror(&@3, "IFALUInd can not assign to BIU!"); clear();YYABORT;
      ADDOPERAND(Opc, UCPM::IFALUIndToIALU_BIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      break;
      
      case 3://to M[t]
      ADDOPERAND(Opc, UCPM::IFALUIndToIALU_M, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      break;
      
      case 4://to m[s++/i++/a++] 
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);	      
      flags.reset();
      ADDOPERAND(Opc, UCPM::IFALUIndToIALU_MSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
      
      case 5://to m[dis(shift)] 
      flagsort = (flags[SHIFTF]);
      dis = OPERAND(Imm, flagsort, FlagS, FlagE);	
      flags.reset();	      
      ADDOPERAND(Opc, UCPM::IFALUIndToIALU_Dis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break;   
      default:
       llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
   }
   }
|ialuasclause ASSIGNTO ifaludest  {
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_Add/Sub inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_Add/Sub inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_Add/Sub inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Add/Sub inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;    
	  case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Add/Sub inst! _IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }      
      
/*      //ducx,20171206
      if(tm->getReg() == UCPMReg::T6)
         {llvmerror(&@1, "Incorrect IFALU add/sub inst! Tm should not be T6!");clear();YYABORT;}
      if(tn->getReg() == UCPMReg::T7)
         {llvmerror(&@1, "Incorrect IFALU add/sub inst! Tn should not be T7!");clear();YYABORT;}
 */        
      if (opc->getReg() == UCPMReg::f_IADD) 
      {
         if(tm->getReg() > UCPMReg::T5)
	    {llvmerror(&@1, "Incorrect IALU_Add/Sub inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
	 if(tn->getReg() > UCPMReg::T6)
	    {llvmerror(&@1, "Incorrect IALU_Add/Sub inst! Tn should be T0-T6!");clear();YYABORT;}//niuxu
      }
      else if (opc->getReg() == UCPMReg::f_ISUB)
      {
         if(tm->getReg() == UCPMReg::T6)
	    {llvmerror(&@1, "Incorrect IALU_Add/Sub inst! Tm should be T0-T5,T7!");clear();YYABORT;}//niuxu
	 if(tn->getReg() > UCPMReg::T5)
	    {llvmerror(&@1, "Incorrect IALU_Add/Sub inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu      
      }
	 
      switch($1)
      {
	case 0 : flagsort = 0;break;
	//case 1 : flagsort = 6;break;
	//case 2 : flagsort = 4;break;
	//case 3 : flagsort = 3;break;
	case 4 : flagsort = 1;break;
	//case 5 : flagsort = 7;break;
	case 6 : flagsort = 1;break;
	//case 7 : flagsort = 4;break;
	
      }
      ff = OPERAND(Imm, flagsort, FlagS, FlagE);
      
      if(flagsort != 0 && flags[CIF])
      {
         llvmerror(&@1, "Incorrect IFALU add/sub inst! Should not have CI flag!"); 
         clear();YYABORT;
      }
      if( ($1 != 0 && $1 != 7 && flags[UF]) )
      {
         llvmerror(&@1, "Incorrect IFALU add/sub inst! Should not have U flag!"); 
         clear();YYABORT;
      }
      
      flagsort = (~(flags[UF]) << 5) | (flags[BF] << 4) | (flags[SF] << 3) | (flags[TF] << 2) | (flags[CIF] << 1) | flags[FF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE);

      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      flagsort = flags[SHIFTF];
      dis = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();
        
  switch ($3) {
    case 0://to shu  
      ADDOPERAND(Opc, UCPM::IFALUASToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ADD or SUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
       break;
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUASToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ADD or SUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break;     
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUASToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ADD or SUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break;    
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUASToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ADD or SUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break;        
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUASToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ADD or SUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
    case 5://to m[dis{shift}]
      ADDOPERAND(Opc, UCPM::IFALUASToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ADD or SUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break;
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IFALUASToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ADD or SUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break;    
    default:
      llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
       //break;
  }

}
|ialuasclause ASSIGNTO ifalu_dest  {
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T6)
	    {llvmerror(&@3, "Incorrect IFALU_Add/Sub inst! Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	  else if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T6)
	    {llvmerror(&@3, "Incorrect IFALU_Add/Sub inst! Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	  else if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_Add/Sub inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_Add/Sub inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_Add/Sub inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Add/Sub inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }       
      
/*           //ducx,20171206
      if(tm->getReg() == UCPMReg::T6 )
         {llvmerror(&@1, "Incorrect IFALU add/sub inst! Tm should not be T6!");clear();YYABORT;}
      if(tn->getReg() == UCPMReg::T7)
         {llvmerror(&@1, "Incorrect IFALU add/sub inst! Tn should not be T7!");clear();YYABORT;}
 */
      if (opc->getReg() == UCPMReg::f_IADD) 
      {
         if(tm->getReg() > UCPMReg::T5)
	    {llvmerror(&@1, "Incorrect IALU_Add/Sub inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
	 if(tn->getReg() > UCPMReg::T6)
	    {llvmerror(&@1, "Incorrect IALU_Add/Sub inst! Tn should be T0-T6!");clear();YYABORT;}//niuxu
      }
      else if (opc->getReg() == UCPMReg::f_ISUB)
      {
         if(tm->getReg() == UCPMReg::T6)
	    {llvmerror(&@1, "Incorrect IALU_Add/Sub inst! Tm should be T0-T5,T7!");clear();YYABORT;}//niuxu
	 if(tn->getReg() > UCPMReg::T5)
	    {llvmerror(&@1, "Incorrect IALU_Add/Sub inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu      
      }
      if(tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@3, "Incorrect IFALU_Add/Sub inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu	
	 
      switch($1)
      {
	case 0 : flagsort = 0;break;
	//case 1 : flagsort = 6;break;
	//case 2 : flagsort = 4;break;
	//case 3 : flagsort = 3;break;
	case 4 : flagsort = 1;break;
	//case 5 : flagsort = 7;break;
	case 6 : flagsort = 1;break;
	//case 7 : flagsort = 4;break;
      }
      ff = OPERAND(Imm, flagsort, FlagS, FlagE);
      
      if(flagsort != 0 && flags[CIF])
      {
         llvmerror(&@1, "Incorrect IFALU add/sub inst! Should not have CI flag!"); 
         clear();YYABORT;
      }
      if( ($1 != 0 && $1 != 7 && flags[UF]) )
      {
         llvmerror(&@1, "Incorrect IFALU add/sub inst! Should not have U flag!"); 
         clear();YYABORT;
      }
      
      flagsort = (~(flags[UF]) << 5) | (flags[BF] << 4) | (flags[SF] << 3) | (flags[TF] << 2) | (flags[CIF] << 1) | flags[FF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE);

      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
      flagsort = flags[SHIFTF];
      dis = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUASToIALU_SHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ADD or SUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break;
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUASToIALU_MACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ADD or SUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break;     
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUASToIALU_BIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ADD or SUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break;
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUASToIALU_M, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ADD or SUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break;
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUASToIALU_MSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ADD or SUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;      
    case 5://to m[dis{shift}]
      ADDOPERAND(Opc, UCPM::IFALUASToIALU_MDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//ADD or SUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break;
    default:
      llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
       //break;
  }

}
| ialurasclause ASSIGNTO ifaludest{
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_RAdd/RSub inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_RAdd/RSub inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_RAdd/RSub inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_RAdd/RSub inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	  
	  case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_RAdd/RSub inst! _IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }        
      
     if(tm->getReg() > UCPMReg::T5 )
	{llvmerror(&@1, "Incorrect IFALU_RAdd/RSub inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
	
/*         if(flags[A1F])
		flagsort = 0b001;
        else if(flags[A2F])
		flagsort = 0b100;	
	else    flagsort = 0b000;*/
	ff = OPERAND(Imm, 0, FlagS, FlagE);
		
      if(flags[CIF])
      {
         llvmerror(&@1, "Incorrect IFALU radd/rsub inst! Should not have CI flag!"); 
         clear();YYABORT;
      }
      if(flags[UF] && flags[A1F])
      {
         llvmerror(&@1, "Incorrect IFALU radd/rsub inst! U and A1 should not coexist!"); 
         clear();YYABORT;
      }
      
         flagsort = (~(flags[UF]) << 5) | (flags[TF] << 2) | (0 << 1) | flags[FF];
         if(flags[BF])
	   flagsort |= 0b001000;
	 else if(flags[SF])
	   flagsort |= 0b000000;
	 else
	   flagsort |= 0b011000;
	   
         f = OPERAND(Imm, flagsort, FlagS, FlagE);

     	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALURASToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break;
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALURASToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break; 
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALURASToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break;  
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALURASToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break;  
    case 4://to m[s++|i++|a++]
      ADDOPERAND(Opc, UCPM::IFALURASToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;  
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALURASToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break;
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IFALURASToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break; 
     default:
      llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
 }
}
| ialurasclause ASSIGNTO ifalu_dest{
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_RAdd/RSub inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_RAdd/RSub inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_RAdd/RSub inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_RAdd/RSub inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
      
     if(tm->getReg() > UCPMReg::T5 )
	{llvmerror(&@1, "Incorrect IFALU_RAdd/RSub inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
     if(tn->getReg() > UCPMReg::T5 )
	{llvmerror(&@3, "Incorrect IFALU_RAdd/RSub inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu	
/*         if(flags[A1F])
		flagsort = 0b001;
	else if(flags[A2F])
		flagsort = 0b100;	
	else    flagsort = 0b000;*/
	ff = OPERAND(Imm, 0, FlagS, FlagE);
         
      if(flags[CIF])
      {
         llvmerror(&@1, "Incorrect IFALU radd/rsub inst! Should not have CI flag!"); 
         clear();YYABORT;
      }
      if(flags[UF] && flags[A1F])
      {
         llvmerror(&@1, "Incorrect IFALU radd/rsub inst! U and A1 should not coexist!"); 
         clear();YYABORT;
      }
      
         flagsort = (~(flags[UF]) << 5) | (flags[TF] << 2) | (0 << 1) | flags[FF];
         if(flags[BF])
	   flagsort |= 0b001000;
	 else if(flags[SF])
	   flagsort |= 0b000000;
	 else
	   flagsort |= 0b011000;
         f = OPERAND(Imm, flagsort, FlagS, FlagE);

     	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALURASToIALU_SHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
       break;
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALURASToIALU_MACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
       break;
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALURASToIALU_BIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
       break;
       case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALURASToIALU_M, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
       break;  
      case 4://to m[s++|i++|a++]
      ADDOPERAND(Opc, UCPM::IFALURASToIALU_MSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
       break;  
      case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALURASToIALU_MDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
       break; 
       default:
    llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      // default:
       //llvm_unreachable("invalid IFALU dest");
}
}
| ialulogicclause ASSIGNTO ifaludest {
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_And/Or/Xor inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_And/Or/Xor inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_And/Or/Xor inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_And/Or/Xor inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	  
	  case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_And/Or/Xor inst! _IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_And/Or/Xor inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu  
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_And/Or/Xor inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu   	 
      
        if(flags[BF])
		flagsort = 0b00;
	else if	(flags[SF])
	        flagsort = 0b01;
	else if	(flags[NF])
	        flagsort = 0b11;
	else    flagsort = 0b10;
	f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALULogicToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//AND OR XOR
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALULogicToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//AND OR XOR
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALULogicToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//AND OR XOR
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALULogicToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//AND OR XOR
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALULogicToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//AND OR XOR
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
      case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALULogicToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
       break;   
      case 6://to ialu
      ADDOPERAND(Opc, UCPM::IFALULogicToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//AND OR XOR
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
    default:
   llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }
}
| ialulogicclause ASSIGNTO ifalu_dest {
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_And/Or/Xor inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_And/Or/Xor inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_And/Or/Xor inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_And/Or/Xor inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_And/Or/Xor inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu  
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_And/Or/Xor inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu 
      if(tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@3, "Incorrect IFALU_And/Or/Xor inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu  	 
     
        if(flags[BF])
		flagsort = 0b00;
	else if	(flags[SF])
	        flagsort = 0b01;
	else if	(flags[NF])
	        flagsort = 0b11;
	else    flagsort = 0b10;
	f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALULogicToIALU_SHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//AND OR XOR
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALULogicToIALU_MACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//AND OR XOR
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALULogicToIALU_BIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//AND OR XOR
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALULogicToIALU_M, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//AND OR XOR
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALULogicToIALU_MSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//AND OR XOR
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
      case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALULogicToIALU_MDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//RADD or RSUB
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
       break;   
      
    default:
      llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }
}

| ialuequclause ASSIGNTO ifaludest{
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
     
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_Equ inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_Equ inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_Equ inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Equ inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	  
	  case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Equ inst! _IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Equ inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Equ inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu     
     
      flagsort = ((flags[BF]) << 3) | (flags[SF] << 2) | (flags[NF] << 1) | flags[FF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      flagsort = flags[SHIFTF];
      dis = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();
    switch ($3) {
    case 0://to shu //????
      ADDOPERAND(Opc, UCPM::IFALUEquToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUEquToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUEquToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
     case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUEquToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUEquToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
      case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUEquToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
       break;   
      case 6://to ialu
      ADDOPERAND(Opc, UCPM::IFALUEquToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
    default:
     llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }
}

| ialuequclause ASSIGNTO ifalu_dest{
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_Equ inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_Equ inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_Equ inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Equ inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Equ inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Equ inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu  
      if(tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@3, "Incorrect IFALU_Equ inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu 	 
     
      flagsort = ((flags[BF]) << 3) | (flags[SF] << 2) | (flags[NF] << 1) | flags[FF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      flagsort = flags[SHIFTF];
      dis = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();
    switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUEquToIALU_SHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUEquToIALU_MACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUEquToIALU_BIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
     case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUEquToIALU_M, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUEquToIALU_MSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
      case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUEquToIALU_MDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
       break;   
      
    default:
      llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }
}
| ialushiftclause ASSIGNTO ifaludest{
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_L/Rshift inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_L/Rshift inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_L/Rshift inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_L/Rshift inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	  
	  case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_L/Rshift inst! _IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_L/Rshift inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_L/Rshift inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu	      
      
      ff = OPERAND(Imm, flagsort, FlagS, FlagE);
      flagsort = (~(flags[UF]) << 2) | (flags[BF] << 1) | (flags[SF]);
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      flagsort = flags[SHIFTF];
      dis = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUShiftToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUShiftToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
     break;      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUShiftToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break;
case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUShiftToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
       break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUShiftToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
      case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUShiftToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
       break;   
      case 6://to ialu
      ADDOPERAND(Opc, UCPM::IFALUShiftToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
     break; 
    default:
       llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }
}
| ialushiftclause ASSIGNTO ifalu_dest{
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_L/Rshift inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_L/Rshift inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_L/Rshift inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_L/Rshift inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_L/Rshift inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_L/Rshift inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
      if(tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@3, "Incorrect IFALU_L/Rshift inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu	 	 
      
      ff = OPERAND(Imm, flagsort, FlagS, FlagE);
      flagsort = (~(flags[UF]) << 2) | (flags[BF] << 1) | (flags[SF]);
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      flagsort = flags[SHIFTF];
      dis = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUShiftToIALU_SHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUShiftToIALU_MACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
     break;      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUShiftToIALU_BIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      break;
case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUShiftToIALU_M, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
       break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUShiftToIALU_MSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
      case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUShiftToIALU_MDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));//Equ
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
       break;   
      
    default:
       llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }
}
/*| ialurlshiclause ASSIGNTO ifaludest{
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }
      
      flagsort = (flags[BF] << 1) | (flags[SF]);
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
    	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	flagsort = flags[SHIFTF];
        dis = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALURLShiToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALURLShiToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALURLShiToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
 case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALURLShiToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
       break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALURLShiToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
      case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALURLShiToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
       break; 
       case 6://to ialu
      ADDOPERAND(Opc, UCPM::IFALURLShiToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      default:
       llvmerror(&@1, "invalid IFALU dest!");
      //break;
  }
}
| ialurlshiclause ASSIGNTO ifalu_dest{
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }
      
      flagsort = (flags[BF] << 1) | (flags[SF]);
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
    	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	flagsort = flags[SHIFTF];
        dis = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALURLShiToIALU_SHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALURLShiToIALU_MACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALURLShiToIALU_BIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
 case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALURLShiToIALU_M, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
       break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALURLShiToIALU_MSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
      case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALURLShiToIALU_MDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
       break;   
      default:
       llvmerror(&@1, "invalid IFALU dest!");
      //break;
  }
}*/
| ialuurynotclause ASSIGNTO ifaludest{
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_Not inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_Not inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_Not inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Not inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	  
	  case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Not inst! _IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Not inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu	      
      
    	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUNOTToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));// NOT	
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUNOTToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUNOTToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      break;
     
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUNOTToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUNOTToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
     case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUNOTToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break; 
      case 6://to ialu
      ADDOPERAND(Opc, UCPM::IFALUNOTToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      break;
    default:
       llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }

}
| ialuurynotclause ASSIGNTO ifalu_dest{
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_Not inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_Not inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_Not inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Not inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Not inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@3, "Incorrect IFALU_Not inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu	      
      
    	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUNOTToIALU_SHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));// NOT	
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUNOTToIALU_MACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUNOTToIALU_BIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
     
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUNOTToIALU_M, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUNOTToIALU_MSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
     case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUNOTToIALU_MDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break; 
    default:
       llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }

}
| ialurshimmclause  ASSIGNTO ifaludest{
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_RshiftI inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_RshiftI inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_RshiftI inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_RshiftI inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	  
	  case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_RshiftI inst! _IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_RshiftI inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu      
      
      flagsort = (~(flags[UF]) << 3) | (flags[BF] << 2) | (flags[SF] << 1 ) | (flags[ROUNDF] << 0 ) ;
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
    	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
        
        
        flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALURShiImmToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));// LSHI RSHI	
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALURShiImmToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));// LSHI RSHI	
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALURShiImmToBIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));// LSHI RSHI	
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALURShiImmToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALURShiImmToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
     case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALURShiImmToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break; 
      case 6://to ialu
      ADDOPERAND(Opc, UCPM::IFALURShiImmToIALU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));// LSHI RSHI	
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
    default:
       llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }

}  
| ialurshimmclause  ASSIGNTO ifalu_dest{
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_RshiftI inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_RshiftI inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_RshiftI inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_RshiftI inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_RshiftI inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_RshiftI inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu	      
      
      flagsort = (~(flags[UF]) << 3) | (flags[BF] << 2) | (flags[SF] << 1 ) | (flags[ROUNDF] << 0 ) ;
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
    	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
        
        
        flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALURShiImmToIALU_SHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));// LSHI RSHI	
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
      case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALURShiImmToIALU_MACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));// LSHI RSHI	
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
      case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALURShiImmToIALU_BIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));// LSHI RSHI	
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALURShiImmToIALU_M, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALURShiImmToIALU_MSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
     case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALURShiImmToIALU_MDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break; 
    default:
      llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }

}    
| ialulshimmclause  ASSIGNTO ifaludest{
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
       /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_LshiftI inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_LshiftI inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_LshiftI inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_LshiftI inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	  
	  case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_LshiftI inst! _IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_LshiftI inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu      
      
      flagsort = (~(flags[UF]) << 4) | (flags[BF] << 3) | (flags[SF] << 2 ) | (flags[TF] << 1 ) | (flags[FF] << 0 ) ;
     
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
    	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
        
        
        flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALULShiImmToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALULShiImmToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALULShiImmToBIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALULShiImmToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALULShiImmToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
     case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALULShiImmToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break; 
      case 6://to ialu
      ADDOPERAND(Opc, UCPM::IFALULShiImmToIALU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
    default:
       llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }

}    
| ialulshimmclause  ASSIGNTO ifalu_dest{
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
       /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_LshiftI inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_LshiftI inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_LshiftI inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_LshiftI inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_LshiftI inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_LshiftI inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu	      
      
      flagsort = (~(flags[UF]) << 4) | (flags[BF] << 3) | (flags[SF] << 2 ) | (flags[TF] << 1 ) | (flags[FF] << 0 ) ;
     
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
    	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
        
        
        flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALULShiImmToIALU_SHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
      case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALULShiImmToIALU_MACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
      case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALULShiImmToIALU_BIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
      case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALULShiImmToIALU_M, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
      case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALULShiImmToIALU_MSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
     case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALULShiImmToIALU_MDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break; 
    default:
       llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }
} 
| ialucprsclause  ASSIGNTO ifaludest{
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_Cprs inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_Cprs inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_Cprs inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Cprs inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	  
	  case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Cprs inst! _IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Cprs inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Cprs inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu	      
      
      flagsort = (~(flags[UF]) << 4) | (flags[TF] << 1 ) | flags[FF];
      if(flags[SF])
	 flagsort |= 0b01000;
      else
	 flagsort |= 0b00100;
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
        flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();
 switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUCPRSToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUCPRSToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUCPRSToBIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUCPRSToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUCPRSToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
     case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUCPRSToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break; 
      case 6://to ialu
      ADDOPERAND(Opc, UCPM::IFALUCPRSToToIALU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
    default:
       llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }
} 
| ialucprsclause  ASSIGNTO ifalu_dest{
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_Cprs inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_Cprs inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_Cprs inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Cprs inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Cprs inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Cprs inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
      if(tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@3, "Incorrect IFALU_Cprs inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu	 
      
      flagsort = (~(flags[UF]) << 4) | (flags[TF] << 1 ) | flags[FF];
      if(flags[SF])
	 flagsort |= 0b01000;
      else
	 flagsort |= 0b00100;
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
      flags.reset();
 switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUCPRSToIALU_SHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUCPRSToIALU_MACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUCPRSToIALU_BIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUCPRSToIALU_M, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUCPRSToIALU_MSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
     case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUCPRSToIALU_MDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break; 
    default:
       llvmerror(&@1, "invalid IFALU dest!");
      //break;
  }
}
  |  ialuexpdclause ASSIGNTO ifaludest{
        llvm::UCPM::is_ifalu = true;
        llvm::UCPM::is_ialu = false;
        /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_Expd inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_Expd inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_Expd inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Expd inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	  
	  case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Expd inst! _IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Expd inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu            
      
      flagsort = (~(flags[UF]) <<2) ;
      if(flags[BF])
	flagsort |= 0b001;
	
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();
 switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUEXPDToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUEXPDToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUEXPDToBIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUEXPDToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUEXPDToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
     case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUEXPDToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break; 
      case 6://to ialu
      ADDOPERAND(Opc, UCPM::IFALUEXPDToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
    default:
       llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }
} 
 |  ialuexpdclause ASSIGNTO ifalu_dest{
       llvm::UCPM::is_ifalu = true;
       llvm::UCPM::is_ialu = false;
        /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_Expd inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_Expd inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_Expd inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	  //case UCPMReg::_IFALUIFALU :	//IFALU->IFALU  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Expd inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	  {llvmerror(&@1, "Incorrect IFALU_Expd inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu        
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@3, "Incorrect IFALU_Expd inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu	      
      
      flagsort = (~(flags[UF]) <<2) ;
      if(flags[BF])
	flagsort |= 0b001;
	
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
 
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();
 switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUEXPDToIALU_SHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUEXPDToIALU_MACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUEXPDToIALU_BIU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUEXPDToIALU_M, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUEXPDToIALU_MSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      break;
     case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUEXPDToIALU_MDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      break; 
       default:
       llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }
} 
      
  | ialureadqrclause ASSIGNTO ifaludestTol {
        llvm::UCPM::is_ifalu = true;
	llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_ReadQ/R inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_ReadQ/R inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_ReadQ/R inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx	
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_ReadQ/R inst! _IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;    
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_ReadQ/R inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_ReadQ/R inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_ReadQ/R inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
      if (isIALUDoubleDest)
      {
	if (tp->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IFALU_ReadQ/R inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }      
      
      
      
        flagsort = (~flags[UF] << 4) | (flags[BF] << 3) |(flags[SF] << 2) | (flags[TF] << 1) | (flags[FF] << 0);
	f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUReadQRToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUReadQRToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUReadQRToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUReadQRToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUReadQRToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUReadQRToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IFALUReadQRToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    default:
       llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }
}
     
  | ialudivscclause {
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
        
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_DivStart inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_DivStart inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu        
        
      ff = OPERAND(Imm, flagsort, FlagS, FlagE);
      flagsort = (~(flags[UF]) << 2) | (flags[BF] << 1) | (flags[SF] ) ;
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();

      ADDOPERAND(Opc, UCPM::IFALUDivSC, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));// DIVSTART, DIVCONT
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
 
 }
| ialuwaitInstr{
                  llvm::UCPM::is_ifalu = true;
                  llvm::UCPM::is_ialu = false;
      ADDOPERAND(Opc, UCPM::IFALUWait, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    
}
| ialusendflagclause ASSIGNTO ifaludestTol {
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_Flag inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_Flag inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_Flag inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx	
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Flag inst! _IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	      
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Flag inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if (isIALUDoubleDest)
      {
	if (tm->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IFALU_Flag inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }	       
      
/*             if(flags[UF])
		flagsort = 0b10000;
	     else if(flags[NF])
		flagsort = 0b100;
	     else if(flags[CF])
		flagsort = 0b010;
	     else if(flags[VF])
		flagsort = 0b001;
	        
	     if(flags[ERASEF])
		flagsort |= 0b01000;*/
		
	flagsort = (flags[ERASEF] << 4) | (flags[UF] << 3) | (flags[NF] << 2) | (flags[CF] << 1) | flags[VF];
	
	f = OPERAND(Imm, flagsort, FlagS, FlagE);
	      	
	      	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUSendFlagToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUSendFlagToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUSendFlagToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUSendFlagToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUSendFlagToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUSendFlagToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IFALUSendFlagToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    default:
       llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }
}
| ialuwriteflagclause{
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_WriteFlag inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu      
      
/*             if(flags[UF])
		flagsort = 0b011;
	     else if(flags[NF])
		flagsort = 0b010;
	     else if(flags[CF])
		flagsort = 0b001;
	     else if(flags[VF])
		flagsort = 0b000;
	     else if(flags[AF])
	        flagsort = 0b10000;
	        
	     if(flags[ERASEF])
		flagsort |= 0b01000;*/
		
	     if(flags[UF])
		flagsort = 0b11;
	     else if(flags[NF])
		flagsort = 0b10;
	     else if(flags[CF])
		flagsort = 0b01;
	     else if(flags[VF])
		flagsort = 0b00;
	     else if(flags[AF])
	        flagsort = 0b100;
	       
	     if(flags[ERASEF])
		flagsort |= 0b1000;
		
		        
      	f = OPERAND(Imm, flagsort, FlagS, FlagE);
      	flags.reset();
        
      ADDOPERAND(Opc, UCPM::IFALUWriteFlag, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    
}
/*| ialuSetTIsFlagclause{
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
             if(flags[UF])
		flagsort = 0b100000;
	     else if(flags[NF])
		flagsort = 0b100;
	     else if(flags[CF])
		flagsort = 0b010;
	     else if(flags[VF])
		flagsort = 0b001;
	        
	     if(flags[LF])
		flagsort |= 0b011000;
	     else if(flags[CRF])
		flagsort &= 0b100111;
	     else
		flagsort |= 0b010000;
		
      	f = OPERAND(Imm, flagsort, FlagS, FlagE);
      	flags.reset();
        
      ADDOPERAND(Opc, UCPM::IFALUSetTIsFlag, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
    
}*/
| ialumodasclause ASSIGNTO ifaludestTol {
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_ModAdd/ModSub inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_ModAdd/ModSub inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_ModAdd/ModSub inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_ModAdd/ModSub inst! _IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	      
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_ModAdd/ModSub inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_ModAdd/ModSub inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_ModAdd/ModSub inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
      if (isIALUDoubleDest)
      {
	if (tp->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IFALU_ModAdd/ModSub inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }      
      
        flagsort = (~flags[UF] << 2) | (flags[BF] << 1) | flags[SF];
	f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUMODASToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUMODASToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUMODASToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUMODASToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUMODASToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUMODASToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IFALUMODASToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    default:
       llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }
}
| ialuSignedasclause ASSIGNTO ifaludestTol {
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_Signed inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_Signed inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_Signed inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Signed inst! _IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	      
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Signed inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Signed inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Signed inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
      if (isIALUDoubleDest)
      {
	if (tp->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IFALU_Signed inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }	       
      
        flagsort =  (flags[BF] << 1) | flags[SF];
	f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUSIGNEDToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUSIGNEDToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUSIGNEDToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUSIGNEDToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUSIGNEDToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUSIGNEDToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IFALUSIGNEDToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
      
    default:
       llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }
}
| ialuMaskgenclause ASSIGNTO ifaludestTol {//niu???
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }
      
        flagsort = flags[SF];
	f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUMASKGENToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUMASKGENToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUMASKGENToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUMASKGENToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUMASKGENToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUMASKGENToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IFALUMASKGENToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
      
    default:
       llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }
}
| t ASSIGNTO ifaludestTol {
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_Mov inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_Mov inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_Mov inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx	
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Mov inst! _IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	      
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Mov inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Mov inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
      if (isIALUDoubleDest)
      {
	if (tn->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IFALU_Mov inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }	      
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUMOVToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUMOVToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUMOVToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUMOVToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUMOVToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUMOVToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IFALUMOVToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      break;
      
      
    default:
       llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }
}
| ialuBitFEclause ASSIGNTO ifaludestTol {
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_BitFilter/BitExpd inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_BitFilter/BitExpd inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_BitFilter/BitExpd inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_BitFilter/BitExpd inst! _IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	      
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_BitFilter/BitExpd inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_BitFilter/BitExpd inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_BitFilter/BitExpd inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
      if (isIALUDoubleDest)
      {
	if (tp->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IFALU_BitFilter/BitExpd inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }	      
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUBITFEToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUBITFEToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUBITFEToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUBITFEToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUBITFEToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUBITFEToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IFALUBITFEToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
      
    default:
      llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }
}
| ialuShiftTpclause ASSIGNTO ifaludestTol {
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_Shift inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_Shift inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_Shift inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx	
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Shift inst! _IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	      
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Shift inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if (tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Shift inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if (tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Shift inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
      if (tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Shift inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu	 
      if (isIALUDoubleDest)
      {
	if (tk->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IFALU_Shift inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }	      
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUShiftTpToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUShiftTpToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUShiftTpToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUShiftTpToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUShiftTpToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUShiftTpToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IFALUShiftTpToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      break;
      
    default:
      llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }
}
| ialucountfirstclause ASSIGNTO ifaludestTol {
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
     
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_First/Count inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_First/Count inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_First/Count inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_First/Count inst! _IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	      
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_First/Count inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_First/Count inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
      if (isIALUDoubleDest)
      {
	if (tn->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IFALU_First/Count inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }	     
      
        flagsort = (flags[NF] << 2) | (flags[BF] << 1) | flags[SF];
	f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUCountFirstToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUCountFirstToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUCountFirstToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUCountFirstToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUCountFirstToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUCountFirstToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IFALUCountFirstToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    default:
      llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      // break;
  }
}
| ialuCompSelclause ASSIGNTO ifaludestTol {
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;     
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
            
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_CompSel0 inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_CompSel0 inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_CompSel0 inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_CompSel0 inst! _IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	      
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_CompSel0 inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T6)
	 {llvmerror(&@1, "Incorrect IFALU_CompSel0 inst! Tm should be T0-T6!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T6)
	 {llvmerror(&@1, "Incorrect IFALU_CompSel0 inst! Tn should be T0-T6!");clear();YYABORT;}//niuxu
      if(tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_CompSel0 inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu
      if(tk->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_CompSel0 inst! Tl should be T0-T5!");clear();YYABORT;}//niuxu	 
      if (isIALUDoubleDest)
      {
	if (tl->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IFALU_CompSel0 inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }	       
      
      //ducx,20171205
/*      if(tp->getReg() == UCPMReg::T6 && tk->getReg() != UCPMReg::T7)
         {llvmerror(&@1, "Incorrect IFALU CompSel0 inst! T6 must be followed by T7!");clear();YYABORT;}
      if(tp->getReg() == UCPMReg::T7 && tk->getReg() != UCPMReg::T6)
         {llvmerror(&@1, "Incorrect IFALU CompSel0 inst! T7 must be followed by T6!");clear();YYABORT;}
      if( (tp->getReg() <= UCPMReg::T5 && tp->getReg() >= UCPMReg::T0) && (tk->getReg() == UCPMReg::T6 || tk->getReg() == UCPMReg::T7) )
         {llvmerror(&@1, "Incorrect IFALU CompSel0 inst! Tl must be T0-T5!");clear();YYABORT;}
         
      //ducx,20171206
      if(tm->getReg() == UCPMReg::T7 || tn->getReg() == UCPMReg::T7)
         {llvmerror(&@1, "Incorrect IFALU CompSel0 inst! Tm/Tn should not be T7!");clear();YYABORT;}*/
         
      flagsort =  (flags[GF] << 4) | (flags[AF] << 6) | (flags[XF] << 5) | (flags[BF] << 3) | (flags[SF] << 2) | (flags[TF] << 1) | flags[FF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUCompSelToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUCompSelToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUCompSelToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUCompSelToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUCompSelToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUCompSelToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IFALUCompSelToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    default:
     llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      // break;
  }
}
| ialuCompSel1clause ASSIGNTO ifaludestTol {
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_CompSel1 inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_CompSel1 inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_CompSel1 inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_CompSel1 inst! _IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	      
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_CompSel1 inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T6)
	 {llvmerror(&@1, "Incorrect IALU_CompSel1 inst! Tm should be T0-T6!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T6)
	 {llvmerror(&@1, "Incorrect IALU_CompSel1 inst! Tn should be T0-T6!");clear();YYABORT;}//niuxu
      if(tp->getReg() == UCPMReg::T6 && tk->getReg() != UCPMReg::T7)
         {llvmerror(&@1, "Incorrect IALU_CompSel1 inst! Tp = T6 then Tl = T7!");clear();YYABORT;}//niuxu
      if(tp->getReg() == UCPMReg::T7 && tk->getReg() != UCPMReg::T6)
         {llvmerror(&@1, "Incorrect IALU_CompSel1 inst! Tp = T7 then Tl = T6!");clear();YYABORT;}//niuxu    
      if (isIALUDoubleDest)
      {
	if (tl->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IALU_CompSel1 inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }      
      
/*           //ducx,20171205
      if(tp->getReg() == UCPMReg::T6 && tk->getReg() != UCPMReg::T7)
         {llvmerror(&@1, "Incorrect IFALU CompSel1 inst! T6 must be followed by T7!");clear();YYABORT;}
      if(tp->getReg() == UCPMReg::T7 && tk->getReg() != UCPMReg::T6)
         {llvmerror(&@1, "Incorrect IFALU CompSel1 inst! T7 must be followed by T6!");clear();YYABORT;}         
      if( (tp->getReg() <= UCPMReg::T5 && tp->getReg() >= UCPMReg::T0) && (tk->getReg() == UCPMReg::T6 || tk->getReg() == UCPMReg::T7) )
         {llvmerror(&@1, "Incorrect IFALU CompSel1 inst! Tl must be T0-T5!");clear();YYABORT;}

      //ducx,20171206
      if(tm->getReg() == UCPMReg::T7 || tn->getReg() == UCPMReg::T7)
         {llvmerror(&@1, "Incorrect IFALU CompSel1 inst! Tm/Tn should not be T7!");clear();YYABORT;}*/
         
      //flagsort =  (flags[GF] << 5) | (flags[AF] << 4) | (flags[NF] << 3) | (~flags[UF] << 2) | (flags[BF] << 1) | (flags[SF]) ;
      flagsort =  (flags[AF] << 3) | (~flags[UF] << 2) | (flags[BF] << 1) | (flags[SF]) ;
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUCompSel1ToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUCompSel1ToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUCompSel1ToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUCompSel1ToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUCompSel1ToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUCompSel1ToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IFALUCompSel1ToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    default:
       llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }
}
| ialuCompSel2clause ASSIGNTO ifaludestTol {
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_CompSel2 inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_CompSel2 inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_CompSel2 inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx	
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_CompSel2 inst! _IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	      
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_CompSel2 inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_CompSel2 inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_CompSel2 inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
      if(tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_CompSel2 inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu
      if(tk->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_CompSel2 inst! Tl should be T0-T5!");clear();YYABORT;}//niuxu	 
      if (isIALUDoubleDest)
      {
	if (tl->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IFALU_CompSel2 inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }	  
      
/*           //ducx,20171205
      if(tp->getReg() == UCPMReg::T6 && tk->getReg() != UCPMReg::T7)
         llvmerror(&@1, "T6 must be followed by T7!");
      if(tp->getReg() == UCPMReg::T7 && tk->getReg() != UCPMReg::T6)
         llvmerror(&@1, "T7 must be followed by T6!");         
      if( (tp->getReg() <= UCPMReg::T5 && tp->getReg() >= UCPMReg::T0) && (tk->getReg() == UCPMReg::T6 || tk->getReg() == UCPMReg::T7) )
         llvmerror(&@1, "Tl must be T0-T5!");

      //ducx,20171206
      if(tm->getReg() == UCPMReg::T7 || tn->getReg() == UCPMReg::T7)
         llvmerror(&@1, "Tm/Tn should not be T7!");*/
         
      //flagsort =  (flags[GF] << 5) | (flags[AF] << 4) | (flags[NF] << 3) | (~flags[UF] << 2) | (flags[BF] << 1) | (flags[SF]) ;
      flagsort =  (flags[AF] << 3) | (flags[LF] << 2) | (flags[BF] << 1) | (flags[SF]) ;
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUCompSel2ToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUCompSel2ToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUCompSel2ToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUCompSel2ToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUCompSel2ToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUCompSel2ToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tl));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IFALUCompSel2ToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    default:
       llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }
}
| ialuSelclause ASSIGNTO ifaludestTol {
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_Sel0 inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_Sel0 inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_Sel0 inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx	
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Sel0 inst! _IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	      
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Sel0 inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Sel0 inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
      if (isIALUDoubleDest)
      {
	if (tk->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IFALU_Sel0 inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }	      
      
      flagsort =  (flags[PF] << 6) | (~flags[UF] << 5) | (flags[BF] << 4) | (flags[SF] << 3) | (flags[TF] << 2) |(flags[FF] << 1) | flags[LF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUSelToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUSelToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUSelToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUSelToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUSelToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUSelToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IFALUSelToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    default:
       llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }
}
| ialuSel1clause ASSIGNTO ifaludestTol {
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_Sel1 inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_Sel1 inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_Sel1 inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Sel1 inst! _IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	      
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Sel1 inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Sel1 inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Sel1 inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Sel1 inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu	 
      if (isIALUDoubleDest)
      {
	if (tk->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IFALU_Sel1 inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }	      
      
/*      //ducx,20171206
      if(tm->getReg() == UCPMReg::T6 || tn->getReg() == UCPMReg::T6)
         {llvmerror(&@1, "Incorrect IFALU Sel1 inst! Tm/Tn should not be T6!");clear();YYABORT;}*/
         
      flagsort =  (flags[NF] << 6) | (~flags[UF] << 5) | (flags[BF] << 4) | (flags[SF] << 3) | (flags[TF] << 2) |(flags[FF] << 1) | flags[CIF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUSel1ToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUSel1ToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUSel1ToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUSel1ToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUSel1ToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUSel1ToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IFALUSel1ToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    default:
       llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }
}
| ialuConjclause ASSIGNTO ifaludestTol {
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_Conj inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_Conj inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_Conj inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx	
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Conj inst! _IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	      
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Conj inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Conj inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu
      if (isIALUDoubleDest)
      {
	if (tn->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IFALU_Conj inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }	      
      
      flagsort = (flags[BF] << 3) | (flags[SF] << 2) | (flags[TF] << 1) |(flags[FF] << 0) ;
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUConjToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUConjToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUConjToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUConjToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUConjToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUConjToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IFALUConjToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    default:
       llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }
}
| ialuFindclause ASSIGNTO ifaludestTol {
      llvm::UCPM::is_ifalu = true;
      llvm::UCPM::is_ialu = false;
      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_Find inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_Find inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_Find inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx	
	    else if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Find inst! _IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;	      
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Find inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Find inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Find inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
      if (isIALUDoubleDest)
      {
	if (tp->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IFALU_Find inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }	      
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUFindToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUFindToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUFindToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
     
      
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUFindToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUFindToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUFindToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ialu
      ADDOPERAND(Opc, UCPM::IFALUFindToIALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
      
    default:
      llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }
}
| falucomclause ASSIGNTO  ifaludestTol {

      if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }      
      
        flagsort = (~flags[UF] << 4) | (flags[BF] << 3) |(flags[SF] << 2) | (flags[TF] << 1) | (flags[FF] << 0);
	f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        
  switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUCOMToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUCOMToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUCOMToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUCOMToToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUCOMToToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUCOMToToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ifalu
      ADDOPERAND(Opc, UCPM::IFALUCOMToIFALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      break;
      
    default:
       llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }
}
| setCGInstr{
            
          flagsort = (flags[ONF]);
          f = OPERAND(Imm, flagsort, FlagS, FlagE);	
	  flags.reset();
	   
	    ADDOPERAND(Opc, UCPM::IFALUSetCG, @$.S, @$.E);
	    Operands.push_back(nullptr);
	    condpos = Operands.size();
	    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));  
    
};

ifalusetcondInstr: ifalucond{   
	    isSetCond = true;
	    ADDOPERAND(Opc, UCPM::IFALUSetCond, @$.S, @$.E);
	    Operands.push_back(nullptr);
	    condpos = Operands.size();
	    if (imm == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
	    if (imm1 == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));   
	  };
ifalucond: IMMSYM DOT IMM5 ASSIGNTO IFALU DOT SETCOND LBRACKET IMM5 RBRACKET 
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $9, @9.S, @9.E);};   
	  
ifaluurytran: tranclause  ASSIGNTO ifaludestTol {

      /*if(unit3 != NULL)
      {
	if(unit3->getReg() == UCPMReg::IALUIMAC)//IMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	  } 
	}
	else if(unit3->getReg() == UCPMReg::IALUIFMAC)//IFMAC
	{
	  if(ut->getReg() == UCPMReg::T7)//xorreg
	  {
	    unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	    ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	  }
	}
      }*/
      
      if(unit3 != NULL)//niuxx
      {
	switch(unit3->getReg())
	{
	  case UCPMReg::IALUIMAC : 
	    if(ut->getReg() == UCPMReg::T6)
	      {llvmerror(&@3, "Incorrect IFALU_Single inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T2, @3.S, @3.E);
	    }
	  break;  
	  case UCPMReg::IALUIFMAC :
	    if(ut->getReg() == UCPMReg::T6)
	     {llvmerror(&@3, "Incorrect IFALU_Single inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu
	    else if(ut->getReg() == UCPMReg::T7)//xorreg
	    {
	      unit3 = OPERAND(Reg, UCPMReg::IALUIFMACxor, @1.S, @1.E);
	      ut = OPERAND(Reg, UCPMReg::T6, @3.S, @3.E);
	    }
	  break;
	  case UCPMReg::IALUBIU0 :
	  case UCPMReg::IALUBIU1 :
	  case UCPMReg::IALUBIU2 :
	    if(ut->getReg() > UCPMReg::T3)
	      {llvmerror(&@3, "Incorrect IFALU_Single inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	  break;  
	  //case UCPMReg::_IALUIALU :   //IALU->IALU 
	    //if (isIALUDoubleDest)
	      //{llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx
	  //case UCPMReg::IALUIFALU :   //IALU->IFALU
	  case UCPMReg::_IFALUIFALU :	//IFALU->IFALU 
	    if (isIALUDoubleDest)
	      {llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;}//niuxx	  
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Single inst! _IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	  case UCPMReg::IALUIALU :    //IFALU->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFALU_Single inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
            
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Single inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
      if (isIALUDoubleDest)
      {
	if (tn->getReg() > UCPMReg::T5)
	  {llvmerror(&@3, "Incorrect IFALU_Single inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      }	      
      
        flagsort = (flags[P2F] << 2) | (~flags[UF] << 1) | (flags[FLAGF] << 0);

	f = OPERAND(Imm, flagsort, FlagS, FlagE);
	

	
	
	flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
	sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	flagsort = flags[SHIFTF];
	dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	
        flags.reset();
        switch ($3) {
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFALUTRANToSHU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFALUTRANToMACC, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 2://to biu
      ADDOPERAND(Opc, UCPM::IFALUTRANToBIU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFALUTRANToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFALUTRANToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;
      
    case 5://to m[dis(shift)]
      ADDOPERAND(Opc, UCPM::IFALUTRANToMDis, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      if(isIALUDoubleDest)
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
	ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E); 
      break;   
      
    case 6://to ifalu
      ADDOPERAND(Opc, UCPM::IFALUTRANToIFALU, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      break;
      
    default:
       llvmerror(&@3, "invalid IFALU dest!");clear();YYABORT;
      //break;
  }
} 
| tranclause2{
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFALU_Single inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
	
        flagsort = (~flags[UF] << 1);
	f = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	sia = OPERAND(Imm, 0, FlagS, FlagE);
	
        flags.reset();

      ADDOPERAND(Opc, UCPM::IFALUTRANToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      ADDOPERAND(Reg, UCPMReg::IALU_ADDITIONALDEST_NULL, @$.S, @$.E);  
   
};
      



tranclause:  ifItoSclause  {opc = OPERAND(Reg, UCPMReg::IntToSingle, @$.S, @$.E);}  |
             ifStoIclause {opc = OPERAND(Reg, UCPMReg::SingleToInt, @$.S, @$.E);} |
             ifDtoSclause  {opc = OPERAND(Reg, UCPMReg::DouToSingle, @$.S, @$.E);}  |
             ifStoDclause {opc = OPERAND(Reg, UCPMReg::SingleToDou, @$.S, @$.E);} ;
ifItoSclause: SINGLE t _flag P2 flag_ {flags.set(P2F);} | SINGLE t _flag P2 flag_ _flag U flag_{flags.set(P2F);flags.set(UF);};
ifStoIclause: INT t  _flag P2 flag_ {flags.set(P2F);} | INT t _flag P2 flag_ _flag U flag_{flags.set(P2F);flags.set(UF);};
ifDtoSclause: SINGLE t  _flag D flag_  _flag ialuflags flag_ | SINGLE t  _flag D flag_;
ifStoDclause: DOUBLE t _flag S flag_ _flag ialuflags flag_ | DOUBLE t _flag S flag_;

tranclause2: ifItoSclause2  {opc = OPERAND(Reg, UCPMReg::IntToSingle, @$.S, @$.E);}  |
             ifStoIclause2 {opc = OPERAND(Reg, UCPMReg::SingleToInt, @$.S, @$.E);} ;
ifItoSclause2: SINGLE t _flag P1 flag_ {flags.set(P1F);} | SINGLE t _flag P1 flag_ _flag U flag_ {flags.set(P1F);flags.set(UF);};
ifStoIclause2: INT t _flag P1 flag_ {flags.set(P1F);} | INT t _flag P1 flag_ _flag U flag_ {flags.set(P1F);flags.set(UF);};

falucomclause: ifm_FEQUclause {opc = OPERAND(Reg, UCPMReg::m_FEQU, @$.S, @$.E);} |
                ifm_FNEQclause {opc = OPERAND(Reg, UCPMReg::m_FNEQ, @$.S, @$.E);} |
                ifm_FSTclause  {opc = OPERAND(Reg, UCPMReg::m_FST, @$.S, @$.E);}  |
                ifm_FMAXclause {opc = OPERAND(Reg, UCPMReg::m_FMAX, @$.S, @$.E);} |
                ifm_FMINclause {opc = OPERAND(Reg, UCPMReg::m_FMIN, @$.S, @$.E);} |
                ifm_FNSTclause {opc = OPERAND(Reg, UCPMReg::m_FNST, @$.S, @$.E);} ;
ifm_FEQUclause: t EQU t _flag FLOAT flag_;
ifm_FNEQclause: t NEQ t _flag FLOAT flag_;
ifm_FSTclause: t ST t _flag FLOAT flag_;
ifm_FNSTclause: t NST t _flag FLOAT flag_;
ifm_FMAXclause: maxexp _flag FLOAT flag_ ;
ifm_FMINclause: minexp _flag FLOAT flag_ ;         
maxexp: MAX _flag dupara flag_;
minexp: MIN _flag dupara flag_;                
 

// end ifalu --------------------------------------------------

// start imac --------------------------------------------------
imacslot: IMAC DOT error { llvmerror(&@1, "Incorrect IMAC inst."); clear();YYABORT;} ;

imacslot: IMAC DOT imacinst 
|
imacsetcond {	
  isSetCond = true;
  ADDOPERAND(Opc, UCPM::IMACSetCond, @$.S, @$.E);
  Operands.push_back(nullptr);
  condpos = Operands.size();
  if (imm == NULL)
    ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
  else
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
  if (imm1 == NULL)
    ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
  else
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));   
};
imacinst:
//ducx IMAC Turbo
// imacturboclause ASSIGNTO imacdest {
//       flagsort = flags[HF];
//       f = OPERAND(Imm, flagsort, FlagS, FlagE); 
// 
//       
//   switch ($3){
//     case 0://to shu
//       ADDOPERAND(Opc, UCPM::IMACTurboToSHU, @$.S, @$.E); 
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
//       Operands.push_back(nullptr);
//       condpos = Operands.size();
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
//       goto imacturboBIU_add;
//       break;
// 
//     case 1://to macc
//       ADDOPERAND(Opc, UCPM::IMACTurboToMACC, @$.S, @$.E); 
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
//       Operands.push_back(nullptr);
//       condpos = Operands.size();     
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
//       goto imacturboBIU_add;
//       break;
//     case 3://to m[t]
//       ADDOPERAND(Opc, UCPM::IMACTurboToM, @$.S, @$.E);
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
//       Operands.push_back(nullptr);
//       condpos = Operands.size();
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
//       goto imacturboBIU_add;
//       break;
//          
//     case 4://to m[s++/i++/a++]
//       flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
//       sia = OPERAND(Imm, flagsort, FlagS, FlagE);
//       flags.reset();
//       ADDOPERAND(Opc, UCPM::IMACTurboToMSIA, @$.S, @$.E); 
//       Operands.push_back(nullptr);
//       condpos = Operands.size();
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia)); 
//       goto imacturboBIU_add;
//       break;
//     case 5://to m[dis{shift}]
//       flagsort = flags[SHIFTF];
//       dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
//       flags.reset();
//       ADDOPERAND(Opc, UCPM::IMACTurboToMDis, @$.S, @$.E);         
//       Operands.push_back(nullptr);
//       condpos = Operands.size();
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis)); 
//       goto imacturboBIU_add;
//       break;
//       
//     case 6://to biu0  
//       ADDOPERAND(Opc, UCPM::IMACTurboToBIU0, @$.S, @$.E); goto imacturboBIU;  
//     case 7://to biu1  
//       ADDOPERAND(Opc, UCPM::IMACTurboToBIU1, @$.S, @$.E); goto imacturboBIU;      
//     case 8://to biu2  
//       ADDOPERAND(Opc, UCPM::IMACTurboToBIU2, @$.S, @$.E); goto imacturboBIU;  
//       
//     case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
//       ADDOPERAND(Opc, UCPM::IMACTurboToBIU2, @$.S, @$.E);
//       if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
//           ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
//       else if(imac_additional_dest >= 17 && imac_additional_dest <= 20)// _IMAC.T1/T2/T4/T5
//           ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
//       else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
// 	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
//       Operands.push_back(nullptr);
//       condpos = Operands.size();
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
//       goto imacturboBIU_add;
//       break;
//       
// imacturboBIU:  
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
//       Operands.push_back(nullptr);
//       condpos = Operands.size();
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
// imacturboBIU_add:      
//       //deal with additional dest
//       switch (imac_additional_dest) {
//         case 0:
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
//           break;        
//         case 1: //_IMAC.T0 AND imacdest
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
//           break;
//         case 2://_IMAC.T1 AND imacdest
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
//           break;
//         case 3://_IMAC.T2 AND imacdest
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
//           break;        
//         case 4://_IMAC.T3 AND imacdest
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
//           break;        
//         case 5://_IMAC.T4 AND imacdest
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
//           break; 
//         case 6://_IMAC.T5 AND imacdest
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
//           break;
//         case 7:// _IMAC.T0 AND MR
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
//           break;
//         case 8:// _IMAC.T1 AND MR
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
//           break;
//         case 9:// _IMAC.T2 AND MR
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
//           break;
//         case 10:// _IMAC.T3 AND MR
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
//           break;
//         case 11:// _IMAC.T4 AND MR
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
//           break;
//         case 12:// _IMAC.T5 AND MR
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
//           break;
//         case 13://_IMAC.MR AND imacdest
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
//           break; 
//         case 14://_IMAC.T0
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
//           break; 
//         case 15://_IMAC.T3
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
//           break; 
//         case 16://_IMAC.MR
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
//           break; 
//         case 17://_IMAC.T1
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
//           break; 
//         case 18://_IMAC.T2
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
//           break; 
//         case 19://_IMAC.T4
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
//           break; 
//         case 20://_IMAC.T5
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
//           break; 
//         default:
//           llvmerror(&@3, "imac additional dest error!"); clear();YYABORT;
//           break;
//       }
//       break;
//       
//     default:
//       llvmerror(&@3, "imac turbo dest error!"); clear();YYABORT;
//       break;      
//   }
//       
//       flags.reset();
// 
// }//end IMAC Turbo
// | //ducx IMAC Turbo1
imacturbo1clause ASSIGNTO imacdest {
      flagsort = (flags[AF] << 1 ) | flags[HF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE); 

      
  switch ($3){
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IMACTurbo1ToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      goto imacturbo1BIU_add;
      break;

    case 1://to macc
      ADDOPERAND(Opc, UCPM::IMACTurbo1ToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();     
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      goto imacturbo1BIU_add;
      break;
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IMACTurbo1ToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      goto imacturbo1BIU_add;
      break;
         
    case 4://to m[s++/i++/a++]
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();
      ADDOPERAND(Opc, UCPM::IMACTurbo1ToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia)); 
      goto imacturbo1BIU_add;
      break;
    case 5://to m[dis{shift}]
      flagsort = flags[SHIFTF];
      dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
      flags.reset();
      ADDOPERAND(Opc, UCPM::IMACTurbo1ToMDis, @$.S, @$.E);         
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis)); 
      goto imacturbo1BIU_add;
      break;
      
    case 6://to biu0  
      ADDOPERAND(Opc, UCPM::IMACTurbo1ToBIU0, @$.S, @$.E); goto imacturbo1BIU;  
    case 7://to biu1  
      ADDOPERAND(Opc, UCPM::IMACTurbo1ToBIU1, @$.S, @$.E); goto imacturbo1BIU;      
    case 8://to biu2  
      ADDOPERAND(Opc, UCPM::IMACTurbo1ToBIU2, @$.S, @$.E); goto imacturbo1BIU;  
      
    case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      ADDOPERAND(Opc, UCPM::IMACTurbo1ToBIU2, @$.S, @$.E);
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      goto imacturbo1BIU_add;
      break;
      
imacturbo1BIU:  
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
imacturbo1BIU_add:      
      //deal with additional dest
      switch (imac_additional_dest) {
        case 0:
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;        
        case 1: //_IMAC.T0 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@3, "imac additional dest error!"); clear();YYABORT;
          break;
      }
      break;
      
    default:
      llvmerror(&@3, "imac turbo1 dest error!"); clear();YYABORT;
      break;      
  }
      
      flags.reset();

}//end IMAC Turbo1
| //ducx IMAC Turbo2
imacturbo2clause ASSIGNTO imacdest {
      flagsort = flags[AF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE); 

      
  switch ($3){
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IMACTurbo2ToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      goto imacturbo2BIU_add;
      break;

    case 1://to macc
      ADDOPERAND(Opc, UCPM::IMACTurbo2ToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();     
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      goto imacturbo2BIU_add;
      break;
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IMACTurbo2ToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      goto imacturbo2BIU_add;
      break;
         
    case 4://to m[s++/i++/a++]
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();
      ADDOPERAND(Opc, UCPM::IMACTurbo2ToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia)); 
      goto imacturbo2BIU_add;
      break;
    case 5://to m[dis{shift}]
      flagsort = flags[SHIFTF];
      dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
      flags.reset();
      ADDOPERAND(Opc, UCPM::IMACTurbo2ToMDis, @$.S, @$.E);         
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis)); 
      goto imacturbo2BIU_add;
      break;
      
    case 6://to biu0  
      ADDOPERAND(Opc, UCPM::IMACTurbo2ToBIU0, @$.S, @$.E); goto imacturbo2BIU;  
    case 7://to biu1  
      ADDOPERAND(Opc, UCPM::IMACTurbo2ToBIU1, @$.S, @$.E); goto imacturbo2BIU;      
    case 8://to biu2  
      ADDOPERAND(Opc, UCPM::IMACTurbo2ToBIU2, @$.S, @$.E); goto imacturbo2BIU;  
      
    case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      ADDOPERAND(Opc, UCPM::IMACTurbo2ToBIU2, @$.S, @$.E);
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      goto imacturbo2BIU_add;
      break;
      
imacturbo2BIU:  
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
imacturbo2BIU_add:      
      //deal with additional dest
      switch (imac_additional_dest) {
        case 0:
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;        
        case 1: //_IMAC.T0 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@3, "imac additional dest error!"); clear();YYABORT;
          break;
      }
      break;
      
    default:
      llvmerror(&@3, "imac turbo2 dest error!"); clear();YYABORT;
      break;      
  }
      
      flags.reset();

}//end IMAC Turbo2
//yangl: UCP_M, start IMAC Logic
| imaclogicclause ASSIGNTO imacdest {

      if(unit4 != NULL)//niuxx
      {
	switch(unit4->getReg())
	{
	  /*case UCPMReg::IMACIMAC :      //IMAC->_IMAC
	    //if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IMAC_Logic inst! _IMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;*/ 
	  case UCPMReg::IMACIFMAC :    //IMAC->IFMAC
	    if(ut->getReg() > UCPMReg::T5)
	     {llvmerror(&@3, "Incorrect IMAC_Logic inst! IFMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	  case UCPMReg::IMACIALU :	//IMAC->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IMAC_Logic inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu  
	  case UCPMReg::IMACIFALU :    //IMAC->IFALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IMAC_Logic inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
      
      if ($1 == 3)
      {
	if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IMAC_Logic inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu      
      }
      else 
      {
	if(tm->getReg() > UCPMReg::T5)
	  {llvmerror(&@1, "Incorrect IMAC_Logic inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
	if(tn->getReg() > UCPMReg::T5)
	  {llvmerror(&@1, "Incorrect IMAC_Logic inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu      
      }


  switch ($3){
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IMACLogicToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));    
      switch ($1) {
        case 0:   
        case 1:
        case 2:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
          break;
        case 3:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt)); //a reserved T
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's tn
          break;
        default:
          llvmerror(&@1, "imac logic clause error!"); clear();YYABORT;
          break; 
      }
      goto imaclogicBIU_add;
      break;

    case 1://to macc
      ADDOPERAND(Opc, UCPM::IMACLogicToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();     
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));    
      switch ($1) {
        case 0:   
        case 1:
        case 2:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
          break;
        case 3:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt)); //a reserved T
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's tn
          break;
        default:
          llvmerror(&@1, "imac logic clause error!"); clear();YYABORT;
          break; 
      }
      goto imaclogicBIU_add;
      break;
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IMACLogicToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));     
      switch ($1) {
        case 0:   
        case 1:
        case 2:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
          break;
        case 3:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt)); //a reserved T
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's tn
          break;
        default:
          llvmerror(&@1, "imac logic clause error!"); clear();YYABORT;
          break; 
      }
      goto imaclogicBIU_add;
      break;
         
    case 4://to m[s++/i++/a++]
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();
      ADDOPERAND(Opc, UCPM::IMACLogicToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));     
      switch ($1) {
        case 0:   
        case 1:
        case 2:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
          break;
        case 3:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt)); //a reserved T
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's tn
          break;
        default:
          llvmerror(&@1, "imac logic clause error!"); clear();YYABORT;
          break; 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia)); 
      goto imaclogicBIU_add;
      break;
    case 5://to m[dis{shift}]
      flagsort = flags[SHIFTF];
      dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
      flags.reset();
      ADDOPERAND(Opc, UCPM::IMACLogicToMDis, @$.S, @$.E);         
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      switch ($1) {
        case 0:   
        case 1:
        case 2:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
          break;
        case 3:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt)); //a reserved T
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's tn
          break;
        default:
          llvmerror(&@1, "imac logic clause error!"); clear();YYABORT;
          break; 
      }           
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis)); 
      goto imaclogicBIU_add;
      break;
      
    case 6://to biu0  
      ADDOPERAND(Opc, UCPM::IMACLogicToBIU0, @$.S, @$.E); goto imaclogicBIU;  
    case 7://to biu1  
      ADDOPERAND(Opc, UCPM::IMACLogicToBIU1, @$.S, @$.E); goto imaclogicBIU;      
    case 8://to biu2  
      ADDOPERAND(Opc, UCPM::IMACLogicToBIU2, @$.S, @$.E); goto imaclogicBIU;  
      
    case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      ADDOPERAND(Opc, UCPM::IMACLogicToBIU2, @$.S, @$.E);
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));    
      switch ($1) {
        case 0:   
        case 1:
        case 2:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
          break;
        case 3:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt)); //a reserved T
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's tn
          break;
        default:
          llvmerror(&@1, "imac logic clause error!"); clear();YYABORT;
          break; 
      }
      goto imaclogicBIU_add;
      break;
      
imaclogicBIU:  
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));    
      switch ($1) {
        case 0:   
        case 1:
        case 2:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
          break;
        case 3:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt)); //a reserved T
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's tn
          break;
        default:
          llvmerror(&@1, "imac logic clause error!"); clear();YYABORT;
          break; 
      }
imaclogicBIU_add:      
      //deal with additional dest
      switch (imac_additional_dest) {
        case 0:
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;        
        case 1: //_IMAC.T0 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@3, "imac additional dest error!"); clear();YYABORT;
          break;
      }
      break;
      
    default:
      llvmerror(&@3, "imac logic dest error!"); clear();YYABORT;
      break;      
  }
}//end IMAC Logic
|
//yangl: UCP_M, start IMAC RWFlag
imacreadflagclause ASSIGNTO imacdest {
//original code:  28  27  26  25  24:23  22  21  20:18  17:15  14:12  11
//f in my def:    14  13  12  11  10-9   8   7   6-4    3-1            0
      if(unit4 != NULL)//niuxx
      {
	switch(unit4->getReg())
	{
	  /*case UCPMReg::IMACIMAC :      //IMAC->_IMAC
	    //if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IMAC_Logic inst! _IMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;*/ 
	  case UCPMReg::IMACIFMAC :    //IMAC->IFMAC
	    if(ut->getReg() > UCPMReg::T5)
	     {llvmerror(&@3, "Incorrect IMAC_ReadFlag inst! IFMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	  case UCPMReg::IMACIALU :	//IMAC->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IMAC_ReadFlag inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu  
	  case UCPMReg::IMACIFALU :    //IMAC->IFALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IMAC_ReadFlag inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  


  flagsort = (flags[NF] << 13) | (flags[CF] << 12) | (flags[VF] << 11) | (flags[MCF] << 8) | (flags[MVF] << 7) 
                              | (0x1 << 6) | (0x1 << 5) | (0x1 << 4) | (flags[TF] << 3) | (flags[LSF] << 2) 
                              | (flags[ERASEF]);  
  
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
  sia = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = flags[SHIFTF];
  dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
  
  flags.reset();
  
  switch ($3){
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IMACFlagToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E); 
      goto imacrwflagBIU_add;
      break;
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IMACFlagToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();     
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      goto imacrwflagBIU_add;
      break;
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IMACFlagToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      goto imacrwflagBIU_add;
      break;     
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IMACFlagToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      goto imacrwflagBIU_add;
      break;
    case 5://to m[dis{shift}]  
      ADDOPERAND(Opc, UCPM::IMACFlagToMDis, @$.S, @$.E);         
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      goto imacrwflagBIU_add;
      break;
      
    case 6://to biu0  
      ADDOPERAND(Opc, UCPM::IMACFlagToBIU0, @$.S, @$.E); goto imacrwflagBIU;  
    case 7://to biu1  
      ADDOPERAND(Opc, UCPM::IMACFlagToBIU1, @$.S, @$.E); goto imacrwflagBIU;      
    case 8://to biu2  
      ADDOPERAND(Opc, UCPM::IMACFlagToBIU2, @$.S, @$.E); goto imacrwflagBIU;  
  
  
  case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      ADDOPERAND(Opc, UCPM::IMACFlagToBIU2, @$.S, @$.E);
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      goto imacrwflagBIU_add;
      break;
      
imacrwflagBIU:      

      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      
imacrwflagBIU_add:
//deal with additional dest
  switch (imac_additional_dest) {
        case 0:
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;        
        case 1: //_IMAC.T0 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@3, "imac additional dest error!"); clear();YYABORT;
          break;
      }
      break;
      
    default:
      llvmerror(&@3, "imac dest error!"); clear();YYABORT;
      break;      
  }
}
|
imacwriteflagclause {
//original code:  28  27  26  25  24:23  22  21  20:18  17:15  14:12  11
//f in my def:    14  13  12  11  10-9   8   7   6-4    3-1            0
   if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IMAC_WriteFlag inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu

  flagsort = (flags[NF] << 13) | (flags[CF] << 12) | (flags[VF] << 11) | (flags[MCF] << 8) | (flags[MVF] << 7) 
                              | (0x1 << 6) | (0x1 << 5) | (0x1 << 4) | (flags[TF] << 3) | (flags[LSF] << 2) 
                              | (flags[ERASEF]);  
  flagsort |= (1 << 9);
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flags.reset();

  ADDOPERAND(Opc, UCPM::IMACFlagToSHU, @$.S, @$.E); 
  //Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
  ADDOPERAND(Reg, UCPMReg::IALUBIU0, @$.S, @$.E);
  //Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
  ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
  Operands.push_back(nullptr);
  condpos = Operands.size();
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//it's tp in imac r/w flag instruction
  ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
}//end IMAC RWFlag
|
//yangl: UCP_M, start IMAC RW MR
imacreadmrclause ASSIGNTO imacdest {
//original code:  28  27  26  25  24:23  22  21  20:18  17:15  14:12  11
//f in my def:    14  13  12  11  10-9   8   7   6-4    3-1            0
      if(unit4 != NULL)//niuxx
      {
	switch(unit4->getReg())
	{
	  /*case UCPMReg::IMACIMAC :      //IMAC->_IMAC
	    //if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IMAC_Logic inst! _IMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;*/ 
	  case UCPMReg::IMACIFMAC :    //IMAC->IFMAC
	    if(ut->getReg() > UCPMReg::T5)
	     {llvmerror(&@3, "Incorrect IMAC_ReadMR inst! IFMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	  case UCPMReg::IMACIALU :	//IMAC->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IMAC_ReadMR inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu  
	  case UCPMReg::IMACIFALU :    //IMAC->IFALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IMAC_ReadMR inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      } 

  flagsort = ( 1 << 14 ) | ( 1 << 11 ) | (1 << 6) | (1 << 5) | (1 << 4);  
  if(flags[BF])
    ;
  else if(flags[SF])
    flagsort |= (1 << 9);
  else if(flags[WF])
    flagsort |= (1 << 10);
  else
    {llvmerror(&@1, "imac readmr B/S/W flag error!"); clear();YYABORT;}
    
  if(flags[HF])
    flagsort |= (1 << 1);
  else if(flags[LF])
    ;
  else if(flags[OF])
    flagsort |= (1 << 2);
  
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  switch ($3){
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IMACFlagToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      goto imacreadMRBIU_add;
      break;
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IMACFlagToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();     
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      goto imacreadMRBIU_add;
      break;
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IMACFlagToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      goto imacreadMRBIU_add;
      break;     
    case 4://to m[s++/i++/a++]
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);
  
      ADDOPERAND(Opc, UCPM::IMACFlagToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      goto imacreadMRBIU_add;
      break;
    case 5://to m[dis{shift}]  
      flagsort = flags[SHIFTF];
      dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
    
      ADDOPERAND(Opc, UCPM::IMACFlagToMDis, @$.S, @$.E);         
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      goto imacreadMRBIU_add;
      break;
      
    case 6://to biu0  
      ADDOPERAND(Opc, UCPM::IMACFlagToBIU0, @$.S, @$.E); goto imacreadMRBIU;  
    case 7://to biu1  
      ADDOPERAND(Opc, UCPM::IMACFlagToBIU1, @$.S, @$.E); goto imacreadMRBIU;      
    case 8://to biu2  
      ADDOPERAND(Opc, UCPM::IMACFlagToBIU2, @$.S, @$.E); goto imacreadMRBIU;  
  
   case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      ADDOPERAND(Opc, UCPM::IMACFlagToBIU2, @$.S, @$.E);
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      goto imacreadMRBIU_add;
      break;
      
imacreadMRBIU:      
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      
imacreadMRBIU_add:    
    //deal with additional dest
      switch (imac_additional_dest) {
        case 0:
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;        
        case 1: //_IMAC.T0 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@3, "imac additional dest error!"); clear();YYABORT;
          break;
      }
      break;
      
    default:
      llvmerror(&@3, "imac dest error!"); clear();YYABORT;
      break;      
  }
  flags.reset();
}
|
imacwritemrclause {
//original code:  28  27  26  25  24:23  22  21  20:18  17:15  14:12  11
//f in my def:    14  13  12  11  10-9   8   7   6-4    3-1            0
  if(tm->getReg() > UCPMReg::T5)
    {llvmerror(&@1, "Incorrect IMAC_SetMR inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu

  flagsort = ( 1 << 14 ) | (0x1 << 6) | (0x1 << 5) | (0x1 << 4);  
  if(flags[BF])
    ;
  else if(flags[SF])
    flagsort |= (1 << 9);
  else if(flags[WF])
    flagsort |= (1 << 10);
  else
    {llvmerror(&@1, "imac setMR B/S/W flag error!"); clear();YYABORT;}
    
  if(flags[HF])
    flagsort |= (1 << 1);
  else if(flags[LF])
    ;
  else if(flags[OF])
    flagsort |= (1 << 2);    
    
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flags.reset();

  ADDOPERAND(Opc, UCPM::IMACFlagToSHU, @$.S, @$.E); 
  //Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
  ADDOPERAND(Reg, UCPMReg::IALUBIU0, @$.S, @$.E);
  //Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
  ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
  Operands.push_back(nullptr);
  condpos = Operands.size();
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//it's tp in imac r/w flag instruction
  ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
}//end IMAC RW MR
|
//yangl: UCP_M, start IMAC RW XOR REG
imacreadxorclause ASSIGNTO imacdest {
//original code:  28  27  26  25  24:23  22  21  20:18  17:15  14:12  11
//f in my def:    14  13  12  11  10-9   8   7   6-4    3-1            0
      if(unit4 != NULL)//niuxx
      {
	switch(unit4->getReg())
	{
	  /*case UCPMReg::IMACIMAC :      //IMAC->_IMAC
	    //if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IMAC_Logic inst! _IMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;*/ 
	  case UCPMReg::IMACIFMAC :    //IMAC->IFMAC
	    if(ut->getReg() > UCPMReg::T5)
	     {llvmerror(&@3, "Incorrect IMAC_ReadXOR inst! IFMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	  case UCPMReg::IMACIALU :	//IMAC->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IMAC_ReadXOR inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu  
	  case UCPMReg::IMACIFALU :    //IMAC->IFALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IMAC_ReadXOR inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      } 

  flagsort = ( 1 << 13 ) | ( 1 << 11 ) | (0x1 << 6) | (0x1 << 5);  
  
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
  sia = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = flags[SHIFTF];
  dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
  
  flags.reset();
  
  switch ($3){
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IMACFlagToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      goto imacrwXORBIU_add;
      break;
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IMACFlagToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();     
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      goto imacrwXORBIU_add;
      break;
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IMACFlagToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      goto imacrwXORBIU_add;
      break;     
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IMACFlagToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      goto imacrwXORBIU_add;
      break;
    case 5://to m[dis{shift}]  
      ADDOPERAND(Opc, UCPM::IMACFlagToMDis, @$.S, @$.E);         
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      goto imacrwXORBIU_add;
      break;
      
    case 6://to biu0  
      ADDOPERAND(Opc, UCPM::IMACFlagToBIU0, @$.S, @$.E); goto imacrwXORBIU;  
    case 7://to biu1  
      ADDOPERAND(Opc, UCPM::IMACFlagToBIU1, @$.S, @$.E); goto imacrwXORBIU;      
    case 8://to biu2  
      ADDOPERAND(Opc, UCPM::IMACFlagToBIU2, @$.S, @$.E); goto imacrwXORBIU;  
      
    case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      ADDOPERAND(Opc, UCPM::IMACFlagToBIU2, @$.S, @$.E);
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E); 
      goto imacrwXORBIU_add;
      break;
      
imacrwXORBIU:      

      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E); 
      
imacrwXORBIU_add:
      //deal with additional dest
      switch (imac_additional_dest) {
        case 0:
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;        
        case 1: //_IMAC.T0 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@3, "imac additional dest error!"); clear();YYABORT;
          break;
      }
      break;
      
    default:
      llvmerror(&@3, "imac dest error!"); clear();YYABORT;
      break;      
  }
}
|
imacwritexorclause {
//original code:  28  27  26  25  24:23  22  21  20:18  17:15  14:12  11
//f in my def:    14  13  12  11  10-9   8   7   6-4    3-1            0
  if(tm->getReg() > UCPMReg::T5)
    {llvmerror(&@1, "Incorrect IMAC_SetXOR inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
  flagsort = ( 1 << 13 ) | (0x1 << 6) | (0x1 << 5); 

  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flags.reset();

  ADDOPERAND(Opc, UCPM::IMACFlagToSHU, @$.S, @$.E); 
  //Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
  ADDOPERAND(Reg, UCPMReg::IALUBIU0, @$.S, @$.E);
  //Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
  ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
  Operands.push_back(nullptr);
  condpos = Operands.size();
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//it's tp in imac r/w flag instruction
  ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
}//end IMAC RW XOR REG
|
//yangl: UCP_M, start IMAC MulAA
imacMulAAclause ASSIGNTO imacdest {
      if (!isTpValid)//tp == 0
      {
	if(tm->getReg() < UCPMReg::T6)
	{
	  if(tn->getReg() - tm->getReg() != 1)
	    {llvmerror(&@1, "Incorrect IMAC_MulAA inst! Tm+1 is error!");clear();YYABORT;}//niuxu
	}
	else 
	  {llvmerror(&@1, "Incorrect IMAC_MulAA inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
	if(tp->getReg() < UCPMReg::T6 && tp->getReg() > UCPMReg::T0)
	{
	  if (tp->getReg() - tk->getReg() != 1)
	    {llvmerror(&@1, "Incorrect IMAC_MulAA inst! Tn-1 is error!");clear();YYABORT;}//niuxu	
	}  
	else 
	  {llvmerror(&@1, "Incorrect IMAC_MulAA inst! Tn should be T1-T5!");clear();YYABORT;}//niuxu
      }
      else if (isTpMR || isTpMR_toMR)//tp == MR
      {
	if(tm->getReg() < UCPMReg::T6)
	{
	  if(tn->getReg() - tm->getReg() != 1)
	    {llvmerror(&@1, "Incorrect IMAC_MulAA inst! Tm+1 is error!");clear();YYABORT;}//niuxu
	}
	else 
	  {llvmerror(&@1, "Incorrect IMAC_MulAA inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
	if(tp->getReg() < UCPMReg::T6 && tp->getReg() > UCPMReg::T0)
	{
	  if (tp->getReg() - tk->getReg() != 1)
	    {llvmerror(&@1, "Incorrect IMAC_MulAA inst! Tn-1 is error!");clear();YYABORT;}//niuxu	
	}  
	else 
	  {llvmerror(&@1, "Incorrect IMAC_MulAA inst! Tn should be T1-T5!");clear();YYABORT;}//niuxu
      }
      else
      {
	if(tm->getReg() > UCPMReg::T5)
	  {llvmerror(&@1, "Incorrect IMAC_MulAA inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu
	if(tn->getReg() < UCPMReg::T6)
	{
	  if (tp->getReg() - tn->getReg() != 1)
	     {llvmerror(&@1, "Incorrect IMAC_MulAA inst! Tm+1 is error!");clear();YYABORT;}//niuxu
	}
	else 
	  {llvmerror(&@1, "Incorrect IMAC_MulAA inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
	 
	if(tk->getReg() < UCPMReg::T6 && tk->getReg() > UCPMReg::T0)
	{
	  if(tk->getReg() - tl->getReg() != 1)
	    {llvmerror(&@1, "Incorrect IMAC_MulAA inst! Tn-1 is error!");clear();YYABORT;}//niuxu		
	}
	else
	  {llvmerror(&@1, "Incorrect IMAC_MulAA inst! Tn should be T1-T5!");clear();YYABORT;}//niuxu
     } 
     
     if (unit4 != NULL)
     {
	switch (unit4->getReg())
	{
	  case  UCPMReg::IMACIALU:
	    if (ut->getReg() > UCPMReg::T5)
	       {llvmerror(&@3, "Incorrect IMAC_MulAA inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	  case UCPMReg::IMACIFALU:
	    if (ut->getReg() > UCPMReg::T5)
	       {llvmerror(&@3, "Incorrect IMAC_MulAA inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;     
	  case UCPMReg::IMACIFMAC:
	    if (ut->getReg() > UCPMReg::T5)
	       {llvmerror(&@3, "Incorrect IMAC_MulAA inst! IFMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;     
	}
     }

  flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (flags[FF] << 2) | (flags[PF] << 1);
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    {llvmerror(&@1, "imac MulAA ShiftMode0/1/2/3 flag error!");clear();YYABORT;}
    //flagsort = 0x2;
  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
  sia = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = flags[SHIFTF];
  dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
  
  if(flags[BF])
    ImacMuAA_BSflag = 0;
  else if(flags[SF])
    ImacMuAA_BSflag = 1;
  else
    {llvmerror(&@1, "imac MulAA B/S flag error!"); clear();YYABORT;}
  flags.reset();  
  
  switch ($3){
    case 0://to shu
      ADDOPERAND(Opc, UCPM::MulAAToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAA
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imacmulAABIU_add;
      break;

    case 1://to macc
      ADDOPERAND(Opc, UCPM::MulAAToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();     
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAA
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift)); 
      goto imacmulAABIU_add;
      break;
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::MulAAToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAA
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imacmulAABIU_add;
      break;
         
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::MulAAToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAA
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      goto imacmulAABIU_add;
      break;
    case 5://to m[dis{shift}]
      ADDOPERAND(Opc, UCPM::MulAAToMDis, @$.S, @$.E);         
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAA
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      goto imacmulAABIU_add;
      break;
      
    case 6://to biu0  
      ADDOPERAND(Opc, UCPM::MulAAToBIU0, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAA
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imacmulAABIU_add;
      break;
    case 7://to biu1  
      ADDOPERAND(Opc, UCPM::MulAAToBIU1, @$.S, @$.E);  
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAA
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imacmulAABIU_add;
      break;
    case 8://to biu2  
      ADDOPERAND(Opc, UCPM::MulAAToBIU2, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAA
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imacmulAABIU_add;
      break;
    case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      ADDOPERAND(Opc, UCPM::MulAAToBIU2, @$.S, @$.E);//common with biu2
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20 && isTpMR_toMR)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20 && !isTpMR_toMR)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAA
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imacmulAABIU_add;
      break;
     

imacmulAABIU_add:      

      switch (imac_additional_dest) {
        case 0:
          if(isTpMR_toMR)
            ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          else
            ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;  
          break;        
        case 1: //_IMAC.T0 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@3, "imac additional dest error!"); clear();YYABORT;
          break;
      }
      
      //}  
      ADDOPERAND(Imm, ImacMulAA_addsub, @$.S, @$.E);
      ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);  
      break;
      
    default:
      llvmerror(&@3, "imac dest error!"); clear();YYABORT;
      break;      
  }
}
|
imacMulAAclause_inside{

    if(tm->getReg() < UCPMReg::T6)
    {
	if(tn->getReg() - tm->getReg() != 1)
	  {llvmerror(&@1, "Incorrect IMAC_MulAA inst! Tm+1 is error!");clear();YYABORT;}//niuxu
    }
    else 
	{llvmerror(&@1, "Incorrect IMAC_MulAA inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
	
    if(tp->getReg() < UCPMReg::T6 && tp->getReg() > UCPMReg::T0)
    {
	if (tp->getReg() - tk->getReg() != 1)
	  {llvmerror(&@1, "Incorrect IMAC_MulAA inst! Tn-1 is error!");clear();YYABORT;}//niuxu	
    }  
    else 
	{llvmerror(&@1, "Incorrect IMAC_MulAA inst! Tn should be T1-T5!");clear();YYABORT;}//niuxu
      
  flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (flags[FF] << 2) | (flags[PF] << 1);
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    {llvmerror(&@1, "imac MulAA ShiftMode0/1/2/3 flag error!");clear();YYABORT;}
    //flagsort = 0x2;
  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
  sia = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = flags[SHIFTF];
  dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
  
  if(flags[BF])
    ImacMuAA_BSflag = 0;
  else if(flags[SF])
    ImacMuAA_BSflag = 1;
  else
    {llvmerror(&@1, "imac MulAA B/S flag error!"); clear();YYABORT;}
  flags.reset();  
  
  ADDOPERAND(Opc, UCPM::MulAAToBIU2, @$.S, @$.E);//common with biu2
  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
  Operands.push_back(nullptr);
  condpos = Operands.size();
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tm in MulAA
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tn in MulAA
  unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
  revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
  ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
  ADDOPERAND(Imm, ImacMulAA_addsub, @$.S, @$.E);
  ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
}//end IMAC MulAA
| //ducx 20180310
imacMulVTnclause ASSIGNTO imacdest {
  if(!isTpValid) //tp == 0
  {
      if(tm->getReg() > UCPMReg::T5)
	  {llvmerror(&@1, "Incorrect IMAC_Mul inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	  {llvmerror(&@1, "Incorrect IMAC_Mul inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu    
  }
  else if (isTpMR || isTpMR_toMR)//tp == MR
  {
      if(tm->getReg() > UCPMReg::T5)
	  {llvmerror(&@1, "Incorrect IMAC_Mul inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	  {llvmerror(&@1, "Incorrect IMAC_Mul inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu   
  }
  else
  {
      if(tm->getReg() > UCPMReg::T5)
	  {llvmerror(&@1, "Incorrect IMAC_Mul inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	  {llvmerror(&@1, "Incorrect IMAC_Mul inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tp->getReg() > UCPMReg::T5)
	  {llvmerror(&@1, "Incorrect IMAC_Mul inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu  
  }
  if (unit4 != NULL)
  {
    switch (unit4->getReg())
    {
      case  UCPMReg::IMACIALU:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IMAC_Mul inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;
      case UCPMReg::IMACIFALU:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IMAC_Mul inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;     
      case UCPMReg::IMACIFMAC:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IMAC_Mul inst! IFMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;     
    }
  }   

  flagsort = (flags[CF] << 2) | (flags[FF] << 1) | (flags[PF] << 0);
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    {llvmerror(&@1, "imac ShiftMode0/1/2/3 flag error!");clear();YYABORT;}

  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
  sia = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = flags[SHIFTF];
  dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
  
  if(flags[BF])
    ImacMuAA_BSflag = 0;
  else if(flags[SF])
    ImacMuAA_BSflag = 1;
  else
    {llvmerror(&@1, "imac B/S flag error!"); clear();YYABORT;}
  flags.reset();  
  
  switch ($3){
    case 0://to shu
      ADDOPERAND(Opc, UCPM::MulVTnToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      goto imacmulVTnBIU_add;
      break;

    case 1://to macc
      ADDOPERAND(Opc, UCPM::MulVTnToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();     
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift)); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      goto imacmulVTnBIU_add;
      break;
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::MulVTnToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      goto imacmulVTnBIU_add;
      break;
         
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::MulVTnToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      goto imacmulVTnBIU_add;
      break;
    case 5://to m[dis{shift}]
      ADDOPERAND(Opc, UCPM::MulVTnToMDis, @$.S, @$.E);         
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      goto imacmulVTnBIU_add;
      break;
      
    case 6://to biu0  
      ADDOPERAND(Opc, UCPM::MulVTnToBIU0, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      goto imacmulVTnBIU_add;
      break;
    case 7://to biu1  
      ADDOPERAND(Opc, UCPM::MulVTnToBIU1, @$.S, @$.E);  
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      goto imacmulVTnBIU_add;
      break;
    case 8://to biu2  
      ADDOPERAND(Opc, UCPM::MulVTnToBIU2, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      goto imacmulVTnBIU_add;
      break;
    case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      ADDOPERAND(Opc, UCPM::MulVTnToBIU2, @$.S, @$.E);//common with biu2
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20 && isTpMR_toMR)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20 && !isTpMR_toMR)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      goto imacmulVTnBIU_add;
      break;
     

imacmulVTnBIU_add:      

      switch (imac_additional_dest) {
        case 0:
          if(isTpMR_toMR)
            ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          else
            ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;  
          break;        
        case 1: //_IMAC.T0 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@3, "imac additional dest error!"); clear();YYABORT;
          break;
      }
      
      //}  
      ADDOPERAND(Imm, ImacMulAA_addsub, @$.S, @$.E);
      ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);  
      break;
      
    default:
      llvmerror(&@3, "imac dest error!"); clear();YYABORT;
      break;      
  }
}
|
imacMulVTnclause_inside {

  
  flagsort = (flags[CF] << 2) | (flags[FF] << 1) | (flags[PF] << 0);
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    {llvmerror(&@1, "imac ShiftMode0/1/2/3 flag error!");clear();YYABORT;}

  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
  sia = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = flags[SHIFTF];
  dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
  
  if(flags[BF])
    ImacMuAA_BSflag = 0;
  else if(flags[SF])
    ImacMuAA_BSflag = 1;
  else
    {llvmerror(&@1, "imac B/S flag error!"); clear();YYABORT;}
  flags.reset();  
  
  ADDOPERAND(Opc, UCPM::MulVTnToBIU2, @$.S, @$.E);//common with biu2
  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
  Operands.push_back(nullptr);
  condpos = Operands.size();
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
  unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
  revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
  ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
  ADDOPERAND(Imm, ImacMulAA_addsub, @$.S, @$.E);
  ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
}//end Tp+Tm*V(Tn[k])
|
CLEARMR {
  ADDOPERAND(Opc, UCPM::IMACClearMR, @$.S, @$.E);
  Operands.push_back(nullptr);
  condpos = Operands.size();
}
//yangl: UCP_M, IMAC set shift mode
| imacsetshiftclause ASSIGNTO imacshiftmodeoption {
  switch ($1) {
  case 0://t
    ADDOPERAND(Opc, UCPM::IMACSetShiftModeWithT, @$.S, @$.E);
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
    break;
  case 1://imm5
    ADDOPERAND(Opc, UCPM::IMACSetShiftModeWithImm, @$.S, @$.E);
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));   
    break;
  default:
    llvmerror(&@1, "imac setshift clause error!"); clear();YYABORT;
    break;
  }
}
| //yangl:UCP_M, IMAC triple
imactripleclause ASSIGNTO imacdest {
  if(tm->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IMAC_Triple inst! Tl should be T0-T5!");clear();YYABORT;}//niuxu
  if(tn->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IMAC_Triple inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
  if(tp->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IMAC_Triple inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
      
  if (unit4 != NULL)
  {
    switch (unit4->getReg())
    {
      case  UCPMReg::IMACIALU:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IMAC_Triple inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;
      case UCPMReg::IMACIFALU:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IMAC_Triple inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;     
      case UCPMReg::IMACIFMAC:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IMAC_Triple inst! IFMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;     
    }
  }       
         
  flagsort = (flags[ALLF] << 4);// | (flags[NOT1F] << 1) | flags[NOT2F];
  if(flags[BF])
    flagsort = flagsort | (0b00 << 2);
  else if(flags[SF])
    flagsort = flagsort | (0b01 << 2);
//  else if(flags[WF])
//    flagsort = flagsort | (0b10 << 2);
//  else // I don't know if is reasonable
//    flagsort = flagsort | (0b11 << 2);   
  else
    {llvmerror(&@1, "imac B/S flag error!");clear();YYABORT;}
  flags.reset();
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  switch ($3){
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IMACTripleToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's 'tl' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//in fact it's 'tm' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//in fact it's 'tn' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      goto imactripleBIU_add;
      break;

    case 1://to macc
      ADDOPERAND(Opc, UCPM::IMACTripleToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();     
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));   
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's 'tl' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//in fact it's 'tm' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//in fact it's 'tn' in the document   
      goto imactripleBIU_add;
      break;
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IMACTripleToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));   
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's 'tl' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//in fact it's 'tm' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//in fact it's 'tn' in the document
      goto imactripleBIU_add;
      break;        
    case 4://to m[s++/i++/a++]
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();
      ADDOPERAND(Opc, UCPM::IMACTripleToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));   
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's 'tl' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//in fact it's 'tm' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//in fact it's 'tn' in the document          
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia)); 
      goto imactripleBIU_add;
      break;
    case 5://to m[dis{shift}]
      flagsort = flags[SHIFTF];
      dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
      flags.reset();
      ADDOPERAND(Opc, UCPM::IMACTripleToMDis, @$.S, @$.E);         
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));  
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's 'tl' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//in fact it's 'tm' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//in fact it's 'tn' in the document             
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis)); 
      goto imactripleBIU_add;
      break;     
    case 6://to biu0  
      ADDOPERAND(Opc, UCPM::IMACTripleToBIU0, @$.S, @$.E); goto imactripleBIU;  
    case 7://to biu1  
      ADDOPERAND(Opc, UCPM::IMACTripleToBIU1, @$.S, @$.E); goto imactripleBIU;      
    case 8://to biu2  
      ADDOPERAND(Opc, UCPM::IMACTripleToBIU2, @$.S, @$.E); goto imactripleBIU;  
  
    case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      ADDOPERAND(Opc, UCPM::IMACTripleToBIU2, @$.S, @$.E);
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));   
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's 'tl' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//in fact it's 'tm' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//in fact it's 'tn' in the document       
      goto imactripleBIU_add;
      break;    
      
imactripleBIU:      
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));   
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's 'tl' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//in fact it's 'tm' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//in fact it's 'tn' in the document       

imactripleBIU_add:
      //deal with additional dest
      switch (imac_additional_dest) {
        case 0:
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;        
        case 1: //_IMAC.T0 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@3, "imac additional dest error!"); clear();YYABORT;
          break;
      }
      break;  
    default:
      llvmerror(&@3, "imac dest error!"); clear();YYABORT;
      break;      
  }
}//end IMAC triple
//huhh: imac: tm +- tm*tn
| imacmaclause ASSIGNTO imacdest {
  if(tm->getReg() > UCPMReg::T5)
    {llvmerror(&@1, "Incorrect IMAC_Mul inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu
  if(tn->getReg() > UCPMReg::T5)
    {llvmerror(&@1, "Incorrect IMAC_Mul inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
  if(tp->getReg() > UCPMReg::T5)
    {llvmerror(&@1, "Incorrect IMAC_Mul inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu

  if (unit4 != NULL)
  {
    switch (unit4->getReg())
    {
      case  UCPMReg::IMACIALU:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IMAC_Mul inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;
      case UCPMReg::IMACIFALU:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IMAC_Mul inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;     
      case UCPMReg::IMACIFMAC:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IMAC_Mul inst! IFMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;     
    }
  }   
  
  flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1);
  //C but not have CR
  if(flags[CF])
  {
     flagsort |= 0x1;
     flagsort &= 0b110111;
  }
  //SEND flag
  if(flags[SENDF])
    flagsort |= 0x1;
    
    //ducx:for abs mul
  if(isIMACABS)
    flagsort &= 0b110111;
    
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    {llvmerror(&@1, "imac ShiftMode0/1/2/3 flag error!");clear();YYABORT;}
    //flagsort = 0x2;
  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  //flags.reset();
  
  switch ($3){
    case 0://to shu  
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToSHU, @$.S, @$.E);//?????
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToSHU, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToSHU, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToSHU, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imac_tripleBIU_add;
      break;
      
    case 1://to macc
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToMACC, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToMACC, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToMACC, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToMACC, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imac_tripleBIU_add;
      break;
      
    case 3://to m[t]
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToM, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToM, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToM, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToM, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imac_tripleBIU_add;
      break;

    case 4://to m[s++/i++/a++]  
     flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
     sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToMSIA, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToMSIA, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToMSIA, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToMSIA, @$.S, @$.E); 
      }
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia)); 
      goto imac_tripleBIU_add;
      break;
      
    case 5://to m[dis{shift}]
    flagsort = flags[SHIFTF];
    dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToMDis, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToMDis, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToMDis, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToMDis, @$.S, @$.E); 
      }
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis)); 
      goto imac_tripleBIU_add;
      break;
      
      case 6://to imacbiu0  
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToBIU0, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToBIU0, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToBIU0, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToBIU0, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imac_tripleBIU_add;
      break;
      
      case 7://to imacbiu1    
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToBIU1, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToBIU1, @$.S, @$.E); 
        break;     
       case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToBIU1, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToBIU1, @$.S, @$.E); 
       }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imac_tripleBIU_add;
      break;
      
      case 8://to imacbiu2  
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToBIU2, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToBIU2, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToBIU2, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToBIU2, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imac_tripleBIU_add;
      break;
      
      case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToBIU2, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToBIU2, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToBIU2, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToBIU2, @$.S, @$.E); 
      }
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imac_tripleBIU_add;
      break;
      
  }
imac_tripleBIU_add:
  //deal with additional dest
    switch (imac_additional_dest) {
        case 0:
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;        
        case 1: //_IMAC.T0 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@3, "imac additional dest error!"); clear();YYABORT;
          break;
      }
      //for imac abs bit
      f = OPERAND(Imm, 0, FlagS, FlagE);
      ff = OPERAND(Imm, 1, FlagS, FlagE);
      if(isIMACABS)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      //for imac B/S/R/I, or B/S/W flag
      if(!isIMACABS) {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[RF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else if(flags[IF])
          ADDOPERAND(Reg, UCPMReg::T3, @$.S, @$.E);
        else
          {llvmerror(&@1, "imac B/R/S/I flag error!");clear();YYABORT;}
      }
      else {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[WF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else
          {llvmerror(&@1, "imac B/S/W flag error!"); clear();YYABORT;}
      }
      flags.reset();  
}
//ducx:for tp +- tm*tn, nodest
| imacmaclause {
  if(tm->getReg() > UCPMReg::T5)
    {llvmerror(&@1, "Incorrect IMAC_Mul inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu
  if(tn->getReg() > UCPMReg::T5)
    {llvmerror(&@1, "Incorrect IMAC_Mul inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
  if(tp->getReg() > UCPMReg::T5)
    {llvmerror(&@1, "Incorrect IMAC_Mul inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
    
  flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1);
  //C but not have CR
  if(flags[CF])
  {
     flagsort |= 0x1;
     flagsort &= 0b110111;
  }
  //SEND flag
  if(flags[SENDF])
    flagsort |= 0x1;
    
    //ducx:for abs mul
  if(isIMACABS)
    flagsort &= 0b110111;
    
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
  {llvmerror(&@1, "imac ShiftMode0/1/2/3 flag error!");clear();YYABORT;}
  //flagsort = 0x2;
  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  //flags.reset();
  
 if (flags[LF])
   {llvmerror(&@1, "IMAC_Mul L flag error,available flags are U,P,T,F,C/Send,ShiftMode0/1/2/3 ");clear();YYABORT;};//niuxx
   
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToSHU, @$.S, @$.E);//?????
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToSHU, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToSHU, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToSHU, @$.S, @$.E); 
      }

      ADDOPERAND(Reg, UCPMReg::IALUBIU0, @$.S, @$.E);//unit=0
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);//ut=0
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
      
      //for imac abs bit
      f = OPERAND(Imm, 0, FlagS, FlagE);
      ff = OPERAND(Imm, 1, FlagS, FlagE);
      if(isIMACABS)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      //for imac B/S/R/I, or B/S/W flag
      if(!isIMACABS) {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[RF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else if(flags[IF])
          ADDOPERAND(Reg, UCPMReg::T3, @$.S, @$.E);
        else
          {llvmerror(&@1, "imac B/R/S/I flag error!");clear();YYABORT;}
      }
      else {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[WF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else
          {llvmerror(&@1, "imac B/S/W flag error!"); clear();YYABORT;}
      }
      flags.reset();  
}
|
//ducx start 20180130
imacASclause ASSIGNTO imacASdest {//niuxiaoxu
  if (!isTpValid)
  {
    if(tm->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IMAC_AS inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
    if(tn->getReg() == UCPMReg::T6)
      {llvmerror(&@1, "Incorrect IMAC_AS inst! Tn should be T0-T5,T7!");clear();YYABORT;}//niuxu 
  }
  else if (!isTnValid)
  {
    if(tm->getReg() > UCPMReg::T6)
      {llvmerror(&@1, "Incorrect IMAC_AS inst! Tp should be T0-T6!");clear();YYABORT;}//niuxu
    if(tn->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IMAC_AS inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu 
  }
  else
  {
    if(tm->getReg() > UCPMReg::T6)
      {llvmerror(&@1, "Incorrect IMAC_AS inst! Tp should be T0-T6!");clear();YYABORT;}//niuxu
    if(tn->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IMAC_AS inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
    if(tp->getReg() == UCPMReg::T6)
      {llvmerror(&@1, "Incorrect IMAC_AS inst! Tn should be T0-T5,T7!");clear();YYABORT;}//niuxu  
  }
     
  flagsort = (flags[LF] << 3) | (flags[TF] << 2) | (flags[CF] << 1) | (flags[PF] << 0);
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    {llvmerror(&@1, "imac ShiftMode0/1/2/3 flag error!");clear();YYABORT;}

  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  
  if(flags[BF])
    ImacMuAA_BSflag = 0;
  else if(flags[SF])
    ImacMuAA_BSflag = 1;
  else
    {llvmerror(&@1, "imac B/S flag error!"); clear();YYABORT;}
    
  //flags.reset();
  
  switch ($3){
  
    case 0://to imac  
   
	
      ADDOPERAND(Opc, UCPM::IMACASToIMAC, @$.S, @$.E); 

      Operands.push_back(nullptr);
      condpos = Operands.size();
      
      if(!isTpValid) {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        //it's tp as 0 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);//for unused tp in imac
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
      }
      else if(!isTnValid)
      {     
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        //it's tn as 1 
        unsigned tn_1 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);//for unused tn in imac
        revt = OPERAND(Reg, tn_1, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
      }
      else
      {
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
      if(flags[XF])
        ADDOPERAND(Imm, 1, @$.S, @$.E);
      else
        ADDOPERAND(Imm, 0, @$.S, @$.E);
      break;
      
    case 1://to m[t] & IALU/SHU
      if(flags[XF])
	{llvmerror(&@1, "IMAC_AS X flags error! Available flags are L,P,T,C,ShiftMode0/1/2/3"); clear();YYABORT;};//niuxx
    
      ADDOPERAND(Opc, UCPM::IMACASToMregIALUSHU, @$.S, @$.E); 
         
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      
      if(!isTpValid) {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        //it's tp as 0 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);//for unused tp in imac
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
      }
      else if(!isTnValid)
      {     
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        //it's tn as 1 
        unsigned tn_1 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);//for unused tn in imac
        revt = OPERAND(Reg, tn_1, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
      }
      else
      {
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
      ADDOPERAND(Imm, ImacToialu_flag, @$.S, @$.E);
      break;
      
    case 2://to m[s++/i++/a++] & IALU/SHU
       if(flags[XF])
	{llvmerror(&@1, "IMAC_AS X flags error! Available flags are L,P,T,C,ShiftMode0/1/2/3"); clear();YYABORT;};//niuxx
    
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      
         ADDOPERAND(Opc, UCPM::IMACASToMSIAIALUSHU, @$.S, @$.E); 

      Operands.push_back(nullptr);
      condpos = Operands.size();
      
      if(!isTpValid) {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        //it's tp as 0 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);//for unused tp in imac
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
      }
      else if(!isTnValid)
      {     
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        //it's tn as 1 
        unsigned tn_1 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);//for unused tn in imac
        revt = OPERAND(Reg, tn_1, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
      }
      else
      {
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
      ADDOPERAND(Imm, ImacToialu_flag, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia)); 
      break;

    case 3://to m[dis{shift}] & IALU/SHU    
      if(flags[XF])
	{llvmerror(&@1, "IMAC_AS X flags error! Available flags are L,P,T,C,ShiftMode0/1/2/3"); clear();YYABORT;};//niuxx
     flagsort = flags[SHIFTF];
     dis = OPERAND(Imm, flagsort, FlagS, FlagE);
     
         ADDOPERAND(Opc, UCPM::IMACASToMDISIALUSHU, @$.S, @$.E); 

      Operands.push_back(nullptr);
      condpos = Operands.size();
      
      if(!isTpValid) {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        //it's tp as 0 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);//for unused tp in imac
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
      }
      else if(!isTnValid)
      {     
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        //it's tn as 1 
        unsigned tn_1 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);//for unused tn in imac
        revt = OPERAND(Reg, tn_1, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
      }
      else
      {
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
      ADDOPERAND(Imm, ImacToialu_flag, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis)); 
      break;
   }
      
      flags.reset();  
}
//ducx end 20180130
|
//yangl: imac: 0 +- tm*tn
imacmaclause_0_tm_tn ASSIGNTO imacdest {
  if(tm->getReg() > UCPMReg::T5)
    {llvmerror(&@1, "Incorrect IMAC_Mul inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
  if(tn->getReg() > UCPMReg::T5)
    {llvmerror(&@1, "Incorrect IMAC_Mul inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
    
  if (unit4 != NULL)
  {
    switch (unit4->getReg())
    {
      case  UCPMReg::IMACIALU:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IMAC_Mul inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;
      case UCPMReg::IMACIFALU:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IMAC_Mul inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;     
      case UCPMReg::IMACIFMAC:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IMAC_Mul inst! IFMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;     
    }
  }    

  unsigned treg = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);//for unused tp in imac
  revt = OPERAND(Reg, treg, @$.S, @$.E);
  flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1);
  //C but not have CR
  if(flags[CF])
  {
     flagsort |= 0x1;
     flagsort &= 0b110111;
  }
  //SEND flag
  if(flags[SENDF])
    flagsort |= 0x1;
    
    //ducx:for abs mul
  if(isIMACABS)
    flagsort &= 0b110111;
    
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    {llvmerror(&@1, "imac ShiftMode0/1/2/3 flag error!");clear();YYABORT;}
    //flagsort = 0x2;
  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  //flags.reset();
  
  switch ($3){
    case 0://to shu  
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToSHU, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToSHU, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToSHU, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToSHU, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));//null tp for imac (it's T6 in binary)
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imac111BIU_add;
      break;
      
    case 1://to macc
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToMACC, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToMACC, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToMACC, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToMACC, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));//null tp for imac (it's T6 in binary)
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift)); 
      goto imac111BIU_add;
      break;     
    case 3://to m[t]
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToM, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToM, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToM, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToM, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));//null tp for imac (it's T6 in binary)
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imac111BIU_add;
      break;

    case 4://to m[s++/i++/a++]
    
     flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
     sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToMSIA, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToMSIA, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToMSIA, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToMSIA, @$.S, @$.E); 
      }
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));//null tp for imac (it's T6 in binary)
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));  
      goto imac111BIU_add;
      break;
      
    case 5://to m[dis{shift}]
    flagsort = flags[SHIFTF];
    dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToMDis, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToMDis, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToMDis, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToMDis, @$.S, @$.E); 
      }
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));//null tp for imac (it's T6 in binary)
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis)); 
      goto imac111BIU_add;
      break;
      
      case 6://to imacbiu0  
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToBIU0, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToBIU0, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToBIU0, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToBIU0, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));//null tp for imac (it's T6 in binary)
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imac111BIU_add;
      break;
      
      case 7://to imacbiu1    
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToBIU1, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToBIU1, @$.S, @$.E); 
        break;     
       case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToBIU1, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToBIU1, @$.S, @$.E); 
       }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));//null tp for imac (it's T6 in binary)
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imac111BIU_add;
      break;
      
      case 8://to imacbiu2  
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToBIU2, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToBIU2, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToBIU2, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToBIU2, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));//null tp for imac (it's T6 in binary)
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imac111BIU_add;
      break;
      
    case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToBIU2, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToBIU2, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToBIU2, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToBIU2, @$.S, @$.E); 
      }
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));//null tp for imac (it's T6 in binary)
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imac111BIU_add;
      break;
  }
imac111BIU_add:
      //deal with additional dest
      switch (imac_additional_dest) {
        case 0:
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;        
        case 1: //_IMAC.T0 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@3, "imac additional dest error!"); clear();YYABORT;
          break;
      }
      //for imac abs bit
      f = OPERAND(Imm, 0, FlagS, FlagE);
      ff = OPERAND(Imm, 1, FlagS, FlagE);
      if(isIMACABS)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      //for imac B/S/R/I, or B/S/W flag
      if(!isIMACABS) {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[RF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else if(flags[IF])
          ADDOPERAND(Reg, UCPMReg::T3, @$.S, @$.E);
        else
          {llvmerror(&@1, "imac B/R/S/I flag error!"); clear();YYABORT;}
      }
      else {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[WF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else
          {llvmerror(&@1, "imac B/S/W flag error!"); clear();YYABORT;}
      }
      flags.reset();
}
//ducx: 0 +- tm*tn, nodest
| imacmaclause_0_tm_tn {
  if(tm->getReg() > UCPMReg::T5)
    {llvmerror(&@1, "Incorrect IMAC_Mul inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
  if(tn->getReg() > UCPMReg::T5)
    {llvmerror(&@1, "Incorrect IMAC_Mul inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
    
  unsigned treg = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);//for unused tp in imac
  revt = OPERAND(Reg, treg, @$.S, @$.E);
  flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1);
  //C but not have CR
  if(flags[CF])
  {
     flagsort |= 0x1;
     flagsort &= 0b110111;
  }
  //SEND flag
  if(flags[SENDF])
    flagsort |= 0x1;
    
    //ducx:for abs mul
  if(isIMACABS)
    flagsort &= 0b110111;
    
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    {llvmerror(&@1, "imac ShiftMode0/1/2/3 flag error!");clear();YYABORT;}
    //flagsort = 0x2;
  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  //flags.reset();
 
  if (flags[LF])
   {llvmerror(&@1, "IMAC/IFMAC_Add/Sub_Mul L flag error,available flags are U,P,T,F,C/Send,ShiftMode0/1/2/3 ");clear();YYABORT;};//niuxx
   
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToSHU, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToSHU, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToSHU, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToSHU, @$.S, @$.E); 
      }

      ADDOPERAND(Reg, UCPMReg::IALUBIU0, @$.S, @$.E);//unit=0
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);//ut=0
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));//null tp for imac (it's T6 in binary)
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
 
      //for imac abs bit
      f = OPERAND(Imm, 0, FlagS, FlagE);
      ff = OPERAND(Imm, 1, FlagS, FlagE);
      if(isIMACABS)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      //for imac B/S/R/I, or B/S/W flag
      if(!isIMACABS) {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[RF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else if(flags[IF])
          ADDOPERAND(Reg, UCPMReg::T3, @$.S, @$.E);
        else
          {llvmerror(&@1, "imac B/R/S/I flag error!"); clear();YYABORT;}
      }
      else {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[WF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else
          {llvmerror(&@1, "imac B/S/W flag error!"); clear();YYABORT;}
      }
      flags.reset();
}
/*|
//yangl: imac: MR +- tm*tn
imacmaclause_mr_tm_tn ASSIGNTO imacdest {
  unsigned treg = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);//for unused tp in imac
  revt = OPERAND(Reg, treg, @$.S, @$.E);
  
  //ducx
  if(flags[CF])
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (flags[CRF] << 3) | (flags[FF] << 2) | (flags[PF] << 1) | (1 << 0);
  else if(flags[RF])
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1) | flags[CRF];
  else if(flags[IF])
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1) | flags[SENDF];
  else
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1);


  //ducx:for abs mul
  if(isIMACABS)
    flagsort &= 0b110111;
    
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    llvmerror(&@1, "ShiftMode0/1/2/3 flag error!");
    //flagsort = 0x2;
  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  //flags.reset();
  
  switch ($3){
    case 0://to shu  
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToSHU, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToSHU, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToSHU, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToSHU, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imac222BIU_add;
      break;
      
    case 1://to macc
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToMACC, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToMACC, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToMACC, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToMACC, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imac222BIU_add;
      break;
      
    case 3://to m[t]
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToM, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToM, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToM, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToM, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imac222BIU_add;
      break;

    case 4://to m[s++/i++/a++]
    
     flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
     sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToMSIA, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToMSIA, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToMSIA, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToMSIA, @$.S, @$.E); 
      }
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia)); 
      goto imac222BIU_add;
      break;
      
    case 5://to m[dis{shift}]
    flagsort = flags[SHIFTF];
    dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToMDis, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToMDis, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToMDis, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToMDis, @$.S, @$.E); 
      }
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis)); 
      goto imac222BIU_add;
      break;
      
      case 6://to imacbiu0  
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToBIU0, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToBIU0, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToBIU0, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToBIU0, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imac222BIU_add;
      break;
      
      case 7://to imacbiu1    
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToBIU1, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToBIU1, @$.S, @$.E); 
        break;     
       case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToBIU1, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToBIU1, @$.S, @$.E); 
       }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imac222BIU_add;
      break;
      
      case 8://to imacbiu2  
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToBIU2, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToBIU2, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToBIU2, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToBIU2, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imac222BIU_add;
      break;
      
    case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToBIU2, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToBIU2, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToBIU2, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToBIU2, @$.S, @$.E); 
      }
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imac222BIU_add;
      break;
      
  }
imac222BIU_add:  
      //deal with additional dest
        switch (imac_additional_dest) {
        case 0:
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;        
        case 1: //_IMAC.T0 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@1, "imac additional dest error!"); 
          break;
      }
      //for imac abs bit
      f = OPERAND(Imm, 0, FlagS, FlagE);
      ff = OPERAND(Imm, 1, FlagS, FlagE);
      if(isIMACABS)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      //for imac B/S/R/I, or B/S/W flag
      if(!isIMACABS) {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[RF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else if(flags[IF])
          ADDOPERAND(Reg, UCPMReg::T3, @$.S, @$.E);
        else
          llvmerror(&@1, "B/R/S/I flag error!"); 
      }
      else {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[WF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else
          llvmerror(&@1, "B/S/W flag error!"); 
      }
      flags.reset();
}
|
//ducx: imac: MR +- tm*tn, nodest
imacmaclause_mr_tm_tn {
  unsigned treg = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);//for unused tp in imac
  revt = OPERAND(Reg, treg, @$.S, @$.E);
  
  //ducx
  if(flags[CF])
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (flags[CRF] << 3) | (flags[FF] << 2) | (flags[PF] << 1) | (1 << 0);
  else if(flags[RF])
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1) | flags[CRF];
  else if(flags[IF])
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1) | flags[SENDF];
  else
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1);


  //ducx:for abs mul
  if(isIMACABS)
    flagsort &= 0b110111;
    
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    llvmerror(&@1, "ShiftMode0/1/2/3 flag error!");
    //flagsort = 0x2;
  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  //flags.reset();
  

      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToSHU, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToSHU, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToSHU, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToSHU, @$.S, @$.E); 
      }
      ADDOPERAND(Reg, UCPMReg::IALUBIU0, @$.S, @$.E);//unit=0
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);//ut=0
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
   
      //for imac abs bit
      f = OPERAND(Imm, 0, FlagS, FlagE);
      ff = OPERAND(Imm, 1, FlagS, FlagE);
      if(isIMACABS)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      //for imac B/S/R/I, or B/S/W flag
      if(!isIMACABS) {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[RF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else if(flags[IF])
          ADDOPERAND(Reg, UCPMReg::T3, @$.S, @$.E);
        else
          llvmerror(&@1, "B/R/S/I flag error!"); 
      }
      else {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[WF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else
          llvmerror(&@1, "B/S/W flag error!"); 
      }
      flags.reset();
}*/
|
//yangl: imac: MR +=/-= tm*tn -> dest
imacmaclause_mr_equ_tm_tn ASSIGNTO imacdest {
      
  if (unit4 != NULL)
  {
    switch (unit4->getReg())
    {
      case  UCPMReg::IMACIALU:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IMAC_Mul inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;
      case UCPMReg::IMACIFALU:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IMAC_Mul inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;     
      case UCPMReg::IMACIFMAC:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IMAC_Mul inst! IFMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;     
    }
  }   
  
  if(tm->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IMAC_Mul inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
  if (isTnValid == true)
  {
    if(tn->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IMAC_Mul inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu   
  }
 
  unsigned treg = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);//for unused tp in imac
  revt = OPERAND(Reg, treg, @$.S, @$.E);
  
  //ducx
  if(flags[CF])
//    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (flags[CRF] << 3) | (flags[FF] << 2) | (flags[PF] << 1) | (1 << 0);
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (0 << 3) | (flags[FF] << 2) | (flags[PF] << 1) | (1 << 0);
  else if(flags[RF])
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1) | flags[CRF];
  else if(flags[IF])
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1) | flags[SENDF];
  else
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1);

  //ducx 20180801
  if(flags[CF] && flags[CRF])
  {
    llvmerror(&@1, "Incorrect IMAC_Mul inst! C and CR should not coexist!");clear();YYABORT;
  }
  

    //ducx:for abs mul
  if(isIMACABS)
    flagsort &= 0b110111;
    
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    {llvmerror(&@1, "imac ShiftMode0/1/2/3 flag error!");clear();YYABORT;}
    //flagsort = 0x2;
  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  //flags.reset();
  
  switch ($3){
    case 0://to shu  
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToSHU, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToSHU, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToSHU, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToSHU, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imac333BIU_add;
      break;
      
    case 1://to macc
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToMACC, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToMACC, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToMACC, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToMACC, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imac333BIU_add;
      break;
      
    case 3://to m[t]
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToM, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToM, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToM, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToM, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imac333BIU_add;
      break;

    case 4://to m[s++/i++/a++]
    
     flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
     sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToMSIA, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToMSIA, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToMSIA, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToMSIA, @$.S, @$.E); 
      }
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia)); 
      goto imac333BIU_add;
      break;
      
    case 5://to m[dis{shift}]
    flagsort = flags[SHIFTF];
    dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToMDis, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToMDis, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToMDis, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToMDis, @$.S, @$.E); 
      }
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis)); 
      goto imac333BIU_add;
      break;
      
      case 6://to imacbiu0  
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToBIU0, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToBIU0, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToBIU0, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToBIU0, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imac333BIU_add;
      break;
      
      case 7://to imacbiu1    
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToBIU1, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToBIU1, @$.S, @$.E); 
        break;     
       case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToBIU1, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToBIU1, @$.S, @$.E); 
       }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imac333BIU_add;
      break;
      
      case 8://to imacbiu2  
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToBIU2, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToBIU2, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToBIU2, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToBIU2, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imac333BIU_add;
      break;
      
     case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IMARealaddToBIU2, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IMARealsubToBIU2, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IMACompaddToBIU2, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IMACompsubToBIU2, @$.S, @$.E); 
      }
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto imac333BIU_add;
      break;
      
  }
imac333BIU_add:  
       switch (imac_additional_dest) {
        case 0:
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 1: //_IMAC.T0 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@3, "imac additional dest error!"); clear();YYABORT;
          break;
      }
      //for imac abs bit
      f = OPERAND(Imm, 0, FlagS, FlagE);
      ff = OPERAND(Imm, 1, FlagS, FlagE);
      if(isIMACABS)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      //for imac B/S/R/I, or B/S/W flag
      if(!isIMACABS) {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[RF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else if(flags[IF])
          ADDOPERAND(Reg, UCPMReg::T3, @$.S, @$.E);
        else
          {llvmerror(&@1, "imac B/R/S/I flag error!"); clear();YYABORT;}
      }
      else {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[WF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else
          {llvmerror(&@1, "imac B/S/W flag error!"); clear();YYABORT;}
      }
      flags.reset();
}
|
//yangl: imac: MR +=/-= tm*tn
imacmaclause_mr_equ_tm_tn_inside {
  if(tm->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IMAC_Mul inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
  if(tn->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IMAC_Mul inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu

  unsigned treg = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);//for unused tp in imac
  revt = OPERAND(Reg, treg, @$.S, @$.E);
  
  //ducx
  if(flags[CF])
//    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (flags[CRF] << 3) | (flags[FF] << 2) | (flags[PF] << 1) | (1 << 0);
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (0 << 3) | (flags[FF] << 2) | (flags[PF] << 1) | (1 << 0);
  else if(flags[RF])
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1) | flags[CRF];
  else if(flags[IF])
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1) | flags[SENDF];
  else
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1);


  //ducx 20180801
  if(flags[CF] && flags[CRF])
  {
    llvmerror(&@1, "Incorrect IMAC_Mul inst! C and CR should not coexist!");clear();YYABORT;
  }

    
    //ducx:for abs mul
  if(isIMACABS)
    flagsort &= 0b110111;
    
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    {llvmerror(&@1, "imac ShiftMode0/1/2/3 flag error!");clear();YYABORT;}
    //flagsort = 0x2;
  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  //flags.reset();

 if (flags[LF])
   {llvmerror(&@1, "IMAC/IFMAC_MR_Mul L flag error,available flags are CR,U,P,T,F,C/Send,ShiftMode0/1/2/3 ");clear();YYABORT;};//niuxx  
  
   //use "to shu" case
  switch ($1) {
    case 0: //real add
    ADDOPERAND(Opc, UCPM::IMARealaddToSHU, @$.S, @$.E); 
    break;      
    case 1: //real sub
    ADDOPERAND(Opc, UCPM::IMARealsubToSHU, @$.S, @$.E); 
    break;     
    case 2: //complex add
    ADDOPERAND(Opc, UCPM::IMACompaddToSHU, @$.S, @$.E); 
    break;  
    case 3: //complex sub
    ADDOPERAND(Opc, UCPM::IMACompsubToSHU, @$.S, @$.E); 
    break;
  }
  //Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
  ADDOPERAND(Reg, UCPMReg::IALUBIU0, @$.S, @$.E);
  //Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
  ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
  Operands.push_back(nullptr);
  condpos = Operands.size();
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
  if(isTnValid == true)
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
  else
    ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
  ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
  //for imac abs bit
      f = OPERAND(Imm, 0, FlagS, FlagE);
      ff = OPERAND(Imm, 1, FlagS, FlagE);
      if(isIMACABS)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      //for imac B/S/R/I, or B/S/W flag
      if(!isIMACABS) {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[RF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else if(flags[IF])
          ADDOPERAND(Reg, UCPMReg::T3, @$.S, @$.E);
        else
          {llvmerror(&@1, "imac B/R/S/I flag error!"); clear();YYABORT;}
      }
      else {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[WF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else
          {llvmerror(&@1, "imac B/S/W flag error!"); clear();YYABORT;}
      }
      flags.reset();
}
|
//yangl: UCP_M, start IMAC MulAV
imacMulAVclause ASSIGNTO imacdest {
    if (!isTpValid)
    {
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IMAC_MulAV inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IMAC_MulAV inst! Tl should be T0-T5!");clear();YYABORT;}//niuxu
      if(tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IMAC_MulAV inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu    
    }
    else if (isTpMR)
    {
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IMAC_MulAV inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IMAC_MulAV inst! Tl should be T0-T5!");clear();YYABORT;}//niuxu
      if(tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IMAC_MulAV inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu    
    }
    else
    {
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IMAC_MulAV inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IMAC_MulAV inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IMAC_MulAV inst! Tl should be T0-T5!");clear();YYABORT;}//niuxu
      if(tk->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IMAC_MulAV inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
    }	 

     if (unit4 != NULL)
     {
	switch (unit4->getReg())
	{
	  case  UCPMReg::IMACIALU:
	    if (ut->getReg() > UCPMReg::T5)
	       {llvmerror(&@3, "Incorrect IMAC_MulAV inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	  case UCPMReg::IMACIFALU:
	    if (ut->getReg() > UCPMReg::T5)
	       {llvmerror(&@3, "Incorrect IMAC_MulAV inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;     
	  case UCPMReg::IMACIFMAC:
	    if (ut->getReg() > UCPMReg::T5)
	       {llvmerror(&@3, "Incorrect IMAC_MulAV inst! IFMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;     
	}
     }     
    
  flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (flags[FF] << 2) | (flags[PF] << 1);
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    {llvmerror(&@1, "imac MulAV ShiftMode0/1/2/3 flag error!");clear();YYABORT;}
    //flagsort = 0x2;
  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
  sia = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = flags[SHIFTF];
  dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
  
  if(flags[BF])
    ImacMuAA_BSflag = 0;
  else if(flags[SF])
    ImacMuAA_BSflag = 1;
  else
    {llvmerror(&@1, "imac MulAV B/S flag error!"); clear();YYABORT;}
  flags.reset();  
  
  switch ($3){
    case 0://to shu
      ADDOPERAND(Opc, UCPM::MulAVToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tn in MulAV
        //it's tp as 0 in MulAV
        unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);//for unused tp in imac
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV

      }
      else if(isTpMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV
      }
      else {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tl in MulAV
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
      //goto imacmulAVBIU_add;
      break;
    case 1://to macc
      ADDOPERAND(Opc, UCPM::MulAVToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();     
      if(!isTpValid) {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tn in MulAV
        //it's tp as 0 in MulAV
        unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);//for unused tp in imac
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV

      }
      else if(isTpMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV
      }
      else {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tl in MulAV
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
      //goto imacmulAVBIU_add;
      break;
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::MulAVToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tn in MulAV
        //it's tp as 0 in MulAV
        unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);//for unused tp in imac
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV

      }
      else if(isTpMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV
      }
      else {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tl in MulAV
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
      //goto imacmulAVBIU_add;
      break;
         
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::MulAVToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tn in MulAV
        //it's tp as 0 in MulAV
        unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);//for unused tp in imac
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV

      }
      else if(isTpMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV
      }
      else {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tl in MulAV
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
      //goto imacmulAVBIU_add;
      break;
    case 5://to m[dis{shift}]
      ADDOPERAND(Opc, UCPM::MulAVToMDis, @$.S, @$.E);         
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tn in MulAV
        //it's tp as 0 in MulAV
        unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);//for unused tp in imac
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV

      }
      else if(isTpMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV
      }
      else {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tl in MulAV
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
      //goto imacmulAVBIU_add;
      break;
   
   case 9://to _IMAC.MR
      ADDOPERAND(Opc, UCPM::MulAVToBIU2, @$.S, @$.E); 
      ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tn in MulAV
        //it's tp as 0 in MulAV
        unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);//for unused tp in imac
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV

      }
      else if(isTpMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV
      }
      else {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tl in MulAV
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
      break;
      
    case 6://to biu0  
      ADDOPERAND(Opc, UCPM::MulAVToBIU0, @$.S, @$.E); goto imacmulAVBIU;  
    case 7://to biu1  
      ADDOPERAND(Opc, UCPM::MulAVToBIU1, @$.S, @$.E); goto imacmulAVBIU;      
    case 8://to biu2  
      ADDOPERAND(Opc, UCPM::MulAVToBIU2, @$.S, @$.E); goto imacmulAVBIU;  
  
imacmulAVBIU:      

      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tn in MulAV
        //it's tp as 0 in MulAV
        unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);//for unused tp in imac
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV

      }
      else if(isTpMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV
      }
      else {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tl in MulAV
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
      break;
      
    default:
      llvmerror(&@3, "imac MulAV dest error!"); 
      break;      
  }

}
|
imacMulAVclause_inside {
  if(tm->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IMAC_MulAV inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
  if(tn->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IMAC_MulAV inst! Tl should be T0-T5!");clear();YYABORT;}//niuxu
  if(tp->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IMAC_MulAV inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu   
      
  flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (flags[FF] << 2) | (flags[PF] << 1);
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    {llvmerror(&@1, "imac MulAV ShiftMode0/1/2/3 flag error!");clear();YYABORT;}
    //flagsort = 0x2;
  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  if(flags[BF])
    ImacMuAA_BSflag = 0;
  else if(flags[SF])
    ImacMuAA_BSflag = 1;
  else
    {llvmerror(&@1, "imac MulAV B/S flag error!"); clear();YYABORT;}
  flags.reset();  
  
  ADDOPERAND(Opc, UCPM::MulAVMRACC1, @$.S, @$.E); 
  Operands.push_back(nullptr);
  condpos = Operands.size();
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tm in MulAV
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tn in MulAV
  //it's tp as MR in MulAV
  unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);//for unused tp in imac
  revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
  ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
  break;
}//end IMAC MulAV
|
imacwaitclause{
  ADDOPERAND(Opc, UCPM::IMACWait, @$.S, @$.E); 
  Operands.push_back(nullptr);
  condpos = Operands.size();
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
}
/*|
imacsettisflag{
  flagsort = (flags[LF] << 4);
  if(flags[NF])
    ;
  else if(flags[CF])
    flagsort |= (0x1);
  else if(flags[VF])
    flagsort |= (0x1 << 1);
  else if(flags[MCF])
    flagsort |= (0x1 << 2);
  else if(flags[MVF]) {
    flagsort |= (0x1 << 2);
    flagsort |= (0x1);
  }   
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  ADDOPERAND(Opc, UCPM::IMACSetTIsFLAG, @$.S, @$.E); 
  Operands.push_back(nullptr);
  condpos = Operands.size();
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
}*/
| setCGInstr{
            
          flagsort = (flags[ONF]);
          f = OPERAND(Imm, flagsort, FlagS, FlagE);	
	  flags.reset();
	   
	    ADDOPERAND(Opc, UCPM::IMACSetCG, @$.S, @$.E);
	    Operands.push_back(nullptr);
	    condpos = Operands.size();
	    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));  
    
}
| TpToMRInstr ASSIGNTO MR{
          if(tm->getReg() > UCPMReg::T5)
	    {llvmerror(&@1, "Incorrect IMAC_SendMR inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu 
            
          flagsort = (flags[LF] << 2) | (flags[AF] << 1) | (flags[SF]);
          f = OPERAND(Imm, flagsort, FlagS, FlagE);	
	  flags.reset();
	   
	    ADDOPERAND(Opc, UCPM::IMACTpToMR, @$.S, @$.E);
	    Operands.push_back(nullptr);
	    condpos = Operands.size();
	    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));  
    
}
| imacSelTpMRclause ASSIGNTO imacdest {
  if(tm->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IFMAC_Sel inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu
      
  flagsort =  (flags[LF] << 4) | (flags[AF] << 3) | (flags[SF] << 2);  
    
  if(flags[HHF])
    flagsort |= 0b00011;
  else if(flags[LLF])
    ;
  else if(flags[HLF])
    flagsort |= 0b00010;
  else
    {llvmerror(&@1, "imac SelTpMR HH/LL/HL flag error!"); clear();YYABORT;}
    
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  switch ($3){
 
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IMACSelTpMRToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      goto imacSelTpMR_add;
      break;     
  
   case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      ADDOPERAND(Opc, UCPM::IMACSelTpMRToBIU2, @$.S, @$.E);
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      goto imacSelTpMR_add;
      break;
      
      
imacSelTpMR_add:    
    //deal with additional dest
      switch (imac_additional_dest) {
        case 0:
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;        
        case 1: //_IMAC.T0 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@3, "imac additional dest error!"); clear();YYABORT;
          break;
      }
      break;
      
    default:
      llvmerror(&@3, "imac dest error!"); clear();YYABORT;
      break;      
  }
  flags.reset();
};//end imacinst

// imacturboclause: TURBO LPAREN tripara RPAREN |
//                  TURBO LPAREN tripara RPAREN LPAREN L RPAREN |
//                  TURBO LPAREN tripara RPAREN LPAREN H RPAREN { flags.set(HF); };

imacturbo1clause: TURBO1 LPAREN tripara RPAREN _flag abflag flag_ |
                  TURBO1 LPAREN tripara RPAREN _flag abflag flag_ LPAREN L RPAREN |
                  TURBO1 LPAREN tripara RPAREN _flag abflag flag_ LPAREN H RPAREN { flags.set(HF); } |
                  TURBO1 LPAREN tripara RPAREN error {llvmerror(&@5, "Incorrect Turbo1 inst! Must have A/B flag!"); clear();YYABORT;};

imacturbo2clause: TURBO2 LPAREN dupara RPAREN _flag abflag flag_ |
                  TURBO2 LPAREN dupara RPAREN error {llvmerror(&@5, "Incorrect Turbo2 inst! Must have A/B flag!"); clear();YYABORT;};

imaclogicclause: 
t AND t { $$ = 0; opc = OPERAND(Reg, UCPMReg::imacAND, @$.S, @$.E); } |
t OR t { $$ = 1; opc = OPERAND(Reg, UCPMReg::imacOR, @$.S, @$.E); } |
t XOR t { $$ = 2; opc = OPERAND(Reg, UCPMReg::imacXOR, @$.S, @$.E); } |
NOT t { $$ = 3; opc = OPERAND(Reg, UCPMReg::imacNOT, @$.S, @$.E); 
        unsigned treg = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(0);//tp is unused
        revt = OPERAND(Reg, treg, @$.S, @$.E);} ;

//imulexp: t MUL t ;

imacreadmrclause: READMR _flag imactriplebswflags flag_ |
                  READMR _flag imactriplebswflags flag_ _flag imactreadmrholflags flag_ |
                  
                  READMR _flag error flag_ { llvmerror(&@3, "IMAC/IFMAC_ReadMR flags error! Available flags are B/S/W"); clear();YYABORT;}|//niuxx
                  READMR _flag imactriplebswflags flag_ _flag error flag_ { llvmerror(&@6, "IMAC/IFMAC_ReadMR flags error! Available flags are H/L/O"); clear();YYABORT;};//niuxx
imacwritemrclause: t ASSIGNTO SETMR _flag imactriplebswflags flag_ |
                   t ASSIGNTO SETMR _flag imactriplebswflags flag_ _flag imactreadmrholflags flag_ |
                     
                   t ASSIGNTO SETMR _flag error flag_ { llvmerror(&@3, "IMAC/IFMAC_SetMR flags error! Available flags are B/S/W"); clear();YYABORT;}|//niuxx 
                   t ASSIGNTO SETMR _flag imactriplebswflags flag_ _flag error flag_ { llvmerror(&@8, "IMAC/IFMAC_SetMR flags error! Available flags are H/L/O"); clear();YYABORT;};//niuxx
imacreadxorclause: READXOR;
imacwritexorclause: t ASSIGNTO IMAC DOT READXOR |
                    t ASSIGNTO IFMAC DOT READXOR;

imacreadflagclause: READFLAG _flag imacreadflag_flags flag_ |
		  
		    READFLAG _flag error flag_ { llvmerror(&@3, "IMAC/IFMAC_ReadFLAG flags error! Available flags are ( N/C/V/(N,C,V),Erased )/(MC,MV)/(T,LS)"); clear();YYABORT;};//niuxx
imacwriteflagclause: t ASSIGNTO IMAC DOT WRITEFLAG _flag imacwriteflag_flags flag_ |

		     t ASSIGNTO IMAC DOT WRITEFLAG _flag error flag_ { llvmerror(&@7, "IMAC_WriteFLAG flags error! Available flags are ( N/C/V/(N,C,V),Erased )/(MC,MV)/(T,LS)"); clear();YYABORT;};//niuxx
ifmacwriteflagclause: t ASSIGNTO IFMAC DOT WRITEFLAG _flag imacwriteflag_flags flag_ |

		      t ASSIGNTO IFMAC DOT WRITEFLAG _flag error flag_ { llvmerror(&@7, "IFMAC_WriteFLAG flags error! Available flags are ( N/C/V/(N,C,V),Erased )/(MC,MV)/(T,LS)"); clear();YYABORT;};//niuxx

//imacsettisflag: SETTISFLAG _flag imacreadflag_flags flag_;

//ducx 20180130
imacASclause: t AS t MUL t _flag imacrealflag flag_ _flag imacasflags flag_ |
              t AS t MUL t _flag imacrealflag flag_ | 
              
              t AS t MUL t _flag error flag_ { llvmerror(&@7, "IMAC/IFMAC_AS flags error! Available flags are B/S"); clear();YYABORT;}|//niuxx
              
              t AS t MUL t _flag imacrealflag flag_ _flag error flag_ { llvmerror(&@10, "IMAC/IFMAC_AS flags error! Available flags are L,P,T,C,X,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
              //for tp=0
              AS t MUL t _flag imacrealflag flag_ _flag imacasflags flag_ {isTpValid = false;} |
              AS t MUL t _flag imacrealflag flag_ {isTpValid = false;} |
              
              AS t MUL t _flag error flag_ { llvmerror(&@6, "IMAC/IFMAC_AS flags error! Available flags are B/S"); clear();YYABORT;}|//niuxx
              AS t MUL t _flag imacrealflag flag_ _flag error flag_ { llvmerror(&@9, "IMAC/IFMAC_AS flags error! Available flags are L,P,T,C,X,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
              //for tn=1
              t AS t _flag imacrealflag flag_ _flag imacasflags flag_ {isTnValid = false;} |
              t AS t _flag imacrealflag flag_ {isTnValid = false;}|
              
	      t AS t _flag error flag_ { llvmerror(&@5, "IMAC/IFMAC_AS flags error! Available flags are B/S"); clear();YYABORT;}|//niuxx
	      t AS t _flag imacrealflag flag_ _flag error flag_ { llvmerror(&@8, "IMAC/IFMAC_AS flags error! Available flags are L,P,T,C,X,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx

//yangl: for imac: tp +- tm*tn
imacmaclause: t ADD t MUL t _flag imacrealflag flag_ _flag imacflags flag_ {$$ = 0;} |
              t ADD t MUL t _flag imacrealflag flag_ {$$ = 0;} |
              
              t ADD t MUL t _flag error flag_ { llvmerror(&@7, "IMAC/IFMAC_Add_Mul flags error! Available flags are B/S/R/I"); clear();YYABORT;}| //niuxx             
              t ADD t MUL t _flag imacrealflag flag_ _flag error flag_ { llvmerror(&@10, "IMAC/IFMAC_Add_Mul flags error! Available flags are U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
              t SUB t MUL t _flag imacrealflag flag_ _flag imacflags flag_ {$$ = 1;} |
              t SUB t MUL t _flag imacrealflag flag_ {$$ = 1;} |
              
              t SUB t MUL t _flag error flag_ { llvmerror(&@7, "IMAC/IFMAC_Sub_Mul flags error! Available flags are B/S/R/I"); clear();YYABORT;}|//niuxx
              t SUB t MUL t _flag imacrealflag flag_ _flag error flag_ { llvmerror(&@10, "IMAC/IFMAC_Sub_Mul flags error! Available flags are U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
              t ADD t MUL t _flag imaccompflag flag_ _flag imacflags flag_ {$$ = 2;} |
              t ADD t MUL t _flag imaccompflag flag_ {$$ = 2;} |
              
              t ADD t MUL t _flag error flag_ { llvmerror(&@7, "IMAC/IFMAC_Add_Mul flags error! Available flags are B/S/R/I"); clear();YYABORT;}|//niuxx
              t ADD t MUL t _flag imaccompflag flag_ _flag error flag_ { llvmerror(&@10, "IMAC/IFMAC_Add_Mul flags error! Available flags are U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
              t SUB t MUL t _flag imaccompflag flag_ _flag imacflags flag_ {$$ = 3;} |
              t SUB t MUL t _flag imaccompflag flag_ {$$ = 3;} |
              
              t SUB t MUL t _flag error flag_ { llvmerror(&@7, "IMAC/IFMAC_Sub_Mul flags error! Available flags are B/S/R/I"); clear();YYABORT;}|//niuxx
              t SUB t MUL t _flag imaccompflag flag_ _flag error flag_ { llvmerror(&@10, "IMAC/IFMAC_Sub_Mul flags error! Available flags are U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
              //yangl: for imac abs()
              t ADD ABS LPAREN t MUL t RPAREN _flag imactriplebswflags flag_ _flag imacflags flag_ {$$ = 0; isIMACABS = true;} |
              t ADD ABS LPAREN t MUL t RPAREN _flag imactriplebswflags flag_ {$$ = 0; isIMACABS = true;} |
              t SUB ABS LPAREN t MUL t RPAREN _flag imactriplebswflags flag_ _flag imacflags flag_ {$$ = 1; isIMACABS = true;} |
              t SUB ABS LPAREN t MUL t RPAREN _flag imactriplebswflags flag_ {$$ = 1; isIMACABS = true;} ;//?????
//yangl: for imac: 0 +- tm*tn
imacmaclause_0_tm_tn: 
              t MUL t _flag imacrealflag flag_ _flag imacflags flag_ {$$ = 0;} |
              t MUL t _flag imacrealflag flag_ {$$ = 0;} |
              
              t MUL t _flag error flag_  { llvmerror(&@5, "IMAC/IFMAC_Mul flags error! Available flags are B/S/R/I"); clear();YYABORT;}|//niuxx
              t MUL t _flag imacrealflag flag_ _flag error flag_ { llvmerror(&@8, "IMAC/IFMAC_Mul flags error! Available flags are U,L,P,T,F,C,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
              SUB t MUL t _flag imacrealflag flag_ _flag imacflags flag_ {$$ = 1;} |
              SUB t MUL t _flag imacrealflag flag_ {$$ = 1;} |
              
              SUB t MUL t _flag error flag_ { llvmerror(&@6, "IMAC/IFMAC_Sub_Mul flags error! Available flags are B/S/R/I"); clear();YYABORT;}|//niuxx
              SUB t MUL t _flag imacrealflag flag_ _flag error flag_ { llvmerror(&@9, "IMAC/IFMAC_Sub_Mul flags error! Available flags are U,L,P,T,F,C,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
              t MUL t _flag imaccompflag flag_ _flag imacflags flag_ {$$ = 2;} |
              t MUL t _flag imaccompflag flag_ {$$ = 2;} |
              
              t MUL t _flag error flag_ { llvmerror(&@5, "IMAC/IFMAC_Mul flags error! Available flags are B/S/R/I"); clear();YYABORT;}|//niuxx
              t MUL t _flag imaccompflag flag_ _flag error flag_ { llvmerror(&@8, "IMAC/IFMAC_Mul flags error! Available flags are U,L,P,T,F,C,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
              SUB t MUL t _flag imaccompflag flag_ _flag imacflags flag_ {$$ = 3;} |
              SUB t MUL t _flag imaccompflag flag_ {$$ = 3;} |
              
              SUB t MUL t _flag error flag_ { llvmerror(&@6, "IMAC/IFMAC_Sub_Mul flags error! Available flags are B/S/R/I"); clear();YYABORT;}|//niuxx
              SUB t MUL t _flag imaccompflag flag_ _flag error flag_ { llvmerror(&@9, "IMAC/IFMAC_Sub_Mul flags error! Available flags are U,L,P,T,F,C,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
              //yangl: for imac abs()
              ABS LPAREN t MUL t RPAREN _flag imactriplebswflags flag_ _flag imacflags flag_ {$$ = 0; isIMACABS = true;} |
              ABS LPAREN t MUL t RPAREN _flag imactriplebswflags flag_ {$$ = 0; isIMACABS = true;} |
              SUB ABS LPAREN t MUL t RPAREN _flag imactriplebswflags flag_ _flag imacflags flag_ {$$ = 1; isIMACABS = true;} |
              SUB ABS LPAREN t MUL t RPAREN _flag imactriplebswflags flag_ {$$ = 1; isIMACABS = true;} ;
//yangl: for imac: MR +- tm*tn
/*imacmaclause_mr_tm_tn: 
              MR ADD t MUL t _flag imacrealflag flag_ _flag imacflags flag_ {$$ = 0;} |
              MR ADD t MUL t _flag imacrealflag flag_ {$$ = 0;} |
              MR SUB t MUL t _flag imacrealflag flag_ _flag imacflags flag_ {$$ = 1;} |
              MR SUB t MUL t _flag imacrealflag flag_ {$$ = 1;} |
              MR ADD t MUL t _flag imaccompflag flag_ _flag imacflags flag_ {$$ = 2;} |
              MR ADD t MUL t _flag imaccompflag flag_ {$$ = 2;} |
              MR SUB t MUL t _flag imaccompflag flag_ _flag imacflags flag_ {$$ = 3;} |
              MR SUB t MUL t _flag imaccompflag flag_ {$$ = 3;} |
              //for tn = 1
              MR ADD t _flag imacrealflag flag_ _flag imacflags flag_ {$$ = 0; isTnValid = false; } |
              MR ADD t _flag imacrealflag flag_ {$$ = 0; isTnValid = false; } |
              MR SUB t _flag imacrealflag flag_ _flag imacflags flag_ {$$ = 1; isTnValid = false; } |
              MR SUB t _flag imacrealflag flag_ {$$ = 1; isTnValid = false; } |
              MR ADD t _flag imaccompflag flag_ _flag imacflags flag_ {$$ = 2; isTnValid = false; } |
              MR ADD t _flag imaccompflag flag_ {$$ = 2; isTnValid = false; } |
              MR SUB t _flag imaccompflag flag_ _flag imacflags flag_ {$$ = 3; isTnValid = false; } |
              MR SUB t _flag imaccompflag flag_ {$$ = 3; isTnValid = false; } |
              //yangl: for imac abs()
              MR ADD ABS LPAREN t MUL t RPAREN _flag imactriplebswflags flag_ _flag imacflags flag_ {$$ = 0; isIMACABS = true;} |
              MR ADD ABS LPAREN t MUL t RPAREN _flag imactriplebswflags flag_ {$$ = 0; isIMACABS = true;} |
              MR SUB ABS LPAREN t MUL t RPAREN _flag imactriplebswflags flag_ _flag imacflags flag_ {$$ = 1; isIMACABS = true;} |
              MR SUB ABS LPAREN t MUL t RPAREN _flag imactriplebswflags flag_ {$$ = 1; isIMACABS = true;} |
              //for tn = 1
              MR ADD ABS LPAREN t RPAREN _flag imactriplebswflags flag_ _flag imacflags flag_ {$$ = 0; isTnValid = false;  isIMACABS = true;} |
              MR ADD ABS LPAREN t RPAREN _flag imactriplebswflags flag_ {$$ = 0; isTnValid = false;  isIMACABS = true;} |
              MR SUB ABS LPAREN t RPAREN _flag imactriplebswflags flag_ _flag imacflags flag_ {$$ = 1; isTnValid = false;  isIMACABS = true;} |
              MR SUB ABS LPAREN t RPAREN _flag imactriplebswflags flag_ {$$ = 1; isTnValid = false; isIMACABS = true; } ;*/
//yangl: for imac: MR +=/-= tm*tn -> dest
imacmaclause_mr_equ_tm_tn: 
              MR ACC1 t MUL t _flag imacrealflag flag_ _flag imacmrasmflags flag_ {$$ = 0;} |
              MR ACC1 t MUL t _flag imacrealflag flag_ {$$ = 0;} |
              
              MR ACC1 t MUL t _flag imacrealflag flag_ _flag error flag_ { llvmerror(&@10, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
              MR ACC1 t MUL t _flag error flag_ { llvmerror(&@7, "IMAC/IFMAC_MR_Mul flags error! Available flags are B/S/R/I"); clear();YYABORT;}|//niuxx
              MR SUBEQU t MUL t _flag imacrealflag flag_ _flag imacmrasmflags flag_ {$$ = 1;} |
              MR SUBEQU t MUL t _flag imacrealflag flag_ {$$ = 1;} |
              
              MR SUBEQU t MUL t _flag error flag_ { llvmerror(&@7, "IMAC/IFMAC_MR_Mul flags error! Available flags are B/S/R/I"); clear();YYABORT;}|//niuxx
              MR SUBEQU t MUL t _flag imacrealflag flag_ _flag error flag_ { llvmerror(&@10, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
              MR ACC1 t MUL t _flag imaccompflag flag_ _flag imacmrasmflags flag_ {$$ = 2;} |
              MR ACC1 t MUL t _flag imaccompflag flag_ {$$ = 2;} |
              
              MR ACC1 t MUL t _flag error flag_ { llvmerror(&@7, "IMAC/IFMAC_MR_Mul flags error! Available flags are B/S/R/I"); clear();YYABORT;}|//niuxx
              MR ACC1 t MUL t _flag imaccompflag flag_ _flag error flag_ { llvmerror(&@10, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
              MR SUBEQU t MUL t _flag imaccompflag flag_ _flag imacmrasmflags flag_ {$$ = 3;} |
              MR SUBEQU t MUL t _flag imaccompflag flag_ {$$ = 3;} |
              
              MR SUBEQU t MUL t _flag error flag_ { llvmerror(&@7, "IMAC/IFMAC_MR_Mul flags error! Available flags are B/S/R/I"); clear();YYABORT;}|//niuxx
              MR SUBEQU t MUL t _flag imaccompflag flag_ _flag error flag_ { llvmerror(&@10, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
              //for tn = 1
              MR ACC1 t _flag imacrealflag flag_ _flag imacmrasmflags flag_ {$$ = 0; isTnValid = false; } |
              MR ACC1 t _flag imacrealflag flag_ {$$ = 0; isTnValid = false; } |
              
              MR ACC1 t _flag error flag_ { llvmerror(&@5, "IMAC/IFMAC_MR_Mul flags error! Available flags are B/S/R/I"); clear();YYABORT;}|//niuxx
              MR ACC1 t _flag imacrealflag flag_ _flag error flag_ { llvmerror(&@8, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
              MR SUBEQU t _flag imacrealflag flag_ _flag imacmrasmflags flag_ {$$ = 1; isTnValid = false; } |
              MR SUBEQU t _flag imacrealflag flag_ {$$ = 1; isTnValid = false; } |
              
              MR SUBEQU t _flag error flag_ { llvmerror(&@5, "IMAC/IFMAC_MR_Mul flags error! Available flags are B/S/R/I"); clear();YYABORT;}|//niuxx
              MR SUBEQU t _flag imacrealflag flag_ _flag error flag_ { llvmerror(&@8, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
              MR ACC1 t _flag imaccompflag flag_ _flag imacmrasmflags flag_ {$$ = 2; isTnValid = false; } |
              MR ACC1 t _flag imaccompflag flag_ {$$ = 2; isTnValid = false; } |
              
              MR ACC1 t _flag error flag_ { llvmerror(&@5, "IMAC/IFMAC_MR_Mul flags error! Available flags are B/S/R/I"); clear();YYABORT;}|//niuxx
              MR ACC1 t _flag imaccompflag flag_ _flag error flag_ { llvmerror(&@8, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
              MR SUBEQU t _flag imaccompflag flag_ _flag imacmrasmflags flag_ {$$ = 3; isTnValid = false; } |
              MR SUBEQU t _flag imaccompflag flag_ {$$ = 3; isTnValid = false; } |
              
              MR SUBEQU t _flag error flag_ { llvmerror(&@5, "IMAC/IFMAC_MR_Mul flags error! Available flags are B/S/R/I"); clear();YYABORT;}|//niuxx
              MR SUBEQU t _flag imaccompflag flag_ _flag error flag_ { llvmerror(&@8, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
              //yangl: for imac abs()
              MR ACC1 ABS LPAREN t MUL t RPAREN _flag imactriplebswflags flag_ _flag imacflags flag_ {$$ = 0; isIMACABS = true;} |
              MR ACC1 ABS LPAREN t MUL t RPAREN _flag imactriplebswflags flag_ {$$ = 0; isIMACABS = true;} |
              MR SUBEQU ABS LPAREN t MUL t RPAREN _flag imactriplebswflags flag_ _flag imacflags flag_ {$$ = 1; isIMACABS = true;} |
              MR SUBEQU ABS LPAREN t MUL t RPAREN _flag imactriplebswflags flag_ {$$ = 1; isIMACABS = true;} |
              //for tn = 1
              MR ACC1 ABS LPAREN t RPAREN _flag imactriplebswflags flag_ _flag imacflags flag_ {$$ = 0; isTnValid = false; isIMACABS = true; } |
              MR ACC1 ABS LPAREN t RPAREN _flag imactriplebswflags flag_ {$$ = 0; isTnValid = false; isIMACABS = true; } |
              MR SUBEQU ABS LPAREN t RPAREN _flag imactriplebswflags flag_ _flag imacflags flag_ {$$ = 1; isTnValid = false; isIMACABS = true; } |
              MR SUBEQU ABS LPAREN t RPAREN _flag imactriplebswflags flag_ {$$ = 1; isTnValid = false; isIMACABS = true; } ;
//yangl: for imac: MR +=/-= tm*tn
imacmaclause_mr_equ_tm_tn_inside: 
              MR ACC1 t MUL t _flag imacrealflag flag_ _flag imacmrasmflags flag_ {$$ = 0;} |
              MR ACC1 t MUL t _flag imacrealflag flag_ {$$ = 0;} |
              
              MR ACC1 t MUL t _flag imacrealflag flag_ _flag error flag_ { llvmerror(&@10, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
              MR ACC1 t MUL t _flag error flag_ { llvmerror(&@7, "IMAC/IFMAC_MR_Mul flags flags error! Available flags are B/S/R/I"); clear();YYABORT;}|//niuxx
              MR SUBEQU t MUL t _flag imacrealflag flag_ _flag imacmrasmflags flag_ {$$ = 1;} |
              MR SUBEQU t MUL t _flag imacrealflag flag_ {$$ = 1;} |
              
              MR SUBEQU t MUL t _flag imacrealflag flag_ _flag error flag_ { llvmerror(&@10, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
              MR SUBEQU t MUL t _flag error flag_ { llvmerror(&@7, "IMAC/IFMAC_MR_Mul flags error! Available flags are B/S/R/I"); clear();YYABORT;}|//niuxx
              MR ACC1 t MUL t _flag imaccompflag flag_ _flag imacmrasmflags flag_ {$$ = 2;} |
              MR ACC1 t MUL t _flag imaccompflag flag_ {$$ = 2;} |
              
              MR ACC1 t MUL t _flag imaccompflag flag_ _flag error flag_ { llvmerror(&@10, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
              MR ACC1 t MUL t _flag error flag_ { llvmerror(&@7, "IMAC/IFMAC_MR_Mul flags error! Available flags are B/S/R/I"); clear();YYABORT;}|//niuxx
              MR SUBEQU t MUL t _flag imaccompflag flag_ _flag imacmrasmflags flag_ {$$ = 3;} |
              MR SUBEQU t MUL t _flag imaccompflag flag_ {$$ = 3;} |
              
              MR SUBEQU t MUL t _flag imaccompflag flag_ _flag error flag_ { llvmerror(&@10, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
              MR SUBEQU t MUL t _flag error flag_ { llvmerror(&@7, "IMAC/IFMAC_MR_Mul flags error! Available flags are B/S/R/I"); clear();YYABORT;}|//niuxx
              //for tn = 1
              MR ACC1 t _flag imacrealflag flag_ _flag imacmrasmflags flag_ {$$ = 0; isTnValid = false; } |
              MR ACC1 t _flag imacrealflag flag_ {$$ = 0; isTnValid = false; } |
              
              MR ACC1 t _flag imacrealflag flag_ _flag error flag_ { llvmerror(&@8, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
              MR ACC1 t _flag error flag_ { llvmerror(&@5, "IMAC/IFMAC_MR_Mul flags error! Available flags are B/S/R/I"); clear();YYABORT;}|//niuxx
              MR SUBEQU t _flag imacrealflag flag_ _flag imacmrasmflags flag_ {$$ = 1; isTnValid = false; } |
              MR SUBEQU t _flag imacrealflag flag_ {$$ = 1; isTnValid = false; } |
              
              MR SUBEQU t _flag imacrealflag flag_ _flag error flag_ { llvmerror(&@8, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
              MR SUBEQU t _flag error flag_ { llvmerror(&@5, "IMAC/IFMAC_MR_Mul flags error! Available flags are B/S/R/I"); clear();YYABORT;}|//niuxx
              MR ACC1 t _flag imaccompflag flag_ _flag imacmrasmflags flag_ {$$ = 2; isTnValid = false; } |
              MR ACC1 t _flag imaccompflag flag_ {$$ = 2; isTnValid = false; } |
              
              MR ACC1 t _flag imaccompflag flag_ _flag error flag_ { llvmerror(&@8, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
              MR ACC1 t _flag error flag_ { llvmerror(&@5, "IMAC/IFMAC_MR_Mul flags error! Available flags are B/S/R/I"); clear();YYABORT;}|//niuxx
              MR SUBEQU t _flag imaccompflag flag_ _flag imacmrasmflags flag_ {$$ = 3; isTnValid = false; } |
              MR SUBEQU t _flag imaccompflag flag_ {$$ = 3; isTnValid = false; } |
              
              MR SUBEQU t _flag imaccompflag flag_ _flag error flag_ { llvmerror(&@8, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
              MR SUBEQU t _flag error flag_ { llvmerror(&@5, "IMAC/IFMAC_MR_Mul flags error! Available flags are B/S/R/I"); clear();YYABORT;}|//niuxx
              //yangl: for imac abs()
              MR ACC1 ABS LPAREN t MUL t RPAREN _flag imactriplebswflags flag_ _flag imacflags flag_ {$$ = 0; isIMACABS = true;} |
              MR ACC1 ABS LPAREN t MUL t RPAREN _flag imactriplebswflags flag_ {$$ = 0; isIMACABS = true;} |
              
              MR SUBEQU ABS LPAREN t MUL t RPAREN _flag imactriplebswflags flag_ _flag imacflags flag_ {$$ = 1; isIMACABS = true;} |
              MR SUBEQU ABS LPAREN t MUL t RPAREN _flag imactriplebswflags flag_ {$$ = 1; isIMACABS = true;} |
              //for tn = 1
              MR ACC1 ABS LPAREN t RPAREN _flag imactriplebswflags flag_ _flag imacflags flag_ {$$ = 0; isTnValid = false; isIMACABS = true; } |
              MR ACC1 ABS LPAREN t RPAREN _flag imactriplebswflags flag_ {$$ = 0; isTnValid = false; isIMACABS = true; } |
              MR SUBEQU ABS LPAREN t RPAREN _flag imactriplebswflags flag_ _flag imacflags flag_ {$$ = 1; isTnValid = false; isIMACABS = true; } |
              MR SUBEQU ABS LPAREN t RPAREN _flag imactriplebswflags flag_ {$$ = 1; isTnValid = false; isIMACABS = true; } ;
//yangl: for IMAC MulAA: Tp+-Tm* Tm+1+-Tn*Tn-1 -> dest
imacMulAAclause: t ADD t MUL t ADD t MUL t _flag imactriplebswflags flag_ _flag imacmulaaflags flag_ {ImacMulAA_addsub = 0;} |
                 t ADD t MUL t ADD t MUL t _flag imactriplebswflags flag_ {ImacMulAA_addsub = 0;} | 
                 
                 t ADD t MUL t ADD t MUL t _flag imactriplebswflags flag_ _flag error flag_ {llvmerror(&@14, "IMAC/IFMAC_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
                 
                 t ADD t MUL t SUB t MUL t _flag imactriplebswflags flag_ _flag imacmulaaflags flag_ {ImacMulAA_addsub = 1;} |
                 t ADD t MUL t SUB t MUL t _flag imactriplebswflags flag_ {ImacMulAA_addsub = 1;} |  
                 
                 t ADD t MUL t SUB t MUL t _flag imactriplebswflags flag_ _flag error flag_ {llvmerror(&@14, "IMAC/IFMAC_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
                 
                 t SUB t MUL t ADD t MUL t _flag imactriplebswflags flag_ _flag imacmulaaflags flag_ {ImacMulAA_addsub = 2;} |
                 t SUB t MUL t ADD t MUL t _flag imactriplebswflags flag_ {ImacMulAA_addsub = 2;} |
                 
                 t SUB t MUL t ADD t MUL t _flag imactriplebswflags flag_ _flag error flag_ {llvmerror(&@14, "IMAC/IFMAC_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
                 
                 t SUB t MUL t SUB t MUL t _flag imactriplebswflags flag_ _flag imacmulaaflags flag_ {ImacMulAA_addsub = 3;} |
                 t SUB t MUL t SUB t MUL t _flag imactriplebswflags flag_ {ImacMulAA_addsub = 3;} |
                 
                 t SUB t MUL t SUB t MUL t _flag imactriplebswflags flag_ _flag error flag_ {llvmerror(&@14, "IMAC/IFMAC_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
                 //for tp = 0
                 t MUL t ADD t MUL t _flag imactriplebswflags flag_ _flag imacmulaaflags flag_ {ImacMulAA_addsub = 0; isTpValid = false; } |
                 t MUL t ADD t MUL t _flag imactriplebswflags flag_ {ImacMulAA_addsub = 0; isTpValid = false; } | 
                 
                 t MUL t ADD t MUL t _flag imactriplebswflags flag_ _flag error flag_ {llvmerror(&@12, "IMAC/IFMAC_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
                 
                 t MUL t SUB t MUL t _flag imactriplebswflags flag_ _flag imacmulaaflags flag_ {ImacMulAA_addsub = 1; isTpValid = false; } |
                 t MUL t SUB t MUL t _flag imactriplebswflags flag_ {ImacMulAA_addsub = 1; isTpValid = false; } |  
                 
                 t MUL t SUB t MUL t _flag imactriplebswflags flag_ _flag error flag_ {llvmerror(&@12, "IMAC/IFMAC_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
                 
                 SUB t MUL t ADD t MUL t _flag imactriplebswflags flag_ _flag imacmulaaflags flag_ {ImacMulAA_addsub = 2; isTpValid = false; } |
                 SUB t MUL t ADD t MUL t _flag imactriplebswflags flag_ {ImacMulAA_addsub = 2; isTpValid = false; } |  
                 
                 SUB t MUL t ADD t MUL t _flag imactriplebswflags flag_ _flag error flag_ {llvmerror(&@13, "IMAC/IFMAC_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
                              
                 SUB t MUL t SUB t MUL t _flag imactriplebswflags flag_ _flag imacmulaaflags flag_ {ImacMulAA_addsub = 3; isTpValid = false; } |
                 SUB t MUL t SUB t MUL t _flag imactriplebswflags flag_ {ImacMulAA_addsub = 3; isTpValid = false; } |
                 
                 SUB t MUL t SUB t MUL t _flag imactriplebswflags flag_ _flag error flag_ {llvmerror(&@13, "IMAC/IFMAC_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx  
                 //for tp = MR, MR+-Tm* Tm+1+-Tn*Tn-1 -> dest
                 //MR ADD t MUL t ADD t MUL t _flag imactriplebswflags flag_ _flag imacflags flag_ {ImacMulAA_addsub = 0; isTpMR = true;} |
                 //MR ADD t MUL t ADD t MUL t _flag imactriplebswflags flag_ {ImacMulAA_addsub = 0; isTpMR = true;} | 
                 //MR ADD t MUL t SUB t MUL t _flag imactriplebswflags flag_ _flag imacflags flag_ {ImacMulAA_addsub = 1; isTpMR = true;} |
                 //MR ADD t MUL t SUB t MUL t _flag imactriplebswflags flag_ {ImacMulAA_addsub = 1; isTpMR = true;} |     
                 //MR SUB t MUL t ADD t MUL t _flag imactriplebswflags flag_ _flag imacflags flag_ {ImacMulAA_addsub = 2; isTpMR = true;} |
                 //MR SUB t MUL t ADD t MUL t _flag imactriplebswflags flag_ {ImacMulAA_addsub = 2; isTpMR = true;} |     
                 //MR SUB t MUL t SUB t MUL t _flag imactriplebswflags flag_ _flag imacflags flag_ {ImacMulAA_addsub = 3; isTpMR = true;} |
                 //MR SUB t MUL t SUB t MUL t _flag imactriplebswflags flag_ {ImacMulAA_addsub = 3; isTpMR = true;} |
                 //for tp = MR, MR+=/-=Tm* Tm+1+-Tn*Tn-1 -> dest
                 MR ACC1 t MUL t ADD t MUL t _flag imactriplebswflags flag_ _flag imacmulaamrflags flag_ {ImacMulAA_addsub = 0; isTpMR_toMR = true;} |
                 MR ACC1 t MUL t ADD t MUL t _flag imactriplebswflags flag_ {ImacMulAA_addsub = 0; isTpMR_toMR = true;} | 
                 
                 MR ACC1 t MUL t ADD t MUL t _flag imactriplebswflags flag_ _flag error flag_ {llvmerror(&@14, "IMAC/IFMAC_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
                 
                 MR ACC1 t MUL t SUB t MUL t _flag imactriplebswflags flag_ _flag imacmulaamrflags flag_ {ImacMulAA_addsub = 1; isTpMR_toMR = true;} |
                 MR ACC1 t MUL t SUB t MUL t _flag imactriplebswflags flag_ {ImacMulAA_addsub = 1; isTpMR_toMR = true;} |     
                 
                 MR ACC1 t MUL t SUB t MUL t _flag imactriplebswflags flag_ _flag error flag_ {llvmerror(&@14, "IMAC/IFMAC_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
                 
                 MR SUBEQU t MUL t ADD t MUL t _flag imactriplebswflags flag_ _flag imacmulaamrflags flag_ {ImacMulAA_addsub = 2; isTpMR_toMR = true;} |
                 MR SUBEQU t MUL t ADD t MUL t _flag imactriplebswflags flag_ {ImacMulAA_addsub = 2; isTpMR_toMR = true;} |    
                 
                 MR SUBEQU t MUL t ADD t MUL t _flag imactriplebswflags flag_ _flag error flag_ {llvmerror(&@14, "IMAC/IFMAC_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
                 
                 MR SUBEQU t MUL t SUB t MUL t _flag imactriplebswflags flag_ _flag imacmulaamrflags flag_ {ImacMulAA_addsub = 3; isTpMR_toMR = true;} |
                 MR SUBEQU t MUL t SUB t MUL t _flag imactriplebswflags flag_ {ImacMulAA_addsub = 3; isTpMR_toMR = true;} |
                 
                 MR SUBEQU t MUL t SUB t MUL t _flag imactriplebswflags flag_ _flag error flag_ {llvmerror(&@14, "IMAC/IFMAC_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;};//niuxx
//yangl: for IMAC MulAA: MR+=/-=Tm* Tm+1+-Tn*Tn-1, inside                 
imacMulAAclause_inside:
                 MR ACC1 t MUL t ADD t MUL t _flag imactriplebswflags flag_ _flag imacmulaamrflags flag_ {ImacMulAA_addsub = 0; } |//isTpMR_toMR = true;
                 MR ACC1 t MUL t ADD t MUL t _flag imactriplebswflags flag_ {ImacMulAA_addsub = 0; } | //isTpMR_toMR = true;
                 
                 MR ACC1 t MUL t ADD t MUL t _flag imactriplebswflags flag_ _flag error flag_ {llvmerror(&@14, "IMAC/IFMAC_MulAA flags error! Available flags are P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
                 
                 MR ACC1 t MUL t SUB t MUL t _flag imactriplebswflags flag_ _flag imacmulaamrflags flag_ {ImacMulAA_addsub = 1; } |//isTpMR_toMR = true;
                 MR ACC1 t MUL t SUB t MUL t _flag imactriplebswflags flag_ {ImacMulAA_addsub = 1; } |//isTpMR_toMR = true;  
                 
                 MR ACC1 t MUL t SUB t MUL t _flag imactriplebswflags flag_ _flag error flag_ {llvmerror(&@14, "IMAC/IFMAC_MulAA flags error! Available flags are P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
                 
                 MR SUBEQU t MUL t ADD t MUL t _flag imactriplebswflags flag_ _flag imacmulaamrflags flag_ {ImacMulAA_addsub = 2;} |// isTpMR_toMR = true;
                 MR SUBEQU t MUL t ADD t MUL t _flag imactriplebswflags flag_ {ImacMulAA_addsub = 2;} |// isTpMR_toMR = true;  
                 
                 MR SUBEQU t MUL t ADD t MUL t _flag imactriplebswflags flag_ _flag error flag_ {llvmerror(&@14, "IMAC/IFMAC_MulAA flags error! Available flags are P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
                 
                 MR SUBEQU t MUL t SUB t MUL t _flag imactriplebswflags flag_ _flag imacmulaamrflags flag_ {ImacMulAA_addsub = 3;} |// isTpMR_toMR = true;
                 MR SUBEQU t MUL t SUB t MUL t _flag imactriplebswflags flag_ {ImacMulAA_addsub = 3; } |//isTpMR_toMR = true;
                 
                 MR SUBEQU t MUL t SUB t MUL t _flag imactriplebswflags flag_ _flag error flag_ {llvmerror(&@14, "IMAC/IFMAC_MulAA flags error! Available flags are P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;};//niuxx
//ducx 20180310
imacMulVTnclause:t ADD t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ _flag imacmul5_mul6flags flag_ {ImacMulAA_addsub = 0;imm = OPERAND(Imm, $9, @9.S, @9.E);} |
                 t ADD t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ {ImacMulAA_addsub = 0;imm = OPERAND(Imm, $9, @9.S, @9.E);} | 
                 
                 t ADD t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ _flag error flag_ {llvmerror(&@16, "IMAC/IFMAC_Mul flags error! Available flags are P,C,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
                 
                 t SUB t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ _flag imacmul5_mul6flags flag_ {ImacMulAA_addsub = 1;imm = OPERAND(Imm, $9, @9.S, @9.E);} |
                 t SUB t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ {ImacMulAA_addsub = 1;imm = OPERAND(Imm, $9, @9.S, @9.E);} |     
                   
                 t SUB t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ _flag error flag_ {llvmerror(&@16, "IMAC/IFMAC_Mul flags error! Available flags are P,C,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
                   //for tp = 0
                 t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ _flag imacmul5_mul6flags flag_ {ImacMulAA_addsub = 0; isTpValid = false;imm = OPERAND(Imm, $7, @7.S, @7.E);  } |
                 t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ {ImacMulAA_addsub = 0; isTpValid = false;imm = OPERAND(Imm, $7, @7.S, @7.E);  } | 
                 
                 t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ _flag error flag_ {llvmerror(&@14, "IMAC/IFMAC_Mul flags error! Available flags are P,C,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
                 
                 SUB t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ _flag imacmul5_mul6flags flag_ {ImacMulAA_addsub = 1; isTpValid = false; imm = OPERAND(Imm, $7, @7.S, @7.E); } |
                 SUB t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ {ImacMulAA_addsub = 1; isTpValid = false;imm = OPERAND(Imm, $7, @7.S, @7.E);  } |    
                 
                 SUB t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ _flag error flag_ {llvmerror(&@15, "IMAC/IFMAC_Mul flags error! Available flags are P,C,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
                 
                    //for tp = MR, MR+-Tm* V(Tn[k]) -> dest  
                 MR ADD t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ _flag imacmul7flags flag_ {ImacMulAA_addsub = 0; isTpMR = true;imm = OPERAND(Imm, $9, @9.S, @9.E);} |
                 MR ADD t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ {ImacMulAA_addsub = 0; isTpMR = true;imm = OPERAND(Imm, $9, @9.S, @9.E);} | 
                 
                 MR ADD t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ _flag error flag_ {llvmerror(&@16, "IMAC/IFMAC_Mul flags error! Available flags are P,C,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
                 
                 MR SUB t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ _flag imacmul7flags flag_ {ImacMulAA_addsub = 1; isTpMR = true;imm = OPERAND(Imm, $9, @9.S, @9.E);} |
                 MR SUB t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ {ImacMulAA_addsub = 1; isTpMR = true;imm = OPERAND(Imm, $9, @9.S, @9.E);} |  
                 
                 MR SUB t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ _flag error flag_ {llvmerror(&@16, "IMAC/IFMAC_Mul flags error! Available flags are P,C,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
                   //for tp = MR, MR+=/-=Tm* V(Tn[k]) -> dest
                 MR ACC1 t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ _flag imacmul7flags flag_ {ImacMulAA_addsub = 0; isTpMR_toMR = true;imm = OPERAND(Imm, $9, @9.S, @9.E);} |
                 MR ACC1 t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ {ImacMulAA_addsub = 0; isTpMR_toMR = true;imm = OPERAND(Imm, $9, @9.S, @9.E);} | 
                 
                 MR ACC1 t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ _flag error flag_ {llvmerror(&@16, "IMAC/IFMAC_Mul flags error! Available flags are P,C,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
                 MR SUBEQU t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ _flag imacmul7flags flag_ {ImacMulAA_addsub = 1; isTpMR_toMR = true;imm = OPERAND(Imm, $9, @9.S, @9.E);} |
                 MR SUBEQU t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ {ImacMulAA_addsub = 1; isTpMR_toMR = true;imm = OPERAND(Imm, $9, @9.S, @9.E);} |
                 
                 MR SUBEQU t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ _flag error flag_ {llvmerror(&@16, "IMAC/IFMAC_Mul flags error! Available flags are P,C,ShiftMode0/1/2/3"); clear();YYABORT;};//niuxx
//ducx: for IMAC MulVTn: MR+=/-=Tm* V(Tn[k]), inside                
imacMulVTnclause_inside:
                 MR ACC1 t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ _flag imacmul7flags flag_ {ImacMulAA_addsub = 0; isTpMR_toMR = true;imm = OPERAND(Imm, $9, @9.S, @9.E);} |
                 
                 MR ACC1 t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ _flag error flag_ {llvmerror(&@16, "IMAC/IFMAC_Mul flags error! Available flags are P,C,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
                 MR ACC1 t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ {ImacMulAA_addsub = 0; isTpMR_toMR = true;imm = OPERAND(Imm, $9, @9.S, @9.E);} | 
                 MR SUBEQU t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ _flag imacmul7flags flag_ {ImacMulAA_addsub = 1; isTpMR_toMR = true;imm = OPERAND(Imm, $9, @9.S, @9.E);} |
                 MR SUBEQU t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ {ImacMulAA_addsub = 1; isTpMR_toMR = true;imm = OPERAND(Imm, $9, @9.S, @9.E);} |     
   
                 MR SUBEQU t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imactriplebswflags flag_ _flag error flag_ {llvmerror(&@16, "IMAC/IFMAC_Mul flags error! Available flags are P,C,ShiftMode0/1/2/3"); clear();YYABORT;};//niuxx
//yangl: for IMAC MulAV: tp + tm*V(tl[k])+Tn*VPLUS('B|S')({L,P,T,F,shiftMode0|1|2|3})({!}Mode0|1) -> dest 
imacMulAVclause: t ADD t MUL V _flag t LBRACKET imm5 RBRACKET flag_  ADD  t MUL VPLUS _flag imacrealflag flag_ _flag imacmulavflags flag_ {imm = OPERAND(Imm, $9, @9.S, @9.E);} |
                 t ADD t MUL V _flag t LBRACKET imm5 RBRACKET flag_  ADD  t MUL VPLUS _flag imacrealflag flag_ {imm = OPERAND(Imm, $9, @9.S, @9.E);} |
                                  
                 t ADD t MUL V _flag t LBRACKET imm5 RBRACKET flag_  ADD  t MUL VPLUS _flag imacrealflag flag_ _flag error flag_ {llvmerror(&@20, "IMAC/IFMAC_MulAV flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
                 //for tp = 0
                 t MUL V _flag t LBRACKET imm5 RBRACKET flag_  ADD  t MUL VPLUS _flag imacrealflag flag_ _flag imacmulavflags flag_ {imm = OPERAND(Imm, $7, @7.S, @7.E); isTpValid = false;} |
                 t MUL V _flag t LBRACKET imm5 RBRACKET flag_  ADD  t MUL VPLUS _flag imacrealflag flag_ {imm = OPERAND(Imm, $7, @7.S, @7.E); isTpValid = false;} |
                 
                 t MUL V _flag t LBRACKET imm5 RBRACKET flag_  ADD  t MUL VPLUS _flag imacrealflag flag_ _flag error flag_ {llvmerror(&@18, "IMAC/IFMAC_MulAV flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}|//niuxx
                //for tp = MR
                 MR ACC1 t MUL V _flag t LBRACKET imm5 RBRACKET flag_  ADD  t MUL VPLUS _flag imacrealflag flag_ _flag imacmulavmrflags flag_ {imm = OPERAND(Imm, $9, @9.S, @9.E);isTpMR = true;} |
                 MR ACC1 t MUL V _flag t LBRACKET imm5 RBRACKET flag_  ADD  t MUL VPLUS _flag imacrealflag flag_ {imm = OPERAND(Imm, $9, @9.S, @9.E);isTpMR = true;} |
                 
                 MR ACC1 t MUL V _flag t LBRACKET imm5 RBRACKET flag_  ADD  t MUL VPLUS _flag imacrealflag flag_ _flag error flag_ {llvmerror(&@20, "IMAC/IFMAC_MulAV flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;};//niuxx
//yangl: for IMAC MulAV: MR += tm*V(tl[k])+Tn*VPLUS('B|S')({L,P,T,F,shiftMode0|1|2|3})({!}Mode0|1), inside
imacMulAVclause_inside:
                 MR ACC1 t MUL V _flag t LBRACKET imm5 RBRACKET flag_  ADD  t MUL VPLUS _flag imacrealflag flag_ _flag imacmulavmrflags flag_ {imm = OPERAND(Imm, $9, @9.S, @9.E); isTpMR = true;} |
                 MR ACC1 t MUL V _flag t LBRACKET imm5 RBRACKET flag_  ADD  t MUL VPLUS _flag imacrealflag flag_ {imm = OPERAND(Imm, $9, @9.S, @9.E); isTpMR = true;}|   
                 
                 MR ACC1 t MUL V _flag t LBRACKET imm5 RBRACKET flag_  ADD  t MUL VPLUS _flag imacrealflag flag_ _flag error flag_ {llvmerror(&@20, "IMAC/IFMAC_MulAV flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;};//niuxx
                              
imacflagclause: FLAG _flag N flag_     {$$ = 0;} |
                FLAG _flag CFLAG flag_ {$$ = 1;} |
                FLAG _flag V flag_     {$$ = 2;} |
                FLAG _flag A flag_     {$$ = 3;} ;
imacwaitclause: WAIT IMM5 {f = OPERAND(Imm, $2, FlagS, FlagE);};
imacsetcond: IMMSYM DOT IMM5 ASSIGNTO IMAC DOT SETCOND LBRACKET IMM5 RBRACKET 
	           {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $9, @9.S, @9.E);}; 

TpToMRInstr:t _flag imacrealflag flag_ _flag imacsendmr_selflags flag_ | 
            t _flag imacrealflag flag_ |
            
            t _flag imacrealflag flag_ _flag error flag_ {llvmerror(&@6, "IMAC/IFMAC_SendMR flags error! Available flags are L,A"); clear();YYABORT;};//niuxx
            
imacSelTpMRclause: SEL LPAREN t COMMA MR RPAREN _flag imacrealflag flag_ _flag imachlflag flag_ _flag imacsendmr_selflags flag_ |
                   SEL LPAREN t COMMA MR RPAREN _flag imacrealflag flag_ _flag imachlflag flag_ |
                   
		   SEL LPAREN t COMMA MR RPAREN _flag imacrealflag flag_ _flag imachlflag flag_ _flag error flag_ {llvmerror(&@14, "IMAC/IFMAC_Sel flags error! Available flags are L,A"); clear();YYABORT;}|//niuxx
		   SEL LPAREN t COMMA MR RPAREN _flag imacrealflag flag_ _flag error flag_ _flag  {llvmerror(&@11, "IMAC/IFMAC_Sel flags error! Available flags are HH/HL/LL"); clear();YYABORT;};//niuxx

imacsetshiftclause:SETSM DOT t {
		    $$ = 0; 
		    if($3 > 5)
		      {llvmerror(&@3, "Incorrect IMAC/IFMAC_SetSM inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu
		    } |
                   SETSM DOT IMM5 {$$ = 1; imm = OPERAND(Imm, $3, FlagS, FlagE);};

imacshiftmodeoption:SHIFTMODE0 {f = OPERAND(Imm, 0, FlagS, FlagE);} |
                    SHIFTMODE1 {f = OPERAND(Imm, 1, FlagS, FlagE);} |
                    SHIFTMODE2 {f = OPERAND(Imm, 2, FlagS, FlagE);} |
                    SHIFTMODE3 {f = OPERAND(Imm, 3, FlagS, FlagE);} ;
/* start imac triple */
imactripleclause: /*imactripleclause_ | */ imactripleclause_ imactripleflags;

imactripleclause_: t TRIPLE _flag t COLON t flag_ ;//|
//                   t TRIPLE _flag NOT2 t COLON t flag_  { flags.set(NOT1F); } |
//                   t TRIPLE _flag t COLON NOT2 t flag_  { flags.set(NOT2F); } |
//                   t TRIPLE _flag NOT2 t COLON NOT2 t flag_  { flags.set(NOT1F); flags.set(NOT2F); };
                 
imactripleflags: LPAREN imactriplebsflags RPAREN LPAREN ALL RPAREN { flags.set(ALLF); }|
		 LPAREN error RPAREN LPAREN ALL RPAREN {llvmerror(&@2, "IMAC/IFMAC_Triple flags error! Available flags are B/S"); clear();YYABORT;}|//niuxx

		 LPAREN ALL RPAREN LPAREN imactriplebsflags RPAREN  { flags.set(ALLF); }| //niuxu
		 
		 LPAREN ALL RPAREN LPAREN error RPAREN {llvmerror(&@5, "IMAC/IFMAC_Triple flags error! Available flags are B/S"); clear();YYABORT;}|//niuxx
//                 LPAREN ALL RPAREN { flags.set(ALLF); }|
                 LPAREN imactriplebsflags RPAREN |
                 LPAREN error RPAREN {llvmerror(&@2, "IMAC/IFMAC_Triple flags error! Available flags are B/S"); clear();YYABORT;}|//niuxx

imactriplebswflags: B { flags.set(BF); }|
                    S { flags.set(SF); }|
                    W { flags.set(WF); };
                    
imactriplebsflags: B { flags.set(BF); }|
                   S { flags.set(SF); };
                    
imactreadmrholflags:   H { flags.set(HF); }|
                       L { flags.set(LF); }|
                       O { flags.set(OF); };                    
/* end imac triple */	          

//ducx 20180130
imacASdest: IMAC DOT t{
	     $$ = 0;
	     if($3 > 5)
		  {llvmerror(&@3, "Incorrect IMAC inst! IMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	    }   
          | mindexn AND IALU DOT t{
	    $$ = 1; 
	    ImacToialu_flag = 1;
	    if($5 > 5)
		  {llvmerror(&@3, "Incorrect IMAC inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
          }
          | mindexn AND SHU0 DOT t {$$ = 1; ImacToialu_flag = 0;}
          | mindexsia AND IALU DOT t{
          $$ = 2; 
          ImacToialu_flag = 1;
          if($5 > 5)
		  {llvmerror(&@3, "Incorrect IMAC inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
          }
          | mindexsia AND SHU0 DOT t{$$ = 2; ImacToialu_flag = 0;}
          | mindexdis AND IALU DOT t{
          $$ = 3; 
          ImacToialu_flag = 1;
           if($5 > 5)
		  {llvmerror(&@3, "Incorrect IMAC inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
          } 
          | mindexdis AND SHU0 DOT t{$$ = 3; ImacToialu_flag = 0;} 
          | _IMAC DOT t {llvmerror(&@1, "IMAC dest error!"); clear();YYABORT;}
          | IFMAC DOT t {llvmerror(&@1, "IMAC dest error!"); clear();YYABORT;}
          | _IFMAC DOT t {llvmerror(&@1, "IMAC dest error!"); clear();YYABORT;};

//imacdest: ialudest;
imacdest: shut {$$ = 0; imac_additional_dest = 0;} 
          | maccdest {$$ = 1; imac_additional_dest = 0;}    
          | mindexn {$$ = 3; imac_additional_dest = 0;}
          | mindexsia {$$ = 4; imac_additional_dest = 0;}
          | mindexdis {$$ = 5; imac_additional_dest = 0;} 
          | imacbiut0{$$ = 6; imac_additional_dest = 0;}
          | imacbiut1{$$ = 7; imac_additional_dest = 0;}
          | imacbiut2{$$ = 8; imac_additional_dest = 0;};

          

          
imacdest: IMAC DOT t AND imacdest {	
            $$ = $5;  
            //isIMACDoubleDest = true;
            if($3 == 0) //additional T0
              imac_additional_dest = 1; 
            else if($3 == 1) //additional T1
              imac_additional_dest = 2; 
            else if($3 == 2) //additional T2
              imac_additional_dest = 3; 
            else if($3 == 3) //additional T3
              imac_additional_dest = 4; 
            else if($3 == 4) //additional T4
              imac_additional_dest = 5; 
            else if($3 == 5) //additional T5
              imac_additional_dest = 6;   
            else 
	      {llvmerror(&@3, "Incorrect IMAC inst! IMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
          } 
         | _IMAC DOT t{
	      $$ = 9;
	      /*if(isIMACDoubleDest == true)
		  {llvmerror(&@1, "IMAC dest error!"); clear();YYABORT;}//niuxu*/
	      if($3 == 0) //additional T0
		imac_additional_dest = 14; 
	      else if($3 == 1) //additional T1
		imac_additional_dest = 17; 
	      else if($3 == 2) //additional T2
		imac_additional_dest = 18; 
	      else if($3 == 3) //additional T3
		imac_additional_dest = 15; 
	      else if($3 == 4) //additional T4
		imac_additional_dest = 19; 
	      else if($3 == 5) //additional T5
		imac_additional_dest = 20; 
	      else 
		{llvmerror(&@3, "Incorrect IMAC inst! _IMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu   
	    }
          | IMAC DOT t AND IMAC { llvmerror(&@1, "IMAC dest error!"); clear();YYABORT;}//niuxu
          | IMAC DOT MR AND imacdest {imac_additional_dest = 13; $$ = $5; }
          | IMAC DOT t AND MR {
              $$ = 9;        
            if($3 == 0) //additional T0
              imac_additional_dest = 7; 
            else if($3 == 1) //additional T1
              imac_additional_dest = 8; 
            else if($3 == 2) //additional T2
              imac_additional_dest = 9; 
            else if($3 == 3) //additional T3
              imac_additional_dest = 10; 
            else if($3 == 4) //additional T4
              imac_additional_dest = 11; 
            else if($3 == 5) //additional T5
              imac_additional_dest = 12;  
            else  
              {llvmerror(&@3, "Incorrect IMAC inst! IMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
            }  
            | _IMAC DOT MR{$$ = 9;imac_additional_dest = 16; }

	    | IMAC DOT t { llvmerror(&@1, "IMAC dest error!"); clear();YYABORT;}//niuxx  
	    | IMAC DOT MR { llvmerror(&@1, "IMAC dest error!"); clear();YYABORT;}|//niuxx
	    | _IFMAC DOT t {llvmerror(&@1, "IMAC dest error!"); clear();YYABORT;};//niuxx
// end imac --------------------------------------------------


//yangl start IFMAC

ifmacslot: IFMAC DOT error { llvmerror(&@1, "Incorrect IFMAC inst."); clear();YYABORT;} ;

ifmacslot: IFMAC DOT ifmacinst
| IFMAC DOT ifmac_imacinst 
| ifmacsetcond {
  isSetCond = true;
  ADDOPERAND(Opc, UCPM::IFMACSetCond, @$.S, @$.E);
  Operands.push_back(nullptr);
  condpos = Operands.size();
  if (imm == NULL)
    ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
  else
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
  if (imm1 == NULL)
    ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
  else
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));   
};

ifmac_imacinst:
//ducx IFMAC Turbo
// imacturboclause ASSIGNTO ifmacdest {
//       flagsort = flags[HF];
//       f = OPERAND(Imm, flagsort, FlagS, FlagE); 
// 
//       
//   switch ($3){
//     case 0://to shu
//       ADDOPERAND(Opc, UCPM::IFMACTurboToSHU, @$.S, @$.E); 
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
//       Operands.push_back(nullptr);
//       condpos = Operands.size();
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
//       goto ifmacturboBIU_add;
//       break;
// 
//     case 1://to macc
//       ADDOPERAND(Opc, UCPM::IFMACTurboToMACC, @$.S, @$.E); 
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
//       Operands.push_back(nullptr);
//       condpos = Operands.size();     
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
//       goto ifmacturboBIU_add;
//       break;
//     case 3://to m[t]
//       ADDOPERAND(Opc, UCPM::IFMACTurboToM, @$.S, @$.E);
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
//       Operands.push_back(nullptr);
//       condpos = Operands.size();
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
//       goto ifmacturboBIU_add;
//       break;
//          
//     case 4://to m[s++/i++/a++]
//       flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
//       sia = OPERAND(Imm, flagsort, FlagS, FlagE);
//       flags.reset();
//       ADDOPERAND(Opc, UCPM::IFMACTurboToMSIA, @$.S, @$.E); 
//       Operands.push_back(nullptr);
//       condpos = Operands.size();
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia)); 
//       goto ifmacturboBIU_add;
//       break;
//     case 5://to m[dis{shift}]
//       flagsort = flags[SHIFTF];
//       dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
//       flags.reset();
//       ADDOPERAND(Opc, UCPM::IFMACTurboToMDis, @$.S, @$.E);         
//       Operands.push_back(nullptr);
//       condpos = Operands.size();
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis)); 
//       goto ifmacturboBIU_add;
//       break;
//       
//     case 6://to biu0  
//       ADDOPERAND(Opc, UCPM::IFMACTurboToBIU0, @$.S, @$.E); goto ifmacturboBIU;  
//     case 7://to biu1  
//       ADDOPERAND(Opc, UCPM::IFMACTurboToBIU1, @$.S, @$.E); goto ifmacturboBIU;      
//     case 8://to biu2  
//       ADDOPERAND(Opc, UCPM::IFMACTurboToBIU2, @$.S, @$.E); goto ifmacturboBIU;  
//       
//     case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
//       ADDOPERAND(Opc, UCPM::IFMACTurboToBIU2, @$.S, @$.E);
//       if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
//           ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
//       else if(imac_additional_dest >= 17 && imac_additional_dest <= 20)// _IMAC.T1/T2/T4/T5
//           ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
//       else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
// 	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
//       Operands.push_back(nullptr);
//       condpos = Operands.size();
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
//       goto ifmacturboBIU_add;
//       break;
//       
// ifmacturboBIU:  
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
//       Operands.push_back(nullptr);
//       condpos = Operands.size();
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
//       Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
// ifmacturboBIU_add:      
//       //deal with additional dest
//       switch (imac_additional_dest) {
//         case 0:
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
//           break;        
//         case 1: //_IMAC.T0 AND imacdest
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
//           break;
//         case 2://_IMAC.T1 AND imacdest
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
//           break;
//         case 3://_IMAC.T2 AND imacdest
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
//           break;        
//         case 4://_IMAC.T3 AND imacdest
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
//           break;        
//         case 5://_IMAC.T4 AND imacdest
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
//           break; 
//         case 6://_IMAC.T5 AND imacdest
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
//           break;
//         case 7:// _IMAC.T0 AND MR
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
//           break;
//         case 8:// _IMAC.T1 AND MR
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
//           break;
//         case 9:// _IMAC.T2 AND MR
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
//           break;
//         case 10:// _IMAC.T3 AND MR
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
//           break;
//         case 11:// _IMAC.T4 AND MR
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
//           break;
//         case 12:// _IMAC.T5 AND MR
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
//           break;
//         case 13://_IMAC.MR AND imacdest
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
//           break; 
//         case 14://_IMAC.T0
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
//           break; 
//         case 15://_IMAC.T3
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
//           break; 
//         case 16://_IMAC.MR
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
//           break; 
//         case 17://_IMAC.T1
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
//           break; 
//         case 18://_IMAC.T2
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
//           break; 
//         case 19://_IMAC.T4
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
//           break; 
//         case 20://_IMAC.T5
//           ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
//           break; 
//         default:
//           llvmerror(&@3, "ifmac additional dest error!"); clear();YYABORT;
//           break;
//       }
//       break;
//       
//     default:
//       llvmerror(&@3, "ifmac turbo dest error!"); clear();YYABORT;
//       break;      
//   }
//       
//       flags.reset();
// 
// }//end IFMAC Turbo
// | //ducx IFMAC Turbo1
imacturbo1clause ASSIGNTO ifmacdest {
      flagsort = (flags[AF] << 1) | flags[HF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE); 

      
  switch ($3){
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFMACTurbo1ToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      goto ifmacturbo1BIU_add;
      break;

    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFMACTurbo1ToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();     
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      goto ifmacturbo1BIU_add;
      break;
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFMACTurbo1ToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      goto ifmacturbo1BIU_add;
      break;
         
    case 4://to m[s++/i++/a++]
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();
      ADDOPERAND(Opc, UCPM::IFMACTurbo1ToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia)); 
      goto ifmacturbo1BIU_add;
      break;
    case 5://to m[dis{shift}]
      flagsort = flags[SHIFTF];
      dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
      flags.reset();
      ADDOPERAND(Opc, UCPM::IFMACTurbo1ToMDis, @$.S, @$.E);         
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis)); 
      goto ifmacturbo1BIU_add;
      break;
      
    case 6://to biu0  
      ADDOPERAND(Opc, UCPM::IFMACTurbo1ToBIU0, @$.S, @$.E); goto ifmacturbo1BIU;  
    case 7://to biu1  
      ADDOPERAND(Opc, UCPM::IFMACTurbo1ToBIU1, @$.S, @$.E); goto ifmacturbo1BIU;      
    case 8://to biu2  
      ADDOPERAND(Opc, UCPM::IFMACTurbo1ToBIU2, @$.S, @$.E); goto ifmacturbo1BIU;  
      
    case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      ADDOPERAND(Opc, UCPM::IFMACTurbo1ToBIU2, @$.S, @$.E);
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      goto ifmacturbo1BIU_add;
      break;
      
ifmacturbo1BIU:  
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
ifmacturbo1BIU_add:      
      //deal with additional dest
      switch (imac_additional_dest) {
        case 0:
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;        
        case 1: //_IMAC.T0 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@3, "ifmac additional dest error!"); clear();YYABORT;
          break;
      }
      break;
      
    default:
      llvmerror(&@3, "ifmac turbo1 dest error!"); clear();YYABORT;
      break;      
  }
      
      flags.reset();

}//end IFMAC Turbo1
| //ducx IFMAC Turbo2
imacturbo2clause ASSIGNTO ifmacdest {
      flagsort = flags[AF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE); 

      
  switch ($3){
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFMACTurbo2ToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      goto ifmacturbo2BIU_add;
      break;

    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFMACTurbo2ToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();     
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      goto ifmacturbo2BIU_add;
      break;
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFMACTurbo2ToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      goto ifmacturbo2BIU_add;
      break;
         
    case 4://to m[s++/i++/a++]
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();
      ADDOPERAND(Opc, UCPM::IFMACTurbo2ToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia)); 
      goto ifmacturbo2BIU_add;
      break;
    case 5://to m[dis{shift}]
      flagsort = flags[SHIFTF];
      dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
      flags.reset();
      ADDOPERAND(Opc, UCPM::IFMACTurbo2ToMDis, @$.S, @$.E);         
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis)); 
      goto ifmacturbo2BIU_add;
      break;
      
    case 6://to biu0  
      ADDOPERAND(Opc, UCPM::IFMACTurbo2ToBIU0, @$.S, @$.E); goto ifmacturbo2BIU;  
    case 7://to biu1  
      ADDOPERAND(Opc, UCPM::IFMACTurbo2ToBIU1, @$.S, @$.E); goto ifmacturbo2BIU;      
    case 8://to biu2  
      ADDOPERAND(Opc, UCPM::IFMACTurbo2ToBIU2, @$.S, @$.E); goto ifmacturbo2BIU;  
      
    case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      ADDOPERAND(Opc, UCPM::IFMACTurbo2ToBIU2, @$.S, @$.E);
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      goto ifmacturbo2BIU_add;
      break;
      
ifmacturbo2BIU:  
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));    
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
ifmacturbo2BIU_add:      
      //deal with additional dest
      switch (imac_additional_dest) {
        case 0:
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;        
        case 1: //_IMAC.T0 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@3, "ifmac additional dest error!"); clear();YYABORT;
          break;
      }
      break;
      
    default:
      llvmerror(&@3, "ifmac turbo2 dest error!"); clear();YYABORT;
      break;      
  }
      
      flags.reset();

}//end IFMAC Turbo2
| imaclogicclause ASSIGNTO ifmacdest {
      if(unit4 != NULL)//niuxx
      {
	switch(unit4->getReg())
	{
	  case UCPMReg::IMACIMAC :      //IMAC->_IMAC
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFMAC_Logic inst! IMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	  /*case UCPMReg::IMACIFMAC :    //IMAC->IFMAC
	    if(ut->getReg() > UCPMReg::T5)
	     {llvmerror(&@3, "Incorrect IFMAC_Logic inst! _IFMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu*/
	  break;
	  case UCPMReg::IMACIALU :	//IMAC->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFMAC_Logic inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu  
	  case UCPMReg::IMACIFALU :    //IMAC->IFALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFMAC_Logic inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  
      
      if ($1 == 3)
      {
	if(tm->getReg() > UCPMReg::T5)
	  {llvmerror(&@1, "Incorrect IFMAC_Logic inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu      
      }
      else
      {
	if(tm->getReg() > UCPMReg::T5)
	  {llvmerror(&@1, "Incorrect IFMAC_Logic inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
	if(tn->getReg() > UCPMReg::T5)
	  {llvmerror(&@1, "Incorrect IFMAC_Logic inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu      
      }


  switch ($3){
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFMACLogicToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));    
      switch ($1) {
        case 0:   
        case 1:
        case 2:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
          break;
        case 3:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt)); //a reserved T
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's tn
          break;
        default:
          llvmerror(&@1, "ifmac logic clause error!"); clear();YYABORT;
          break; 
      }
      goto ifmaclogicBIU_add;
      break;

    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFMACLogicToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();     
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));    
      switch ($1) {
        case 0:   
        case 1:
        case 2:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
          break;
        case 3:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt)); //a reserved T
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's tn
          break;
        default:
          llvmerror(&@1, "ifmac logic clause error!");  clear();YYABORT;
          break; 
      }
      goto ifmaclogicBIU_add;
      break;
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFMACLogicToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));     
      switch ($1) {
        case 0:   
        case 1:
        case 2:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
          break;
        case 3:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt)); //a reserved T
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's tn
          break;
        default:
          llvmerror(&@1, "ifmac logic clause error!");  clear();YYABORT;
          break; 
      }
      goto ifmaclogicBIU_add;
      break;
         
    case 4://to m[s++/i++/a++]
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();
      ADDOPERAND(Opc, UCPM::IFMACLogicToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));     
      switch ($1) {
        case 0:   
        case 1:
        case 2:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
          break;
        case 3:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt)); //a reserved T
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's tn
          break;
        default:
          llvmerror(&@1, "ifmac logic clause error!");  clear();YYABORT;
          break; 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia)); 
      goto ifmaclogicBIU_add;
      break;
    case 5://to m[dis{shift}]
      flagsort = flags[SHIFTF];
      dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
      flags.reset();
      ADDOPERAND(Opc, UCPM::IFMACLogicToMDis, @$.S, @$.E);         
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      switch ($1) {
        case 0:   
        case 1:
        case 2:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
          break;
        case 3:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt)); //a reserved T
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's tn
          break;
        default:
          llvmerror(&@1, "ifmac logic clause error!");  clear();YYABORT;
          break; 
      }           
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis)); 
      goto ifmaclogicBIU_add;
      break;
      
    case 6://to biu0  
      ADDOPERAND(Opc, UCPM::IFMACLogicToBIU0, @$.S, @$.E); goto ifmaclogicBIU;  
    case 7://to biu1  
      ADDOPERAND(Opc, UCPM::IFMACLogicToBIU1, @$.S, @$.E); goto ifmaclogicBIU;      
    case 8://to biu2  
      ADDOPERAND(Opc, UCPM::IFMACLogicToBIU2, @$.S, @$.E); goto ifmaclogicBIU;  
      
    case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      ADDOPERAND(Opc, UCPM::IFMACLogicToBIU2, @$.S, @$.E);
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));    
      switch ($1) {
        case 0:   
        case 1:
        case 2:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
          break;
        case 3:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt)); //a reserved T
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's tn
          break;
        default:
          llvmerror(&@1, "ifmac logic clause error!");  clear();YYABORT;
          break; 
      }
      goto ifmaclogicBIU_add;
      break;
      
ifmaclogicBIU:  

      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));    
      switch ($1) {
        case 0:   
        case 1:
        case 2:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
          break;
        case 3:
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt)); //a reserved T
          Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's tn
          break;
        default:
          llvmerror(&@1, "ifmac logic clause error!");  clear();YYABORT;
          break; 
      }
ifmaclogicBIU_add:      
      //deal with additional dest
      switch (imac_additional_dest) {
        case 0:
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;        
        case 1: //_IMAC.T0 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@3, "ifmac additional dest error!");  clear();YYABORT;
          break;
      }
      break;
      
    default:
      llvmerror(&@3, "ifmac dest error!");  clear();YYABORT;
      break;      
  }
}//end IMAC Logic
|
//yangl: UCP_M, start IMAC RWFlag
imacreadflagclause ASSIGNTO ifmacdest {
//original code:  28  27  26  25  24:23  22  21  20:18  17:15  14:12  11
//f in my def:    14  13  12  11  10-9   8   7   6-4    3-1            0
     if(unit4 != NULL)//niuxx
      {
	switch(unit4->getReg())
	{
	  case UCPMReg::IMACIMAC :      //IMAC->_IMAC
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFMAC_ReadFlag inst! IMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	  /*case UCPMReg::IMACIFMAC :    //IMAC->IFMAC
	    if(ut->getReg() > UCPMReg::T5)
	     {llvmerror(&@3, "Incorrect IFMAC_Logic inst! _IFMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu*/
	  break;
	  case UCPMReg::IMACIALU :	//IMAC->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFMAC_ReadFlag inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu  
	  case UCPMReg::IMACIFALU :    //IMAC->IFALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFMAC_ReadFlag inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  


  flagsort = (flags[NF] << 13) | (flags[CF] << 12) | (flags[VF] << 11) | (flags[MCF] << 8) | (flags[MVF] << 7) 
                              | (0x1 << 6) | (0x1 << 5) | (0x1 << 4) | (flags[TF] << 3) | (flags[LSF] << 2) 
                              | (flags[ERASEF]);  
  
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
  sia = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = flags[SHIFTF];
  dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
  
  flags.reset();
  
  switch ($3){
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFMACFlagToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E); 
      goto ifmacrwflagBIU_add;
      break;
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFMACFlagToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();     
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      goto ifmacrwflagBIU_add;
      break;
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFMACFlagToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      goto ifmacrwflagBIU_add;
      break;     
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFMACFlagToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      goto ifmacrwflagBIU_add;
      break;
    case 5://to m[dis{shift}]  
      ADDOPERAND(Opc, UCPM::IFMACFlagToMDis, @$.S, @$.E);         
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      goto ifmacrwflagBIU_add;
      break;
      
    case 6://to biu0  
      ADDOPERAND(Opc, UCPM::IFMACFlagToBIU0, @$.S, @$.E); goto ifmacrwflagBIU;  
    case 7://to biu1  
      ADDOPERAND(Opc, UCPM::IFMACFlagToBIU1, @$.S, @$.E); goto ifmacrwflagBIU;      
    case 8://to biu2  
      ADDOPERAND(Opc, UCPM::IFMACFlagToBIU2, @$.S, @$.E); goto ifmacrwflagBIU;  
  
  
  case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      ADDOPERAND(Opc, UCPM::IFMACFlagToBIU2, @$.S, @$.E);
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      goto ifmacrwflagBIU_add;
      break;
      
ifmacrwflagBIU:      

      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      
ifmacrwflagBIU_add:
//deal with additional dest
  switch (imac_additional_dest) {
        case 0:
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;        
        case 1: //_IMAC.T0 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@3, "ifmac additional dest error!");  clear();YYABORT;
          break;
      }
      break;
      
    default:
      llvmerror(&@3, "ifmac dest error!");  clear();YYABORT;
      break;      
  }
}
|
ifmacwriteflagclause {
//original code:  28  27  26  25  24:23  22  21  20:18  17:15  14:12  11
//f in my def:    14  13  12  11  10-9   8   7   6-4    3-1            0
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFMAC_WriteFlag inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu

  flagsort = (flags[NF] << 13) | (flags[CF] << 12) | (flags[VF] << 11) | (flags[MCF] << 8) | (flags[MVF] << 7) 
                              | (0x1 << 6) | (0x1 << 5) | (0x1 << 4) | (flags[TF] << 3) | (flags[LSF] << 2) 
                              | (flags[ERASEF]);  
  flagsort |= (1 << 9);
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flags.reset();

  ADDOPERAND(Opc, UCPM::IFMACFlagToSHU, @$.S, @$.E); 
  //Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
  ADDOPERAND(Reg, UCPMReg::IALUBIU0, @$.S, @$.E);
  //Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
  ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
  Operands.push_back(nullptr);
  condpos = Operands.size();
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//it's tp in imac r/w flag instruction
  ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
}//end IMAC RWFlag
|
//yangl: UCP_M, start IMAC RW MR
imacreadmrclause ASSIGNTO ifmacdest {
//original code:  28  27  26  25  24:23  22  21  20:18  17:15  14:12  11
//f in my def:    14  13  12  11  10-9   8   7   6-4    3-1            0
     if(unit4 != NULL)//niuxx
      {
	switch(unit4->getReg())
	{
	  case UCPMReg::IMACIMAC :      //IMAC->_IMAC
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFMAC_ReadMR inst! IMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	  /*case UCPMReg::IMACIFMAC :    //IMAC->IFMAC
	    if(ut->getReg() > UCPMReg::T5)
	     {llvmerror(&@3, "Incorrect IFMAC_Logic inst! _IFMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu*/
	  break;
	  case UCPMReg::IMACIALU :	//IMAC->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFMAC_ReadMR inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu  
	  case UCPMReg::IMACIFALU :    //IMAC->IFALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFMAC_ReadMR inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }  

  flagsort = ( 1 << 14 ) | ( 1 << 11 ) | (1 << 6) | (1 << 5) | (1 << 4);  
  if(flags[BF])
    ;
  else if(flags[SF])
    flagsort |= (1 << 9);
  else if(flags[WF])
    flagsort |= (1 << 10);
  else
    {llvmerror(&@1, "ifmac readmr B/S/W flag error!");  clear();YYABORT;}
    
  if(flags[HF])
    flagsort |= (1 << 1);
  else if(flags[LF])
    ;
  else if(flags[OF])
    flagsort |= (1 << 2);
  
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  switch ($3){
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFMACFlagToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      goto ifmacreadMRBIU_add;
      break;
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFMACFlagToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();     
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      goto ifmacreadMRBIU_add;
      break;
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFMACFlagToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      goto ifmacreadMRBIU_add;
      break;     
    case 4://to m[s++/i++/a++]
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);
  
      ADDOPERAND(Opc, UCPM::IFMACFlagToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      goto ifmacreadMRBIU_add;
      break;
    case 5://to m[dis{shift}]  
      flagsort = flags[SHIFTF];
      dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
    
      ADDOPERAND(Opc, UCPM::IFMACFlagToMDis, @$.S, @$.E);         
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      goto ifmacreadMRBIU_add;
      break;
      
    case 6://to biu0  
      ADDOPERAND(Opc, UCPM::IFMACFlagToBIU0, @$.S, @$.E); goto ifmacreadMRBIU;  
    case 7://to biu1  
      ADDOPERAND(Opc, UCPM::IFMACFlagToBIU1, @$.S, @$.E); goto ifmacreadMRBIU;      
    case 8://to biu2  
      ADDOPERAND(Opc, UCPM::IFMACFlagToBIU2, @$.S, @$.E); goto ifmacreadMRBIU;  
  
   case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      ADDOPERAND(Opc, UCPM::IFMACFlagToBIU2, @$.S, @$.E);
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      goto ifmacreadMRBIU_add;
      break;
      
ifmacreadMRBIU:      
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      
ifmacreadMRBIU_add:    
    //deal with additional dest
      switch (imac_additional_dest) {
        case 0:
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;        
        case 1: //_IMAC.T0 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@3, "ifmac additional dest error!"); clear();YYABORT;
          break;
      }
      break;
      
    default:
      llvmerror(&@3, "ifmac dest error!"); clear();YYABORT;
      break;      
  }
  flags.reset();
}
|
imacwritemrclause {
//original code:  28  27  26  25  24:23  22  21  20:18  17:15  14:12  11
//f in my def:    14  13  12  11  10-9   8   7   6-4    3-1            0
  if(tm->getReg() > UCPMReg::T5)
    {llvmerror(&@1, "Incorrect IFMAC_SetMR inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu

  flagsort = ( 1 << 14 ) | (0x1 << 6) | (0x1 << 5) | (0x1 << 4);  
  if(flags[BF])
    ;
  else if(flags[SF])
    flagsort |= (1 << 9);
  else if(flags[WF])
    flagsort |= (1 << 10);
  else
    {llvmerror(&@1, "ifmac setMR B/S/W flag error!"); clear();YYABORT;}
    
  if(flags[HF])
    flagsort |= (1 << 1);
  else if(flags[LF])
    ;
  else if(flags[OF])
    flagsort |= (1 << 2);  
    
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flags.reset();

  ADDOPERAND(Opc, UCPM::IFMACFlagToSHU, @$.S, @$.E); 
  //Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
  ADDOPERAND(Reg, UCPMReg::IALUBIU0, @$.S, @$.E);
  //Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
  ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
  Operands.push_back(nullptr);
  condpos = Operands.size();
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//it's tp in imac r/w flag instruction
  ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
}//end IMAC RW MR
|
//yangl: UCP_M, start IMAC RW XOR REG
imacreadxorclause ASSIGNTO ifmacdest {
//original code:  28  27  26  25  24:23  22  21  20:18  17:15  14:12  11
//f in my def:    14  13  12  11  10-9   8   7   6-4    3-1            0
     if(unit4 != NULL)//niuxx
      {
	switch(unit4->getReg())
	{
	  case UCPMReg::IMACIMAC :      //IMAC->_IMAC
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFMAC_ReadXOR inst! IMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	  /*case UCPMReg::IMACIFMAC :    //IMAC->IFMAC
	    if(ut->getReg() > UCPMReg::T5)
	     {llvmerror(&@3, "Incorrect IFMAC_Logic inst! _IFMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu*/
	  break;
	  case UCPMReg::IMACIALU :	//IMAC->IALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFMAC_ReadXOR inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu  
	  case UCPMReg::IMACIFALU :    //IMAC->IFALU
	    if(ut->getReg() > UCPMReg::T5)
	      {llvmerror(&@3, "Incorrect IFMAC_ReadXOR inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	}
      }    

  flagsort = ( 1 << 13 ) | ( 1 << 11 ) | (0x1 << 6) | (0x1 << 5);  
  
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
  sia = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = flags[SHIFTF];
  dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
  
  flags.reset();
  
  switch ($3){
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFMACFlagToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      goto ifmacrwXORBIU_add;
      break;
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFMACFlagToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();     
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      goto ifmacrwXORBIU_add;
      break;
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFMACFlagToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      goto ifmacrwXORBIU_add;
      break;     
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFMACFlagToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      goto ifmacrwXORBIU_add;
      break;
    case 5://to m[dis{shift}]  
      ADDOPERAND(Opc, UCPM::IFMACFlagToMDis, @$.S, @$.E);         
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      goto ifmacrwXORBIU_add;
      break;
      
    case 6://to biu0  
      ADDOPERAND(Opc, UCPM::IFMACFlagToBIU0, @$.S, @$.E); goto ifmacrwXORBIU;  
    case 7://to biu1  
      ADDOPERAND(Opc, UCPM::IFMACFlagToBIU1, @$.S, @$.E); goto ifmacrwXORBIU;      
    case 8://to biu2  
      ADDOPERAND(Opc, UCPM::IFMACFlagToBIU2, @$.S, @$.E); goto ifmacrwXORBIU;  
      
    case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      ADDOPERAND(Opc, UCPM::IFMACFlagToBIU2, @$.S, @$.E);
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E); 
      goto ifmacrwXORBIU_add;
      break;
      
ifmacrwXORBIU:      

      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E); 
      
ifmacrwXORBIU_add:
      //deal with additional dest
      switch (imac_additional_dest) {
        case 0:
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;        
        case 1: //_IMAC.T0 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@3, "ifmac additional dest error!"); clear();YYABORT;
          break;
      }
      break;
      
    default:
      llvmerror(&@3, "ifmac dest error!"); clear();YYABORT;
      break;      
  }
}
|
imacwritexorclause {
//original code:  28  27  26  25  24:23  22  21  20:18  17:15  14:12  11
//f in my def:    14  13  12  11  10-9   8   7   6-4    3-1            0
  if(tm->getReg() > UCPMReg::T5)
    {llvmerror(&@1, "Incorrect IFMAC_SetXOR inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu

  flagsort = ( 1 << 13 ) | (0x1 << 6) | (0x1 << 5); 

  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flags.reset();

  ADDOPERAND(Opc, UCPM::IFMACFlagToSHU, @$.S, @$.E); 
  //Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
  ADDOPERAND(Reg, UCPMReg::IALUBIU0, @$.S, @$.E);
  //Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
  ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
  Operands.push_back(nullptr);
  condpos = Operands.size();
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//it's tp in imac r/w flag instruction
  ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
}//end IMAC RW XOR REG
|
//yangl: UCP_M, start IMAC MulAA
imacMulAAclause ASSIGNTO ifmacdest {
      if (!isTpValid)//tp == 0
      {
	if(tm->getReg() < UCPMReg::T6)
	{
	  if(tn->getReg() - tm->getReg() != 1)
	    {llvmerror(&@1, "Incorrect IFMAC_MulAA inst! Tm+1 is error!");clear();YYABORT;}//niuxu
	}
	else 
	  {llvmerror(&@1, "Incorrect IFMAC_MulAA inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
	if(tp->getReg() < UCPMReg::T6 && tp->getReg() > UCPMReg::T0)
	{
	  if (tp->getReg() - tk->getReg() != 1)
	    {llvmerror(&@1, "Incorrect IFMAC_MulAA inst! Tn-1 is error!");clear();YYABORT;}//niuxu	
	}  
	else 
	  {llvmerror(&@1, "Incorrect IFMAC_MulAA inst! Tn should be T1-T5!");clear();YYABORT;}//niuxu
      }
      else if (isTpMR || isTpMR_toMR)//tp == MR
      {
	if(tm->getReg() < UCPMReg::T6)
	{
	  if(tn->getReg() - tm->getReg() != 1)
	    {llvmerror(&@1, "Incorrect IFMAC_MulAA inst! Tm+1 is error!");clear();YYABORT;}//niuxu
	}
	else 
	  {llvmerror(&@1, "Incorrect IFMAC_MulAA inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
	if(tp->getReg() < UCPMReg::T6 && tp->getReg() > UCPMReg::T0)
	{
	  if (tp->getReg() - tk->getReg() != 1)
	    {llvmerror(&@1, "Incorrect IFMAC_MulAA inst! Tn-1 is error!");clear();YYABORT;}//niuxu	
	}  
	else 
	  {llvmerror(&@1, "Incorrect IFMAC_MulAA inst! Tn should be T1-T5!");clear();YYABORT;}//niuxu
      }
      else 
      {
	if(tm->getReg() > UCPMReg::T5)
	  {llvmerror(&@1, "Incorrect IFMAC_MulAA inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu
	if(tn->getReg() < UCPMReg::T6)
	{
	  if (tp->getReg() - tn->getReg() != 1)
	    {llvmerror(&@1, "Incorrect IFMAC_MulAA inst! Tm+1 is error!");clear();YYABORT;}//niuxu
	}
	else
	  {llvmerror(&@1, "Incorrect IFMAC_MulAA inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
	if(tk->getReg() < UCPMReg::T6 && tk->getReg() > UCPMReg::T0)
	{
	  if (tk->getReg() - tl->getReg() != 1)
	    {llvmerror(&@1, "Incorrect IFMAC_MulAA inst! Tn-1 is error!");clear();YYABORT;}//niuxu	  
	}
	else 
	  {llvmerror(&@1, "Incorrect IFMAC_MulAA inst! Tn should be T1-T5!");clear();YYABORT;}//niuxu	 
      } 

     if (unit4 != NULL)
     {
	switch (unit4->getReg())
	{
	  case  UCPMReg::IMACIALU:
	    if (ut->getReg() > UCPMReg::T5)
	       {llvmerror(&@3, "Incorrect IFMAC_MulAA inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	  case UCPMReg::IMACIFALU:
	    if (ut->getReg() > UCPMReg::T5)
	       {llvmerror(&@3, "Incorrect IFMAC_MulAA inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;     
	  case UCPMReg::IMACIMAC:
	    if (ut->getReg() > UCPMReg::T5)
	       {llvmerror(&@3, "Incorrect IFMAC_MulAA inst! IMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;     
	}
     }      

  flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (flags[FF] << 2) | (flags[PF] << 1);
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    {llvmerror(&@1, "ifmac MulAA ShiftMode0/1/2/3 flag error!");clear();YYABORT;}
    //flagsort = 0x2;
  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
  sia = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = flags[SHIFTF];
  dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
  
  if(flags[BF])
    ImacMuAA_BSflag = 0;
  else if(flags[SF])
    ImacMuAA_BSflag = 1;
  else
    {llvmerror(&@1, "ifmac MulAA B/S flag error!"); clear();YYABORT;}
  flags.reset();  
  
  switch ($3){
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFMACMulAAToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAA
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmacmulAABIU_add;
      break;

    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFMACMulAAToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();     
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAA
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift)); 
      goto ifmacmulAABIU_add;
      break;
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFMACMulAAToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAA
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmacmulAABIU_add;
      break;
         
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFMACMulAAToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAA
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      goto ifmacmulAABIU_add;
      break;
    case 5://to m[dis{shift}]
      ADDOPERAND(Opc, UCPM::IFMACMulAAToMDis, @$.S, @$.E);         
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAA
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      goto ifmacmulAABIU_add;
      break;
      
    case 6://to biu0  
      ADDOPERAND(Opc, UCPM::IFMACMulAAToBIU0, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAA
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmacmulAABIU_add;
      break;
    case 7://to biu1  
      ADDOPERAND(Opc, UCPM::IFMACMulAAToBIU1, @$.S, @$.E);  
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAA
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmacmulAABIU_add;
      break;
    case 8://to biu2  
      ADDOPERAND(Opc, UCPM::IFMACMulAAToBIU2, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAA
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmacmulAABIU_add;
      break;
    case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      ADDOPERAND(Opc, UCPM::IFMACMulAAToBIU2, @$.S, @$.E);//common with biu2
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20 && isTpMR_toMR)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20 && !isTpMR_toMR)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAA
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAA
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmacmulAABIU_add;
      break;
     

ifmacmulAABIU_add:      

      switch (imac_additional_dest) {
        case 0:
          if(isTpMR_toMR)
            ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          else
            ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;        
        case 1: //_IMAC.T0 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@3, "ifmac additional dest error!"); clear();YYABORT;
          break;
      }
      
      //}  
      ADDOPERAND(Imm, ImacMulAA_addsub, @$.S, @$.E);
      ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);  
      break;
      
    default:
      llvmerror(&@3, "ifmac dest error!"); clear();YYABORT;
      break;      
  }
}
|
imacMulAAclause_inside {
      if(tm->getReg() < UCPMReg::T6)
	{
	    if(tn->getReg() - tm->getReg() != 1)
	      {llvmerror(&@1, "Incorrect IFMAC_MulAA inst! Tm+1 is error!");clear();YYABORT;}//niuxu
	}
	else 
	  {llvmerror(&@1, "Incorrect IFMAC_MulAA inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tp->getReg() < UCPMReg::T6 && tp->getReg() > UCPMReg::T0)
      {
	if (tp->getReg() - tk->getReg() != 1)
	  {llvmerror(&@1, "Incorrect IFMAC_MulAA inst! Tn-1 is error!");clear();YYABORT;}//niuxu	
      }  
      else 
	{llvmerror(&@1, "Incorrect IFMAC_MulAA inst! Tn should be T1-T5!");clear();YYABORT;}//niuxu    

  flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (flags[FF] << 2) | (flags[PF] << 1);
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    {llvmerror(&@1, "ifmac MulAA ShiftMode0/1/2/3 flag error!");clear();YYABORT;}
    //flagsort = 0x2;
  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
  sia = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = flags[SHIFTF];
  dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
  
  if(flags[BF])
    ImacMuAA_BSflag = 0;
  else if(flags[SF])
    ImacMuAA_BSflag = 1;
  else
    {llvmerror(&@1, "ifmac MulAA B/S flag error!"); clear();YYABORT;}
  flags.reset();  
  
  ADDOPERAND(Opc, UCPM::IFMACMulAAToBIU2, @$.S, @$.E);//common with biu2
  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
  Operands.push_back(nullptr);
  condpos = Operands.size();
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tm in MulAA
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tn in MulAA
  unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
  revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
  ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
  ADDOPERAND(Imm, ImacMulAA_addsub, @$.S, @$.E);
  ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
}//end IMAC MulAA
| //ducx 20180310
imacMulVTnclause ASSIGNTO ifmacdest {
  if(!isTpValid) //tp == 0
  {
      if(tm->getReg() > UCPMReg::T5)
	  {llvmerror(&@1, "Incorrect IFMAC_Mul inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	  {llvmerror(&@1, "Incorrect IFMAC_Mul inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu    
  }
  else if (isTpMR || isTpMR_toMR)//tp == MR
  {
      if(tm->getReg() > UCPMReg::T5)
	  {llvmerror(&@1, "Incorrect IFMAC_Mul inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	  {llvmerror(&@1, "Incorrect IFMAC_Mul inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu   
  }
  else
  {
      if(tm->getReg() > UCPMReg::T5)
	  {llvmerror(&@1, "Incorrect IFMAC_Mul inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	  {llvmerror(&@1, "Incorrect IFMAC_Mul inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tp->getReg() > UCPMReg::T5)
	  {llvmerror(&@1, "Incorrect IFMAC_Mul inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu  
  }
  
     if (unit4 != NULL)
     {
	switch (unit4->getReg())
	{
	  case  UCPMReg::IMACIALU:
	    if (ut->getReg() > UCPMReg::T5)
	       {llvmerror(&@3, "Incorrect IFMAC_Mul inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	  case UCPMReg::IMACIFALU:
	    if (ut->getReg() > UCPMReg::T5)
	       {llvmerror(&@3, "Incorrect IFMAC_Mul inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;     
	  case UCPMReg::IMACIMAC:
	    if (ut->getReg() > UCPMReg::T5)
	       {llvmerror(&@3, "Incorrect IFMAC_Mul inst! IMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;     
	}
     }    

  flagsort = (flags[CF] << 2) | (flags[FF] << 1) | (flags[PF] << 0);
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    {llvmerror(&@1, "ifmac ShiftMode0/1/2/3 flag error!");clear();YYABORT;}

  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
  sia = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = flags[SHIFTF];
  dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
  
  if(flags[BF])
    ImacMuAA_BSflag = 0;
  else if(flags[SF])
    ImacMuAA_BSflag = 1;
  else
    {llvmerror(&@1, "ifmac B/S flag error!"); clear();YYABORT;}
  flags.reset();  
  
  switch ($3){
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFMACMulVTnToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      goto ifmacmulVTnBIU_add;
      break;

    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFMACMulVTnToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();     
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift)); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      goto ifmacmulVTnBIU_add;
      break;
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFMACMulVTnToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      goto ifmacmulVTnBIU_add;
      break;
         
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFMACMulVTnToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      goto ifmacmulVTnBIU_add;
      break;
    case 5://to m[dis{shift}]
      ADDOPERAND(Opc, UCPM::IFMACMulVTnToMDis, @$.S, @$.E);         
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      goto ifmacmulVTnBIU_add;
      break;
      
    case 6://to biu0  
      ADDOPERAND(Opc, UCPM::IFMACMulVTnToBIU0, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      goto ifmacmulVTnBIU_add;
      break;
    case 7://to biu1  
      ADDOPERAND(Opc, UCPM::IFMACMulVTnToBIU1, @$.S, @$.E);  
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      goto ifmacmulVTnBIU_add;
      break;
    case 8://to biu2  
      ADDOPERAND(Opc, UCPM::IFMACMulVTnToBIU2, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      goto ifmacmulVTnBIU_add;
      break;
    case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      ADDOPERAND(Opc, UCPM::IFMACMulVTnToBIU2, @$.S, @$.E);//common with biu2
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20 && isTpMR_toMR)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20 && !isTpMR_toMR)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {//tp == 0
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        }
      else if(isTpMR || isTpMR_toMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
	}
      else {//tpvalid
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      goto imacmulVTnBIU_add;
      break;
     

ifmacmulVTnBIU_add:      

      switch (imac_additional_dest) {
        case 0:
          if(isTpMR_toMR)
            ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          else
            ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;  
          break;        
        case 1: //_IMAC.T0 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@3, "ifmac additional dest error!"); clear();YYABORT;
          break;
      }
      
      //}  
      ADDOPERAND(Imm, ImacMulAA_addsub, @$.S, @$.E);
      ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);  
      break;
      
    default:
      llvmerror(&@3, "ifmac dest error!"); clear();YYABORT;
      break;      
  }
}
|
imacMulVTnclause_inside {
  
  flagsort = (flags[CF] << 2) | (flags[FF] << 1) | (flags[PF] << 0);
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    {llvmerror(&@1, "ifmac ShiftMode0/1/2/3 flag error!");clear();YYABORT;}

  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
  sia = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = flags[SHIFTF];
  dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
  
  if(flags[BF])
    ImacMuAA_BSflag = 0;
  else if(flags[SF])
    ImacMuAA_BSflag = 1;
  else
    {llvmerror(&@1, "ifmac B/S flag error!"); clear();YYABORT;}
  flags.reset();  
  
  ADDOPERAND(Opc, UCPM::IFMACMulVTnToBIU2, @$.S, @$.E);//common with biu2
  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
  Operands.push_back(nullptr);
  condpos = Operands.size();
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
  unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
  revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
  ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
  ADDOPERAND(Imm, ImacMulAA_addsub, @$.S, @$.E);
  ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
}//end Tp+Tm*V(Tn[k])
|
CLEARMR {
  ADDOPERAND(Opc, UCPM::IFMACClearMR, @$.S, @$.E);
  Operands.push_back(nullptr);
  condpos = Operands.size();
}
//yangl: UCP_M, IFMAC set shift mode
| imacsetshiftclause ASSIGNTO imacshiftmodeoption {
  switch ($1) {
  case 0://t
    ADDOPERAND(Opc, UCPM::IFMACSetShiftModeWithT, @$.S, @$.E);
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
    break;
  case 1://imm5
    ADDOPERAND(Opc, UCPM::IFMACSetShiftModeWithImm, @$.S, @$.E);
    Operands.push_back(nullptr);
    condpos = Operands.size();
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));   
    break;
  default:
    llvmerror(&@1, "ifmac setshift clause error!"); clear();YYABORT;
    break;
  }
}
| //yangl:UCP_M, IFMAC triple
imactripleclause ASSIGNTO ifmacdest {
  if(tm->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IFMAC_Triple inst! Tl should be T0-T5!");clear();YYABORT;}//niuxu
  if(tn->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IFAC_Triple inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
  if(tp->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IFMAC_Triple inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
    
  if (unit4 != NULL)
  {
    switch (unit4->getReg())
    {
      case  UCPMReg::IMACIALU:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IFMAC_Triple inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;
      case UCPMReg::IMACIFALU:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IFMAC_Triple inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;     
      case UCPMReg::IMACIMAC:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IFMAC_Triple inst! IMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;     
    }
  }        
      
  flagsort = (flags[ALLF] << 4);// | (flags[NOT1F] << 1) | flags[NOT2F];
  if(flags[BF])
    flagsort = flagsort | (0b00 << 2);
  else if(flags[SF])
    flagsort = flagsort | (0b01 << 2);
//  else if(flags[WF])
//    flagsort = flagsort | (0b10 << 2);
//  else // I don't know if is reasonable
//    flagsort = flagsort | (0b11 << 2);   
  else
    {llvmerror(&@1, "ifmac B/S flag error!");clear();YYABORT;}
  flags.reset();
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  switch ($3){
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFMACTripleToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's 'tl' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//in fact it's 'tm' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//in fact it's 'tn' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      goto ifmactripleBIU_add;
      break;

    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFMACTripleToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();     
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));   
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's 'tl' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//in fact it's 'tm' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//in fact it's 'tn' in the document   
      goto ifmactripleBIU_add;
      break;
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFMACTripleToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));   
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's 'tl' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//in fact it's 'tm' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//in fact it's 'tn' in the document
      goto ifmactripleBIU_add;
      break;        
    case 4://to m[s++/i++/a++]
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      flags.reset();
      ADDOPERAND(Opc, UCPM::IFMACTripleToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));   
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's 'tl' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//in fact it's 'tm' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//in fact it's 'tn' in the document          
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia)); 
      goto ifmactripleBIU_add;
      break;
    case 5://to m[dis{shift}]
      flagsort = flags[SHIFTF];
      dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
      flags.reset();
      ADDOPERAND(Opc, UCPM::IFMACTripleToMDis, @$.S, @$.E);         
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));  
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's 'tl' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//in fact it's 'tm' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//in fact it's 'tn' in the document             
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis)); 
      goto ifmactripleBIU_add;
      break;     
    case 6://to biu0  
      ADDOPERAND(Opc, UCPM::IFMACTripleToBIU0, @$.S, @$.E); goto ifmactripleBIU;  
    case 7://to biu1  
      ADDOPERAND(Opc, UCPM::IFMACTripleToBIU1, @$.S, @$.E); goto ifmactripleBIU;      
    case 8://to biu2  
      ADDOPERAND(Opc, UCPM::IFMACTripleToBIU2, @$.S, @$.E); goto ifmactripleBIU;  
  
    case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      ADDOPERAND(Opc, UCPM::IFMACTripleToBIU2, @$.S, @$.E);
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));   
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's 'tl' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//in fact it's 'tm' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//in fact it's 'tn' in the document       
      goto ifmactripleBIU_add;
      break;    
      
ifmactripleBIU:      
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));   
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//in fact it's 'tl' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//in fact it's 'tm' in the document
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));//in fact it's 'tn' in the document       

ifmactripleBIU_add:
      //deal with additional dest
      switch (imac_additional_dest) {
        case 0:
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;        
        case 1: //_IMAC.T0 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@3, "ifmac additional dest error!"); clear();YYABORT;
          break;
      }
      break;  
    default:
      llvmerror(&@3, "ifmac dest error!"); clear();YYABORT;
      break;      
  }
}//end IMAC triple

//ducx start 20180130
| imacASclause ASSIGNTO ifmacASdest {//niuxiaoxu
  if (!isTpValid)
  {
    if(tm->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IFMAC_AS inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
    if(tn->getReg() == UCPMReg::T6)
      {llvmerror(&@1, "Incorrect IFMAC_AS inst! Tn should be T0-T5,T7!");clear();YYABORT;}//niuxu 
  }
  else if (!isTnValid)
  {
    if(tm->getReg() > UCPMReg::T6)
      {llvmerror(&@1, "Incorrect IFMAC_AS inst! Tp should be T0-T6!");clear();YYABORT;}//niuxu
    if(tn->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IFMAC_AS inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu 
  }
  else
  {
    if(tm->getReg() > UCPMReg::T6)
      {llvmerror(&@1, "Incorrect IFMAC_AS inst! Tp should be T0-T6!");clear();YYABORT;}//niuxu
    if(tn->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IFMAC_AS inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
    if(tp->getReg() == UCPMReg::T6)
      {llvmerror(&@1, "Incorrect IFMAC_AS inst! Tn should be T0-T5,T7!");clear();YYABORT;}//niuxu  
  }
    
  flagsort = (flags[LF] << 3) | (flags[TF] << 2) | (flags[CF] << 1) | (flags[PF] << 0);
  f = OPERAND(Imm, flagsort, FlagS, FlagE);

  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    {llvmerror(&@1, "ifmac ShiftMode0/1/2/3 flag error!");clear();YYABORT;}

  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  
  if(flags[BF])
    ImacMuAA_BSflag = 0;
  else if(flags[SF])
    ImacMuAA_BSflag = 1;
  else
    {llvmerror(&@1, "ifmac B/S flag error!"); clear();YYABORT;}
    
  //flags.reset();
  
  switch ($3){
  
    case 0://to imac  
   
      ADDOPERAND(Opc, UCPM::IFMACASToIFMAC, @$.S, @$.E); 

      Operands.push_back(nullptr);
      condpos = Operands.size();
      
      if(!isTpValid) {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        //it's tp as 0 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);//for unused tp in imac
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
      }
      else if(!isTnValid)
      {     
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        //it's tn as 1 
        unsigned tn_1 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);//for unused tn in imac
        revt = OPERAND(Reg, tn_1, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
      }
      else
      {
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
      if(flags[XF])
        ADDOPERAND(Imm, 1, @$.S, @$.E);
      else
        ADDOPERAND(Imm, 0, @$.S, @$.E);
      break;
      
    case 1://to m[t] & IALU/SHU
      if(flags[XF])
	{llvmerror(&@1, "ifmac X flag error!"); clear();YYABORT;};
  
      ADDOPERAND(Opc, UCPM::IFMACASToMregIFALUSHU, @$.S, @$.E); 
         
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      
      if(!isTpValid) {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        //it's tp as 0 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);//for unused tp in imac
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
      }
      else if(!isTnValid)
      {     
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        //it's tn as 1 
        unsigned tn_1 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);//for unused tn in imac
        revt = OPERAND(Reg, tn_1, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
      }
      else
      {
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
      ADDOPERAND(Imm, ImacToialu_flag, @$.S, @$.E);
      break;
      
    case 2://to m[s++/i++/a++] & IALU/SHU
      if(flags[XF])
	{llvmerror(&@1, "IFMAC_AS X flags error! Available flags are L,P,T,C,ShiftMode0/1/2/3"); clear();YYABORT;};//niuxx
    
    
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      
         ADDOPERAND(Opc, UCPM::IFMACASToMSIAIFALUSHU, @$.S, @$.E); 

      Operands.push_back(nullptr);
      condpos = Operands.size();
      
      if(!isTpValid) {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        //it's tp as 0 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);//for unused tp in imac
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
      }
      else if(!isTnValid)
      {     
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        //it's tn as 1 
        unsigned tn_1 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);//for unused tn in imac
        revt = OPERAND(Reg, tn_1, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
      }
      else
      {
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
      ADDOPERAND(Imm, ImacToialu_flag, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia)); 
      break;

    case 3://to m[dis{shift}] & IALU/SHU
      if(flags[XF])
	{llvmerror(&@1, "IFMAC_AS X flags error! Available flags are L,P,T,C,ShiftMode0/1/2/3"); clear();YYABORT;};//niuxx    
    
     flagsort = flags[SHIFTF];
     dis = OPERAND(Imm, flagsort, FlagS, FlagE);
     
         ADDOPERAND(Opc, UCPM::IFMACASToMDISIFALUSHU, @$.S, @$.E); 

      Operands.push_back(nullptr);
      condpos = Operands.size();
      
      if(!isTpValid) {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        //it's tp as 0 
        unsigned tp_0 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);//for unused tp in imac
        revt = OPERAND(Reg, tp_0, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
      }
      else if(!isTnValid)
      {     
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); 
        //it's tn as 1 
        unsigned tn_1 = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);//for unused tn in imac
        revt = OPERAND(Reg, tn_1, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
      }
      else
      {
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk));
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
      ADDOPERAND(Imm, ImacToialu_flag, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis)); 
      break;
   }
      
      flags.reset();  
}
//ducx end 20180130

//huhh: imac: tm +- tm*tn
| imacmaclause ASSIGNTO ifmacdest {

  if(tm->getReg() > UCPMReg::T5)
    {llvmerror(&@1, "Incorrect IFMAC_Mul inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu
  if(tn->getReg() > UCPMReg::T5)
    {llvmerror(&@1, "Incorrect IFMAC_Mul inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
  if(tp->getReg() > UCPMReg::T5)
    {llvmerror(&@1, "Incorrect IFMAC_Mul inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
    
  if (unit4 != NULL)
  {
    switch (unit4->getReg())
    {
      case  UCPMReg::IMACIALU:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IFMAC_Mul inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;
      case UCPMReg::IMACIFALU:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IFMAC_Mul inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;     
      case UCPMReg::IMACIMAC:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IFMAC_Mul inst! IMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;     
    }
  }    
    
  flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1);
  //C but not have CR
  if(flags[CF])
  {
     flagsort |= 0x1;
     flagsort &= 0b110111;
  }
  //SEND flag
  if(flags[SENDF])
    flagsort |= 0x1;
    
    //ducx:for abs mul
  if(isIMACABS)
    flagsort &= 0b110111;
    
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    {llvmerror(&@1, "IFMAC_AS ShiftMode0/1/2/3 flags error!");clear();YYABORT;}//niuxx
    //flagsort = 0x2;
  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  //flags.reset();
    
  
  switch ($3){
    case 0://to shu  
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToSHU, @$.S, @$.E);//?????
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToSHU, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToSHU, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToSHU, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmac_tripleBIU_add;
      break;
      
    case 1://to macc
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToMACC, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToMACC, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToMACC, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToMACC, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmac_tripleBIU_add;
      break;
      
    case 3://to m[t]
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToM, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToM, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToM, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToM, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmac_tripleBIU_add;
      break;

    case 4://to m[s++/i++/a++]  
     flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
     sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToMSIA, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToMSIA, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToMSIA, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToMSIA, @$.S, @$.E); 
      }
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia)); 
      goto ifmac_tripleBIU_add;
      break;
      
    case 5://to m[dis{shift}]
    flagsort = flags[SHIFTF];
    dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToMDis, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToMDis, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToMDis, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToMDis, @$.S, @$.E); 
      }
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis)); 
      goto ifmac_tripleBIU_add;
      break;
      
      case 6://to imacbiu0  
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToBIU0, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToBIU0, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToBIU0, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToBIU0, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmac_tripleBIU_add;
      break;
      
      case 7://to imacbiu1    
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToBIU1, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToBIU1, @$.S, @$.E); 
        break;     
       case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToBIU1, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToBIU1, @$.S, @$.E); 
       }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmac_tripleBIU_add;
      break;
      
      case 8://to imacbiu2  
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToBIU2, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToBIU2, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToBIU2, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToBIU2, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmac_tripleBIU_add;
      break;
      
      case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToBIU2, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToBIU2, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToBIU2, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToBIU2, @$.S, @$.E); 
      }
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmac_tripleBIU_add;
      break;
      
  }
ifmac_tripleBIU_add:
  //deal with additional dest
    switch (imac_additional_dest) {
        case 0:
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;        
        case 1: //_IMAC.T0 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@3, "ifmac additional dest error!"); clear();YYABORT;
          break;
      }
      //for imac abs bit
      f = OPERAND(Imm, 0, FlagS, FlagE);
      ff = OPERAND(Imm, 1, FlagS, FlagE);
      if(isIMACABS)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      //for imac B/S/R/I, or B/S/W flag
      if(!isIMACABS) {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[RF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else if(flags[IF])
          ADDOPERAND(Reg, UCPMReg::T3, @$.S, @$.E);
        else
          {llvmerror(&@1, "ifmac B/R/S/I flag error!");clear();YYABORT;}
      }
      else {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[WF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else
          {llvmerror(&@1, "ifmac B/S/W flag error!"); clear();YYABORT;}
      }
      flags.reset();  
}
//ducx: ifmac: tp +- tm*tn, nodest
| imacmaclause {
  if(tm->getReg() > UCPMReg::T5)
    {llvmerror(&@1, "Incorrect IFMAC_Mul inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu
  if(tn->getReg() > UCPMReg::T5)
    {llvmerror(&@1, "Incorrect IFMAC_Mul inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
  if(tp->getReg() > UCPMReg::T5)
    {llvmerror(&@1, "Incorrect IFMAC_Mul inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
    
  flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1);
  //C but not have CR
  if(flags[CF])
  {
     flagsort |= 0x1;
     flagsort &= 0b110111;
  }
  //SEND flag
  if(flags[SENDF])
    flagsort |= 0x1;
    
    //ducx:for abs mul
  if(isIMACABS)
    flagsort &= 0b110111;
    
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    {llvmerror(&@1, "ifmac ShiftMode0/1/2/3 flag error!");clear();YYABORT;}
    //flagsort = 0x2;
  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  //flags.reset();
  
  if (flags[LF])
   {llvmerror(&@1, "IFMAC_Mul L flag error,available flags are U,P,T,F,C/Send,ShiftMode0/1/2/3 ");clear();YYABORT;};//niuxx
  
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToSHU, @$.S, @$.E);//?????
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToSHU, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToSHU, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToSHU, @$.S, @$.E); 
      }

      ADDOPERAND(Reg, UCPMReg::IALUBIU0, @$.S, @$.E);//unit=0
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);//ut=0
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
      //for imac abs bit
      f = OPERAND(Imm, 0, FlagS, FlagE);
      ff = OPERAND(Imm, 1, FlagS, FlagE);
      if(isIMACABS)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      //for imac B/S/R/I, or B/S/W flag
      if(!isIMACABS) {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[RF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else if(flags[IF])
          ADDOPERAND(Reg, UCPMReg::T3, @$.S, @$.E);
        else
          {llvmerror(&@1, "ifmac B/R/S/I flag error!");clear();YYABORT;}
      }
      else {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[WF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else
          {llvmerror(&@1, "ifmac B/S/W flag error!"); clear();YYABORT;}
      }
      flags.reset();  
}
|
//yangl: imac: 0 +- tm*tn
imacmaclause_0_tm_tn ASSIGNTO ifmacdest {
  if(tm->getReg() > UCPMReg::T5)
    {llvmerror(&@1, "Incorrect IFMAC_Mul inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
  if(tn->getReg() > UCPMReg::T5)
    {llvmerror(&@1, "Incorrect IFMAC_Mul inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
    
  if (unit4 != NULL)
  {
    switch (unit4->getReg())
    {
      case  UCPMReg::IMACIALU:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IFMAC_Mul inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;
      case UCPMReg::IMACIFALU:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IFMAC_Mul inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;     
      case UCPMReg::IMACIMAC:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IFMAC_Mul inst! IMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;     
    }
  }    
    
  unsigned treg = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);//for unused tp in imac
  revt = OPERAND(Reg, treg, @$.S, @$.E);
  flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1);
  //C but not have CR
  if(flags[CF])
  {
     flagsort |= 0x1;
     flagsort &= 0b110111;
  }
  //SEND flag
  if(flags[SENDF])
    flagsort |= 0x1;
    
    //ducx:for abs mul
  if(isIMACABS)
    flagsort &= 0b110111;
    
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    {llvmerror(&@1, "ifmac ShiftMode0/1/2/3 flag error!");clear();YYABORT;}
    //flagsort = 0x2;
  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  //flags.reset();
  
  switch ($3){
    case 0://to shu  
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToSHU, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToSHU, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToSHU, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToSHU, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));//null tp for imac (it's T6 in binary)
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmac111BIU_add;
      break;
      
    case 1://to macc
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToMACC, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToMACC, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToMACC, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToMACC, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));//null tp for imac (it's T6 in binary)
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift)); 
      goto ifmac111BIU_add;
      break;     
    case 3://to m[t]
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToM, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToM, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToM, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToM, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));//null tp for imac (it's T6 in binary)
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmac111BIU_add;
      break;

    case 4://to m[s++/i++/a++]
    
     flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
     sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToMSIA, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToMSIA, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToMSIA, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToMSIA, @$.S, @$.E); 
      }
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));//null tp for imac (it's T6 in binary)
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));  
      goto ifmac111BIU_add;
      break;
      
    case 5://to m[dis{shift}]
    flagsort = flags[SHIFTF];
    dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToMDis, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToMDis, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToMDis, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToMDis, @$.S, @$.E); 
      }
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));//null tp for imac (it's T6 in binary)
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis)); 
      goto ifmac111BIU_add;
      break;
      
      case 6://to imacbiu0  
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToBIU0, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToBIU0, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToBIU0, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToBIU0, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));//null tp for imac (it's T6 in binary)
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmac111BIU_add;
      break;
      
      case 7://to imacbiu1    
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToBIU1, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToBIU1, @$.S, @$.E); 
        break;     
       case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToBIU1, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToBIU1, @$.S, @$.E); 
       }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));//null tp for imac (it's T6 in binary)
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmac111BIU_add;
      break;
      
      case 8://to imacbiu2  
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToBIU2, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToBIU2, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToBIU2, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToBIU2, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));//null tp for imac (it's T6 in binary)
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmac111BIU_add;
      break;
      
    case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToBIU2, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToBIU2, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToBIU2, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToBIU2, @$.S, @$.E); 
      }
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));//null tp for imac (it's T6 in binary)
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmac111BIU_add;
      break;
  }
ifmac111BIU_add:
      //deal with additional dest
      switch (imac_additional_dest) {
        case 0:
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;        
        case 1: //_IMAC.T0 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@3, "ifmac additional dest error!"); clear();YYABORT;
          break;
      }
      //for imac abs bit
      f = OPERAND(Imm, 0, FlagS, FlagE);
      ff = OPERAND(Imm, 1, FlagS, FlagE);
      if(isIMACABS)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      //for imac B/S/R/I, or B/S/W flag
      if(!isIMACABS) {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[RF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else if(flags[IF])
          ADDOPERAND(Reg, UCPMReg::T3, @$.S, @$.E);
        else
          {llvmerror(&@1, "ifmac B/R/S/I flag error!"); clear();YYABORT;}
      }
      else {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[WF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else
          {llvmerror(&@1, "ifmac B/S/W flag error!"); clear();YYABORT;}
      }
      flags.reset();
}
|
//ducx: ifmac: 0 +- tm*tn, nodest
imacmaclause_0_tm_tn {
  if(tm->getReg() > UCPMReg::T5)
    {llvmerror(&@1, "Incorrect IFMAC_Mul inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
  if(tn->getReg() > UCPMReg::T5)
    {llvmerror(&@1, "Incorrect IFMAC_Mul inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
    
  unsigned treg = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);//for unused tp in imac
  revt = OPERAND(Reg, treg, @$.S, @$.E);
  flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1);
  //C but not have CR
  if(flags[CF])
  {
     flagsort |= 0x1;
     flagsort &= 0b110111;
  }
  //SEND flag
  if(flags[SENDF])
    flagsort |= 0x1;
    
    //ducx:for abs mul
  if(isIMACABS)
    flagsort &= 0b110111;
    
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    {llvmerror(&@1, "ifmac ShiftMode0/1/2/3 flag error!");clear();YYABORT;}
    //flagsort = 0x2;
  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  //flags.reset();
  
  
  if (flags[LF])
   {llvmerror(&@1, "IMAC/IFMAC_Mul L flag error,available flags are U,P,T,F,C/Send,ShiftMode0/1/2/3 ");clear();YYABORT;};//niuxx 
   
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToSHU, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToSHU, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToSHU, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToSHU, @$.S, @$.E); 
      }

      ADDOPERAND(Reg, UCPMReg::IALUBIU0, @$.S, @$.E);//unit=0
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);//ut=0
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));//null tp for imac (it's T6 in binary)
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
      //for imac abs bit
      f = OPERAND(Imm, 0, FlagS, FlagE);
      ff = OPERAND(Imm, 1, FlagS, FlagE);
      if(isIMACABS)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      //for imac B/S/R/I, or B/S/W flag
      if(!isIMACABS) {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[RF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else if(flags[IF])
          ADDOPERAND(Reg, UCPMReg::T3, @$.S, @$.E);
        else
          {llvmerror(&@1, "ifmac B/R/S/I flag error!"); clear();YYABORT;}
      }
      else {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[WF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else
          {llvmerror(&@1, "ifmac B/S/W flag error!"); clear();YYABORT;}
      }
      flags.reset();
}
/*|
//yangl: imac: MR +- tm*tn
imacmaclause_mr_tm_tn ASSIGNTO ifmacdest {
  unsigned treg = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);//for unused tp in imac
  revt = OPERAND(Reg, treg, @$.S, @$.E);
  
  //ducx
  if(flags[CF])
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (flags[CRF] << 3) | (flags[FF] << 2) | (flags[PF] << 1) | (1 << 0);
  else if(flags[RF])
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1) | flags[CRF];
  else if(flags[IF])
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1) | flags[SENDF];
  else
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1);


  
  //ducx:for abs mul
  if(isIMACABS)
    flagsort &= 0b110111;
    
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    llvmerror(&@1, "ShiftMode0/1/2/3 flag error!");
    //flagsort = 0x2;
  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  //flags.reset();
  
  switch ($3){
    case 0://to shu  
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToSHU, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToSHU, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToSHU, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToSHU, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmac222BIU_add;
      break;
      
    case 1://to macc
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToMACC, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToMACC, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToMACC, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToMACC, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmac222BIU_add;
      break;
      
    case 3://to m[t]
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToM, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToM, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToM, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToM, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmac222BIU_add;
      break;

    case 4://to m[s++/i++/a++]
    
     flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
     sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToMSIA, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToMSIA, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToMSIA, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToMSIA, @$.S, @$.E); 
      }
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia)); 
      goto ifmac222BIU_add;
      break;
      
    case 5://to m[dis{shift}]
    flagsort = flags[SHIFTF];
    dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToMDis, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToMDis, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToMDis, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToMDis, @$.S, @$.E); 
      }
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis)); 
      goto ifmac222BIU_add;
      break;
      
      case 6://to imacbiu0  
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToBIU0, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToBIU0, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToBIU0, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToBIU0, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmac222BIU_add;
      break;
      
      case 7://to imacbiu1    
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToBIU1, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToBIU1, @$.S, @$.E); 
        break;     
       case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToBIU1, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToBIU1, @$.S, @$.E); 
       }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmac222BIU_add;
      break;
      
      case 8://to imacbiu2  
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToBIU2, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToBIU2, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToBIU2, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToBIU2, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmac222BIU_add;
      break;
      
    case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToBIU2, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToBIU2, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToBIU2, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToBIU2, @$.S, @$.E); 
      }
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmac222BIU_add;
      break;
      
  }
ifmac222BIU_add:  
      //deal with additional dest
        switch (imac_additional_dest) {
        case 0:
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;        
        case 1: //_IMAC.T0 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@1, "ifmac additional dest error!"); 
          break;
      }
      //for imac abs bit
      f = OPERAND(Imm, 0, FlagS, FlagE);
      ff = OPERAND(Imm, 1, FlagS, FlagE);
      if(isIMACABS)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      //for imac B/S/R/I, or B/S/W flag
      if(!isIMACABS) {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[RF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else if(flags[IF])
          ADDOPERAND(Reg, UCPMReg::T3, @$.S, @$.E);
        else
          llvmerror(&@1, "B/R/S/I flag error!"); 
      }
      else {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[WF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else
          llvmerror(&@1, "B/S/W flag error!"); 
      }
      flags.reset();
}
|
//ducx: ifmac: MR +- tm*tn, nodest
imacmaclause_mr_tm_tn {
  unsigned treg = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);//for unused tp in imac
  revt = OPERAND(Reg, treg, @$.S, @$.E);
  
  //ducx
  if(flags[CF])
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (flags[CRF] << 3) | (flags[FF] << 2) | (flags[PF] << 1) | (1 << 0);
  else if(flags[RF])
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1) | flags[CRF];
  else if(flags[IF])
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1) | flags[SENDF];
  else
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1);


  
  //ducx:for abs mul
  if(isIMACABS)
    flagsort &= 0b110111;
    
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    llvmerror(&@1, "ShiftMode0/1/2/3 flag error!");
    //flagsort = 0x2;
  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  //flags.reset();
  


      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToSHU, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToSHU, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToSHU, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToSHU, @$.S, @$.E); 
      }
      ADDOPERAND(Reg, UCPMReg::IALUBIU0, @$.S, @$.E);//unit=0
      ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);//ut=0
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);

      //for imac abs bit
      f = OPERAND(Imm, 0, FlagS, FlagE);
      ff = OPERAND(Imm, 1, FlagS, FlagE);
      if(isIMACABS)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      //for imac B/S/R/I, or B/S/W flag
      if(!isIMACABS) {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[RF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else if(flags[IF])
          ADDOPERAND(Reg, UCPMReg::T3, @$.S, @$.E);
        else
          llvmerror(&@1, "B/R/S/I flag error!"); 
      }
      else {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[WF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else
          llvmerror(&@1, "B/S/W flag error!"); 
      }
      flags.reset();
}*/
|
//yangl: imac: MR +=/-= tm*tn -> dest
imacmaclause_mr_equ_tm_tn ASSIGNTO ifmacdest {
      
  if (unit4 != NULL)
  {
    switch (unit4->getReg())
    {
      case  UCPMReg::IMACIALU:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IFMAC_Mul inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;
      case UCPMReg::IMACIFALU:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IFMAC_Mul inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;     
      case UCPMReg::IMACIMAC:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IFMAC_Mul inst! IMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;     
    }
  }      

  if(tm->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IFMAC_Mul inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
  if (isTnValid == true)
  {
    if(tn->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IFMAC_Mul inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu   
  }
  
  unsigned treg = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);//for unused tp in imac
  revt = OPERAND(Reg, treg, @$.S, @$.E);
  
  //ducx
  if(flags[CF])
//    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (flags[CRF] << 3) | (flags[FF] << 2) | (flags[PF] << 1) | (1 << 0);
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (0 << 3) | (flags[FF] << 2) | (flags[PF] << 1) | (1 << 0);
  else if(flags[RF])
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1) | flags[CRF];
  else if(flags[IF])
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1) | flags[SENDF];
  else
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1);


  //ducx 20180801
  if(flags[CF] && flags[CRF])
  {
    llvmerror(&@1, "Incorrect IFMAC_Mul inst! C and CR should not coexist!");clear();YYABORT;
  }

  
    //ducx:for abs mul
  if(isIMACABS)
    flagsort &= 0b110111;
    
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    {llvmerror(&@1, "ifmac ShiftMode0/1/2/3 flag error!");clear();YYABORT;}
    //flagsort = 0x2;
  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  //flags.reset();
  
  switch ($3){
    case 0://to shu  
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToSHU, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToSHU, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToSHU, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToSHU, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmac333BIU_add;
      break;
      
    case 1://to macc
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToMACC, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToMACC, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToMACC, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToMACC, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmac333BIU_add;
      break;
      
    case 3://to m[t]
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToM, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToM, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToM, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToM, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmac333BIU_add;
      break;

    case 4://to m[s++/i++/a++]
    
     flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
     sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToMSIA, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToMSIA, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToMSIA, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToMSIA, @$.S, @$.E); 
      }
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia)); 
      goto ifmac333BIU_add;
      break;
      
    case 5://to m[dis{shift}]
    flagsort = flags[SHIFTF];
    dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToMDis, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToMDis, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToMDis, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToMDis, @$.S, @$.E); 
      }
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis)); 
      goto ifmac333BIU_add;
      break;
      
      case 6://to imacbiu0  
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToBIU0, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToBIU0, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToBIU0, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToBIU0, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmac333BIU_add;
      break;
      
      case 7://to imacbiu1    
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToBIU1, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToBIU1, @$.S, @$.E); 
        break;     
       case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToBIU1, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToBIU1, @$.S, @$.E); 
       }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmac333BIU_add;
      break;
      
      case 8://to imacbiu2  
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToBIU2, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToBIU2, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToBIU2, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToBIU2, @$.S, @$.E); 
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmac333BIU_add;
      break;
      
     case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      switch ($1) {
        case 0: //real add
        ADDOPERAND(Opc, UCPM::IFMARealaddToBIU2, @$.S, @$.E); 
        break;      
        case 1: //real sub
        ADDOPERAND(Opc, UCPM::IFMARealsubToBIU2, @$.S, @$.E); 
        break;     
        case 2: //complex add
        ADDOPERAND(Opc, UCPM::IFMACompaddToBIU2, @$.S, @$.E); 
        break;  
        case 3: //complex sub
        ADDOPERAND(Opc, UCPM::IFMACompsubToBIU2, @$.S, @$.E); 
      }
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if(isTnValid == true)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      else
        ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      goto ifmac333BIU_add;
      break;
      
  }
ifmac333BIU_add:  
       switch (imac_additional_dest) {
        case 0:
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 1: //_IMAC.T0 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND ifmacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@3, "ifmac additional dest error!"); clear();YYABORT;
          break;
      }
      //for imac abs bit
      f = OPERAND(Imm, 0, FlagS, FlagE);
      ff = OPERAND(Imm, 1, FlagS, FlagE);
      if(isIMACABS)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      //for imac B/S/R/I, or B/S/W flag
      if(!isIMACABS) {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[RF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else if(flags[IF])
          ADDOPERAND(Reg, UCPMReg::T3, @$.S, @$.E);
        else
          {llvmerror(&@1, "ifmac B/R/S/I flag error!"); clear();YYABORT;}
      }
      else {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[WF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else
          {llvmerror(&@1, "ifmac B/S/W flag error!"); clear();YYABORT;}
      }
      flags.reset();
}
|
//yangl: imac: MR +=/-= tm*tn
imacmaclause_mr_equ_tm_tn_inside {
  if(tm->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IFMAC_Mul inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
  if(tn->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IFMAC_Mul inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu

  unsigned treg = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);//for unused tp in imac
  revt = OPERAND(Reg, treg, @$.S, @$.E);
  
  //ducx
  if(flags[CF])
//    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (flags[CRF] << 3) | (flags[FF] << 2) | (flags[PF] << 1) | (1 << 0);
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (0 << 3) | (flags[FF] << 2) | (flags[PF] << 1) | (1 << 0);
  else if(flags[RF])
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1) | flags[CRF];
  else if(flags[IF])
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1) | flags[SENDF];
  else
    flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (~flags[UF] << 3) | (flags[FF] << 2) | (flags[PF] << 1);

  //ducx 20180801
  if(flags[CF] && flags[CRF])
  {
    llvmerror(&@1, "Incorrect IFMAC_Mul inst! C and CR should not coexist!");clear();YYABORT;
  }


    
    //ducx:for abs mul
  if(isIMACABS)
    flagsort &= 0b110111;
    
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    {llvmerror(&@1, "ifmac ShiftMode0/1/2/3 flag error!");clear();YYABORT;}
    //flagsort = 0x2;
  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  //flags.reset();
  
  
  if (flags[LF])
   {llvmerror(&@1, "IMAC/IFMAC_MR_Mul L flag error,available flags are CR,U,P,T,F,C/Send,ShiftMode0/1/2/3 ");clear();YYABORT;};//niuxx
  
  
   //use "to shu" case
  switch ($1) {
    case 0: //real add
    ADDOPERAND(Opc, UCPM::IFMARealaddToSHU, @$.S, @$.E); 
    break;      
    case 1: //real sub
    ADDOPERAND(Opc, UCPM::IFMARealsubToSHU, @$.S, @$.E); 
    break;     
    case 2: //complex add
    ADDOPERAND(Opc, UCPM::IFMACompaddToSHU, @$.S, @$.E); 
    break;  
    case 3: //complex sub
    ADDOPERAND(Opc, UCPM::IFMACompsubToSHU, @$.S, @$.E); 
    break;
  }
  //Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
  ADDOPERAND(Reg, UCPMReg::IALUBIU0, @$.S, @$.E);
  //Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
  ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
  Operands.push_back(nullptr);
  condpos = Operands.size();
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
  if(isTnValid == true)
    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
  else
    ADDOPERAND(Reg, UCPMReg::T7, @$.S, @$.E);//Tn=1, binary: 0x111
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
  ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
  //for imac abs bit
      f = OPERAND(Imm, 0, FlagS, FlagE);
      ff = OPERAND(Imm, 1, FlagS, FlagE);
      if(isIMACABS)
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
      else
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      //for imac B/S/R/I, or B/S/W flag
      if(!isIMACABS) {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[RF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else if(flags[IF])
          ADDOPERAND(Reg, UCPMReg::T3, @$.S, @$.E);
        else
          {llvmerror(&@1, "ifmac B/R/S/I flag error!"); clear();YYABORT;}
      }
      else {
        if(flags[BF])
          ADDOPERAND(Reg, UCPMReg::T0, @$.S, @$.E);
        else if(flags[SF])
          ADDOPERAND(Reg, UCPMReg::T1, @$.S, @$.E);
        else if(flags[WF])
          ADDOPERAND(Reg, UCPMReg::T2, @$.S, @$.E);
        else
          {llvmerror(&@1, "ifmac B/S/W flag error!"); clear();YYABORT;}
      }
      flags.reset();
}
|
//yangl: UCP_M, start IMAC MulAV
imacMulAVclause ASSIGNTO ifmacdest {
    if (!isTpValid)
    {
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFMAC_MulAV inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFMAC_MulAV inst! Tl should be T0-T5!");clear();YYABORT;}//niuxu
      if(tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFMAC_MulAV inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu    
    }
    else if (isTpMR)
    {
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFMAC_MulAV inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFMAC_MulAV inst! Tl should be T0-T5!");clear();YYABORT;}//niuxu
      if(tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFMAC_MulAV inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu    
    }
    else
    {
      if(tm->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFMAC_MulAV inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFMAC_MulAV inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
      if(tp->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFMAC_MulAV inst! Tl should be T0-T5!");clear();YYABORT;}//niuxu
      if(tk->getReg() > UCPMReg::T5)
	 {llvmerror(&@1, "Incorrect IFMAC_MulAV inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
    }
    
     if (unit4 != NULL)
     {
	switch (unit4->getReg())
	{
	  case  UCPMReg::IMACIALU:
	    if (ut->getReg() > UCPMReg::T5)
	       {llvmerror(&@3, "Incorrect IFMAC_MulAV inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;
	  case UCPMReg::IMACIFALU:
	    if (ut->getReg() > UCPMReg::T5)
	       {llvmerror(&@3, "Incorrect IFMAC_MulAV inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;     
	  case UCPMReg::IMACIMAC:
	    if (ut->getReg() > UCPMReg::T5)
	       {llvmerror(&@3, "Incorrect IFMAC_MulAV inst! IMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	  break;     
	}
     }      

  flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (flags[FF] << 2) | (flags[PF] << 1);
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    {llvmerror(&@1, "ifmac MulAV ShiftMode0/1/2/3 flag error!");clear();YYABORT;}
    //flagsort = 0x2;
  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
  sia = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  flagsort = flags[SHIFTF];
  dis = OPERAND(Imm, flagsort, FlagS, FlagE); 
  
  if(flags[BF])
    ImacMuAA_BSflag = 0;
  else if(flags[SF])
    ImacMuAA_BSflag = 1;
  else
    {llvmerror(&@1, "ifmac MulAV B/S flag error!"); clear();YYABORT;}
  flags.reset();  
  
  switch ($3){
    case 0://to shu
      ADDOPERAND(Opc, UCPM::IFMACMulAVToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tn in MulAV
        //it's tp as 0 in MulAV
        unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);//for unused tp in imac
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV
      }
      else if(isTpMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV
      }
      else {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tl in MulAV
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
      //goto ifmacmulAVBIU_add;
      break;
    case 1://to macc
      ADDOPERAND(Opc, UCPM::IFMACMulAVToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();     
      if(!isTpValid) {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tn in MulAV
        //it's tp as 0 in MulAV
        unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);//for unused tp in imac
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV

      }
      else if(isTpMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV
      }
      else {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tl in MulAV
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
      //goto ifmacmulAVBIU_add;
      break;
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFMACMulAVToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tn in MulAV
        //it's tp as 0 in MulAV
        unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);//for unused tp in imac
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV

      }
      else if(isTpMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV
      }
      else {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tl in MulAV
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
      //goto ifmacmulAVBIU_add;
      break;
         
    case 4://to m[s++/i++/a++]
      ADDOPERAND(Opc, UCPM::IFMACMulAVToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tn in MulAV
        //it's tp as 0 in MulAV
        unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);//for unused tp in imac
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV

      }
      else if(isTpMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV
      }
      else {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tl in MulAV
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
      //goto ifmacmulAVBIU_add;
      break;
    case 5://to m[dis{shift}]
      ADDOPERAND(Opc, UCPM::IFMACMulAVToMDis, @$.S, @$.E);         
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tn in MulAV
        //it's tp as 0 in MulAV
        unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);//for unused tp in imac
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV

      }
      else if(isTpMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV
      }
      else {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tl in MulAV
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
      //goto ifmacmulAVBIU_add;
      break;
    
    case 9://to _IMAC.MR
      ADDOPERAND(Opc, UCPM::IFMACMulAVToBIU2, @$.S, @$.E); 
      ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tn in MulAV
        //it's tp as 0 in MulAV
        unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);//for unused tp in imac
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV
      }
      else if(isTpMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV
      }
      else {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tl in MulAV
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
      break;
      
      
    case 6://to biu0  
      ADDOPERAND(Opc, UCPM::IFMACMulAVToBIU0, @$.S, @$.E); goto ifmacmulAVBIU;  
    case 7://to biu1  
      ADDOPERAND(Opc, UCPM::IFMACMulAVToBIU1, @$.S, @$.E); goto ifmacmulAVBIU;      
    case 8://to biu2  
      ADDOPERAND(Opc, UCPM::IFMACMulAVToBIU2, @$.S, @$.E); goto ifmacmulAVBIU;  
  
ifmacmulAVBIU:      

      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if(!isTpValid) {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tn in MulAV
        //it's tp as 0 in MulAV
        unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(6);//for unused tp in imac
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV

      }
      else if(isTpMR) {//tp == MR
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); 
	unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);
        revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV
      }
      else {
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tm in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tk)); //it's tn in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tp in MulAV
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tl in MulAV
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
      break;
      
    default:
      llvmerror(&@3, "ifmac MulAV dest error!"); 
      break;      
  }

}
|
imacMulAVclause_inside {
  if(tm->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IFMAC_MulAV inst! Tm should be T0-T5!");clear();YYABORT;}//niuxu
  if(tn->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IFMAC_MulAV inst! Tl should be T0-T5!");clear();YYABORT;}//niuxu
  if(tp->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IFMAC_MulAV inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu 
      
  flagsort = (flags[LF] << 5) | (flags[TF] << 4) | (flags[FF] << 2) | (flags[PF] << 1);
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  //SHIFT flag
  if(flags[S0F])
    flagsort = 0x0;
  else if(flags[S1F])
    flagsort = 0x1;
  else if(flags[S2F])
    flagsort = 0x2;
  else if(flags[S3F])
    flagsort = 0x3;
  else
    {llvmerror(&@1, "ifmac MulAV ShiftMode0/1/2/3 flag error!");clear();YYABORT;}
    //flagsort = 0x2;
  shift = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  if(flags[BF])
    ImacMuAA_BSflag = 0;
  else if(flags[SF])
    ImacMuAA_BSflag = 1;
  else
    {llvmerror(&@1, "ifmac MulAV B/S flag error!"); clear();YYABORT;}
  flags.reset();  
  
  ADDOPERAND(Opc, UCPM::IFMACMulAVMRACC1, @$.S, @$.E); 
  Operands.push_back(nullptr);
  condpos = Operands.size();
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); //it's tm in MulAV
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp)); //it's tn in MulAV
  //it's tp as MR in MulAV
  unsigned tp_mr = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(7);//for unused tp in imac
  revt = OPERAND(Reg, tp_mr, @$.S, @$.E);
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(revt));
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn)); //it's tl in MulAV
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(shift));
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
  ADDOPERAND(Imm, ImacMuAA_BSflag, @$.S, @$.E);
  break;
}//end IMAC MulAV
|
imacwaitclause{
  ADDOPERAND(Opc, UCPM::IFMACWait, @$.S, @$.E); 
  Operands.push_back(nullptr);
  condpos = Operands.size();
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
}
/*|
imacsettisflag{
  flagsort = (flags[LF] << 4);
  if(flags[NF])
    ;
  else if(flags[CF])
    flagsort |= (0x1);
  else if(flags[VF])
    flagsort |= (0x1 << 1);
  else if(flags[MCF])
    flagsort |= (0x1 << 2);
  else if(flags[MVF]) {
    flagsort |= (0x1 << 2);
    flagsort |= (0x1);
  }   
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  ADDOPERAND(Opc, UCPM::IFMACSetTIsFLAG, @$.S, @$.E); 
  Operands.push_back(nullptr);
  condpos = Operands.size();
  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
}*/
| setCGInstr{
            
          flagsort = (flags[ONF]);
          f = OPERAND(Imm, flagsort, FlagS, FlagE);	
	  flags.reset();
	   
	    ADDOPERAND(Opc, UCPM::IFMACSetCG, @$.S, @$.E);
	    Operands.push_back(nullptr);
	    condpos = Operands.size();
	    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));  
    
}
| TpToMRInstr ASSIGNTO MR{
          if(tm->getReg() > UCPMReg::T5)
	      {llvmerror(&@1, "Incorrect IFMAC_SendMR inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu  
            
          flagsort = (flags[LF] << 2) | (flags[AF] << 1) | (flags[SF]);
          f = OPERAND(Imm, flagsort, FlagS, FlagE);	
	  flags.reset();
	   
	    ADDOPERAND(Opc, UCPM::IFMACTpToMR, @$.S, @$.E);
	    Operands.push_back(nullptr);
	    condpos = Operands.size();
	    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));  
    
}
| imacSelTpMRclause ASSIGNTO ifmacdest {
  if(tm->getReg() > UCPMReg::T5)
      {llvmerror(&@1, "Incorrect IMAC_Sel inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu

  flagsort =  (flags[LF] << 4) | (flags[AF] << 3) | (flags[SF] << 2);  
    
  if(flags[HHF])
    flagsort |= 0b00011;
  else if(flags[LLF])
    ;
  else if(flags[HLF])
    flagsort |= 0b00010;
  else
    {llvmerror(&@1, "ifmac SelTpMR HH/LL/HL flag error!"); clear();YYABORT;}
    
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  
  switch ($3){
 
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::IFMACSelTpMRToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      goto ifmacSelTpMR_add;
      break;     
  
   case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      ADDOPERAND(Opc, UCPM::IFMACSelTpMRToBIU2, @$.S, @$.E);
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm)); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));    
      goto ifmacSelTpMR_add;
      break;
      
      
ifmacSelTpMR_add:    
    //deal with additional dest
      switch (imac_additional_dest) {
        case 0:
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;        
        case 1: //_IMAC.T0 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@3, "ifmac additional dest error!"); clear();YYABORT;
          break;
      }
      break;
      
    default:
      llvmerror(&@3, "ifmac dest error!"); clear();YYABORT;
      break;      
  }
  flags.reset();
};//end ifmac_imacinst

ifmacinst: ifmacclause ASSIGNTO ifmacdest {//niuxiaoxu     
  if (unit4 != NULL)
  {
    switch (unit4->getReg())
    {
      case  UCPMReg::IMACIALU:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IFMAC_FMul/Add/Sub inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;
      case UCPMReg::IMACIFALU:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IFMAC_FMul/Add/Sub inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;     
      case UCPMReg::IMACIMAC:
	if (ut->getReg() > UCPMReg::T5)
	    {llvmerror(&@3, "Incorrect IFMAC_FMul/Add/Sub inst! IMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
      break;     
    }
  }     

  flagsort = (flags[TF] );
  if($1 == 0)//FMUL
    ;
  else if($1 == 1)//FADD
    flagsort |= (1 << 2);
  else if($1 == 2) {//FSUB
    flagsort |= (1 << 2);
    flagsort |= (1 << 1);
  }
  f = OPERAND(Imm, flagsort, FlagS, FlagE);
  
   switch ($3){
    case 0://to shu
      ADDOPERAND(Opc, UCPM::_IFMACToSHU, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit3));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();  
      if($1==2){
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//it's tn in fmac instruction
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//it's tp in fmac instruction
      }
      else{
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//it's tn in fmac instruction
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//it's tp in fmac instruction
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      goto ifmacBIU_add;
      break;

    case 1://to macc
      ADDOPERAND(Opc, UCPM::_IFMACToMACC, @$.S, @$.E); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit4));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();     
      if($1==2){
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//it's tn in fmac instruction
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//it's tp in fmac instruction
      }
      else{
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//it's tn in fmac instruction
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//it's tp in fmac instruction
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      goto ifmacBIU_add;
      break;
    case 3://to m[t]
      ADDOPERAND(Opc, UCPM::_IFMACToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if($1==2){
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//it's tn in fmac instruction
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//it's tp in fmac instruction
      }
      else{
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//it's tn in fmac instruction
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//it's tp in fmac instruction
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      goto ifmacBIU_add;
      break;
    case 4://to m[s++/i++/a++]
      flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
      sia = OPERAND(Imm, flagsort, FlagS, FlagE);
      
      ADDOPERAND(Opc, UCPM::_IFMACToMSIA, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();   
      if($1==2){
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//it's tn in fmac instruction
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//it's tp in fmac instruction
      }
      else{
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//it's tn in fmac instruction
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//it's tp in fmac instruction
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      goto ifmacBIU_add;
      break;
    case 5://to m[dis{shift}]
      flagsort = flags[SHIFTF];
      dis = OPERAND(Imm, flagsort, FlagS, FlagE);  
  
      ADDOPERAND(Opc, UCPM::_IFMACToMDis, @$.S, @$.E);         
      Operands.push_back(nullptr);
      condpos = Operands.size();   
      if($1==2){
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//it's tn in fmac instruction
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//it's tp in fmac instruction
      }
      else{
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//it's tn in fmac instruction
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//it's tp in fmac instruction
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      goto ifmacBIU_add;
      break;
      
    case 6://to biu0  
      ADDOPERAND(Opc, UCPM::_IFMACToBIU0, @$.S, @$.E); goto ifmacBIU;  
    case 7://to biu1  
      ADDOPERAND(Opc, UCPM::_IFMACToBIU1, @$.S, @$.E); goto ifmacBIU;      
    case 8://to biu2  
      ADDOPERAND(Opc, UCPM::_IFMACToBIU2, @$.S, @$.E); goto ifmacBIU;  
  
    case 9://to _IMAC.t/_IMAC.MR/_IMAC.t&MR
      ADDOPERAND(Opc, UCPM::_IFMACToBIU2, @$.S, @$.E);
      if(imac_additional_dest >= 7 && imac_additional_dest <= 12) // _IMAC.T & MR
          ADDOPERAND(Reg, UCPMReg::InsideTwithMR, @$.S, @$.E);
      else if(imac_additional_dest >= 17 && imac_additional_dest <= 20)// _IMAC.T1/T2/T4/T5
          ADDOPERAND(Reg, UCPMReg::InsideTwithoutMR, @$.S, @$.E);
      else if(imac_additional_dest >= 14 && imac_additional_dest <= 16)// _IMAC.T0/T3/MR
	  ADDOPERAND(Reg, UCPMReg::T0T3MR, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if($1==2){
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//it's tn in fmac instruction
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//it's tp in fmac instruction
      }
      else{
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//it's tn in fmac instruction
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//it's tp in fmac instruction
      }  
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      goto ifmacBIU_add;
      break;
      
ifmacBIU:      
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if($1==2){
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//it's tn in fmac instruction
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//it's tp in fmac instruction
      }
      else{
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));//it's tn in fmac instruction
         Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));//it's tp in fmac instruction
      }
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      goto ifmacBIU_add;
      break;
      
    default:
      llvmerror(&@3, "ifmac dest error!"); clear();YYABORT;
      break;      
  }
ifmacBIU_add:
  //deal with additional dest
      switch (imac_additional_dest) {
        case 0:
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;        
        case 1: //_IMAC.T0 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 2://_IMAC.T1 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 3://_IMAC.T2 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;        
        case 4://_IMAC.T3 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;        
        case 5://_IMAC.T4 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 6://_IMAC.T5 AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 7:// _IMAC.T0 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 8:// _IMAC.T1 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break;
        case 9:// _IMAC.T2 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break;
        case 10:// _IMAC.T3 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 11:// _IMAC.T4 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break;
        case 12:// _IMAC.T5 AND MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break;
        case 13://_IMAC.MR AND imacdest
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 14://_IMAC.T0
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 15://_IMAC.T3
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        case 16://_IMAC.MR
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 17://_IMAC.T1
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_NULL, @$.S, @$.E);
          break; 
        case 18://_IMAC.T2
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_MR, @$.S, @$.E);
          break; 
        case 19://_IMAC.T4
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T0, @$.S, @$.E);
          break; 
        case 20://_IMAC.T5
          ADDOPERAND(Reg, UCPMReg::IMAC_ADDITIONALDEST_T3, @$.S, @$.E);
          break; 
        default:
          llvmerror(&@3, "ifmac additional dest error!"); clear();YYABORT;
          break;
      }
  flags.reset();
} //end ifmacinst
;

ifmacsetcond: IMMSYM DOT IMM5 ASSIGNTO IFMAC DOT SETCOND LBRACKET IMM5 RBRACKET 
	           {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $9, @9.S, @9.E);}; 
	           
ifmacclause: fmul {
	     $$ = 0;
	     if(tm->getReg() > UCPMReg::T5)
		{llvmerror(&@1, "Incorrect IFMAC_Mul_Float inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
	     if(tn->getReg() > UCPMReg::T5)
		{llvmerror(&@1, "Incorrect IFMAC_Mul_Float inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu
	     } |
             ifaddclause {
             $$ = 1;
             if(tm->getReg() > UCPMReg::T5)
		{llvmerror(&@1, "Incorrect IFMAC_Add inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu
	     if(tn->getReg() > UCPMReg::T5)
		{llvmerror(&@1, "Incorrect IFMAC_Add inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu
             } |
             ifsubclause {
             $$ = 2;
	     if(tm->getReg() > UCPMReg::T5)
		{llvmerror(&@1, "Incorrect IFMAC_Sub inst! Tp should be T0-T5!");clear();YYABORT;}//niuxu
	     if(tn->getReg() > UCPMReg::T5)
		{llvmerror(&@1, "Incorrect IFMAC_Sub inst! Tn should be T0-T5!");clear();YYABORT;}//niuxu             
             };
            
fmul: t MUL t _flag FLOAT flag_ _flag ifmacTflag flag_ | 
      t MUL t _flag FLOAT flag_ ;
      
ifaddclause: addexp _flag ifmacTflag flag_ | addexp ;
ifsubclause: subexp _flag ifmacTflag flag_ | subexp ;  

//ducx 20180130
ifmacASdest: IFMAC DOT t {
	      $$ = 0;
	      if($3 > 5)
		{llvmerror(&@3, "Incorrect IFMAC inst! IFMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	      }   
          | mindexn AND IFALU DOT t{
	    $$ = 1; 
	    ImacToialu_flag = 1;
	    if($5 > 5)
		{llvmerror(&@3, "Incorrect IFMAC inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
          }
          | mindexn AND SHU1 DOT t {$$ = 1; ImacToialu_flag = 0;}
          | mindexsia AND IFALU DOT t{
	    $$ = 2; 
	    ImacToialu_flag = 1;
	    if($5 > 5)
		{llvmerror(&@3, "Incorrect IFMAC inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	    }
          | mindexsia AND SHU1 DOT t{$$ = 2; ImacToialu_flag = 0;}
          | mindexdis AND IFALU DOT t{
	    $$ = 3; 
	    ImacToialu_flag = 1;
	    if($5 > 5)
		{llvmerror(&@3, "Incorrect IFMAC inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	    } 
          | mindexdis AND SHU1 DOT t{$$ = 3; ImacToialu_flag = 0;} 
          | _IFMAC DOT t {llvmerror(&@1, "IFMAC dest error!"); clear();YYABORT;}
          | IMAC DOT t {llvmerror(&@1, "IFMAC dest error!"); clear();YYABORT;}
          | _IMAC DOT t {llvmerror(&@1, "IFMAC dest error!"); clear();YYABORT;};
          
//ifmacdest: imacdest;
ifmacdest: shut {$$ = 0; imac_additional_dest = 0;} 
          | maccdest {$$ = 1; imac_additional_dest = 0;}    
          | mindexn {$$ = 3; imac_additional_dest = 0;}
          | mindexsia {$$ = 4; imac_additional_dest = 0;}
          | mindexdis {$$ = 5; imac_additional_dest = 0;} 
          | imacbiut0{$$ = 6; imac_additional_dest = 0;}
          | imacbiut1{$$ = 7; imac_additional_dest = 0;}
          | imacbiut2{$$ = 8; imac_additional_dest = 0;};
          
ifmacdest: IFMAC DOT t AND ifmacdest {
            $$ = $5;         
            if($3 == 0) //additional T0
              imac_additional_dest = 1; 
            else if($3 == 1) //additional T1
              imac_additional_dest = 2; 
            else if($3 == 2) //additional T2
              imac_additional_dest = 3; 
            else if($3 == 3) //additional T3
              imac_additional_dest = 4; 
            else if($3 == 4) //additional T4
              imac_additional_dest = 5; 
            else if($3 == 5) //additional T5
              imac_additional_dest = 6; 
            else 
	      {llvmerror(&@3, "Incorrect IFMAC inst! IFMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
          } 
          | IFMAC DOT MR AND ifmacdest {imac_additional_dest = 13; $$ = $5; }
          | IFMAC DOT t AND MR {
              $$ = 9;        
            if($3 == 0) //additional T0
              imac_additional_dest = 7; 
            else if($3 == 1) //additional T1
              imac_additional_dest = 8; 
            else if($3 == 2) //additional T2
              imac_additional_dest = 9; 
            else if($3 == 3) //additional T3
              imac_additional_dest = 10; 
            else if($3 == 4) //additional T4
              imac_additional_dest = 11; 
            else if($3 == 5) //additional T5
              imac_additional_dest = 12;  
            else
	      {llvmerror(&@3, "Incorrect IFMAC inst! IFMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
            }  
          | _IFMAC DOT t{
              $$ = 9;
            if($3 == 0) //additional T0
              imac_additional_dest = 14; 
            else if($3 == 1) //additional T1
              imac_additional_dest = 17; 
            else if($3 == 2) //additional T2
              imac_additional_dest = 18; 
            else if($3 == 3) //additional T3
              imac_additional_dest = 15; 
            else if($3 == 4) //additional T4
              imac_additional_dest = 19; 
            else if($3 == 5) //additional T5
              imac_additional_dest = 20;  
            else 
             {llvmerror(&@3, "Incorrect IFMAC inst! _IFMAC.Tt should be T0-T5!");clear();YYABORT;}//niuxu
            }
            | _IFMAC DOT MR{$$ = 9;imac_additional_dest = 16; }|
  
	    IFMAC DOT t { llvmerror(&@1, "IFMAC dest error!"); clear();YYABORT;}|//niuxx  
	    IFMAC DOT MR { llvmerror(&@1, "IFMAC dest error!"); clear();YYABORT;}|//niuxx
	    _IMAC DOT t {llvmerror(&@1, "IFMAC dest error!"); clear();YYABORT;};//niuxx
//yangl end IFMAC



// ducx start biu --------------------------------------------------
biuslot: biu0code { if(hasErr)
                    {  hasErr = false;
                       llvmerror(&@1, "Incorrect BIU0 inst.");clear();YYABORT;
                    }
                    $$ = 0;
                  } 
       | biu1code { if(hasErr)
                    {  hasErr = false;
                       llvmerror(&@1, "Incorrect BIU1 inst.");clear();YYABORT;
                    }
                    $$ = 1;
                  } 
       | biu2code { if(hasErr)
                    {  hasErr = false;
                       llvmerror(&@1, "Incorrect BIU2 inst.");clear();YYABORT;
                    }
                    $$ = 2;
                  } ;
biu0code: BIU0 DOT biu0inst | setcond0Instr | imm0Instr;
biu1code: BIU1 DOT biu1inst | setcond1Instr | imm1Instr;
biu2code: BIU2 DOT biu2inst | setcond2Instr | imm2Instr;

biuslot:   BIU0 DOT error { llvmerror(&@1, "Incorrect BIU0 inst."); clear();YYABORT;} |
           BIU1 DOT error { llvmerror(&@1, "Incorrect BIU1 inst."); clear();YYABORT;} |
           BIU2 DOT error { llvmerror(&@1, "Incorrect BIU2 inst."); clear();YYABORT;} ;
           
biu0inst: ldselect ASSIGNTO biu0dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::bBIU0: 
	    case UCPMReg::bBIU1: 
	    case UCPMReg::bBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect BIU0_Load inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::biuIALU:
	      if(ut->getReg() > UCPMReg::T5)
		{llvmerror(&@3, "Incorrect BIU0_Load inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::biuIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect BIU0_Load inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::biuIFALU:
	      if(ut->getReg() > UCPMReg::T5)
		{llvmerror(&@3, "Incorrect BIU0_Load inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::biuIFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect BIU0_Load inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }       

    flagsort =  (flags[MF] << 2) | (flags[APPF] << 1) | flags[BRF];
    f = OPERAND(Imm, flagsort, FlagS, FlagE);
    
    switch ($3) {
    
        case 0://to biu0
	  switch ($1) {
	    case 0://lddis
    
	      //qlh flag
	      if(flags[LF])
		  flagsort = 0x0;
	      else if(flags[QHF])
		  flagsort = 0x1;
	      else if(flags[QLF])
		  flagsort = 0x2;
	      qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();
        
	      ADDOPERAND(Opc, UCPM::BIU0disLdToBIU, @$.S, @$.E); 
              Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh));
            break;
        
            case 1://ldstep
    
	      if(flags[RF])
		  flagsort = 0x1;	     
	      else
		  flagsort = 0x0;
	      rf = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();

	      ADDOPERAND(Opc, UCPM::BIU0ComLdToBIU, @$.S, @$.E); 
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(rf));
	    break;

	  default:
	  llvmerror(&@1, "invalid BIU0Ld instruction!");clear();YYABORT;
	  break;
       }
       break;
       
	case 1://to shu
          switch ($1) {
	    case 0://lddis
    
	      //qlh flag
	      if(flags[LF])
		  flagsort = 0x0;
	      else if(flags[QHF])
		  flagsort = 0x1;
	      else if(flags[QLF])
		  flagsort = 0x2;
	      qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();
        
	      ADDOPERAND(Opc, UCPM::BIU0disLdToSHU, @$.S, @$.E); 
              Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh));
            break;
        
            case 1://ldstep
            
              if(flags[RF])
		  flagsort = 0x1;	     
	      else
		  flagsort = 0x0;
	      rf = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();
 
	      ADDOPERAND(Opc, UCPM::BIU0ComLdToSHU, @$.S, @$.E); 
    
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(rf));	      

	    break;

	  default:
	  llvmerror(&@1, "invalid BIU0Ld instruction!");clear();YYABORT;
	  break;
       }
       break;
        
        case 2://to maccI
        
/*             if(ipath->getImm() == 0)
		flagsort = 0x0;
	     else if(ipath->getImm() == 6)
		flagsort = 0x1;
	     else {
                llvmerror(&@1, "BIU0 to IMAC/IALU must use port I0 or I6"); 
                clear();YYABORT;
             }*/

             switch(ipath->getImm())
             {
		case 0:
		  flagsort = 0;
		  break;
		case 1:
		  flagsort = 1;
		  break;
		case 2:
		  flagsort = 2;
		  break;
		case 6:
		  flagsort = 3;
		  break;
		default:
		   llvmerror(&@1, "BIU0 to IMAC/IALU must use port I0/I1/I2/I6"); 
                   clear();YYABORT;
             }
             
	     ff = OPERAND(Imm, flagsort, FlagS, FlagE);
	     //flags.reset();
	      
          switch ($1) {
	    case 0://lddis
    
	      //qlh flag
	      if(flags[LF])
		  flagsort = 0x0;
	      else if(flags[QHF])
		  flagsort = 0x1;
	      else if(flags[QLF])
		  flagsort = 0x2;
	      qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();
        
	      ADDOPERAND(Opc, UCPM::BIU0disLdToMACCI, @$.S, @$.E); 
              Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
            break;
        
            case 1://ldstep
    
	      if(flags[RF])
		  flagsort = 0x1;	     
	      else
		  flagsort = 0x0;
	      rf = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();

	      ADDOPERAND(Opc, UCPM::BIU0ComLdToMACCI, @$.S, @$.E); 
    
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(rf));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));

	    break;

	  default:
	  llvmerror(&@1, "invalid BIU0Ld instruction!");clear();YYABORT;
	  break;
       }
       break;
       
       case 6://to maccIF
       
/*       if(ipath->getImm() == 4)
		flagsort = 0x0;
       else {
                llvmerror(&@1, "BIU0 to IFMAC/IFALU must use port I4"); 
                clear();YYABORT;
             }*/
             
             switch(ipath->getImm())
             {
		case 3:
		  flagsort = 0;
		  break;
		case 4:
		  flagsort = 1;
		  break;
		case 5:
		  flagsort = 2;
		  break;
		default:
		   llvmerror(&@1, "BIU0 to IFMAC/IFALU must use port I3/I4/I5"); 
                   clear();YYABORT;
             }
             
       ff = OPERAND(Imm, flagsort, FlagS, FlagE);
       //flags.reset();      
          switch ($1) {
	    case 0://lddis
    
	      //qlh flag
	      if(flags[LF])
		  flagsort = 0x0;
	      else if(flags[QHF])
		  flagsort = 0x1;
	      else if(flags[QLF])
		  flagsort = 0x2;
	      qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();
        
	      ADDOPERAND(Opc, UCPM::BIU0disLdToMACCIF, @$.S, @$.E); 
              Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
            break;
        
            case 1://ldstep
    
	      if(flags[RF])
		  flagsort = 0x1;	     
	      else
		  flagsort = 0x0;
	      rf = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();

	      ADDOPERAND(Opc, UCPM::BIU0ComLdToMACCIF, @$.S, @$.E); 
    
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(rf));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));

	    break;

	  default:
	  llvmerror(&@1, "invalid BIU0Ld instruction!");clear();YYABORT;
	  break;
       }
       break;
       
        case 3://to Wx.m[t]
       
	     if(flags[W0F])
		flagsort = 0x0;
	     else if(flags[W2F])
		flagsort = 0x1;
	      else {
		llvmerror(&@1, "Only W0/W2 can be used for BIU0.");
		clear();YYABORT;}
		ff = OPERAND(Imm, flagsort, FlagS, FlagE);
	      
	  switch ($1) {
	    case 0://lddis
    
	      //qlh flag
	      if(flags[LF])
		  flagsort = 0x0;
	      else if(flags[QHF])
		  flagsort = 0x1;
	      else if(flags[QLF])
		  flagsort = 0x2;
	      qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
	      
	      flags.reset();
        
	      ADDOPERAND(Opc, UCPM::BIU0disLdToM, @$.S, @$.E); 
              Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
              Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
            break;
        
            case 1://ldstep
    
	      if(flags[RF])
		  flagsort = 0x1;	     
	      else
		  flagsort = 0x0;
	      rf = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();

	      ADDOPERAND(Opc, UCPM::BIU0ComLdToM, @$.S, @$.E); 
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(rf));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	    break;

	  default:
	  llvmerror(&@1, "invalid BIU0Ld instruction!");clear();YYABORT;
	  break;
       }
       break;
       
         case 4://to Wx.m[s++,i++,a++]
       
	     if(flags[W0F])
		flagsort = 0x0;
	     else if(flags[W2F])
		flagsort = 0x1;
	      else {
		llvmerror(&@1, "Only W0/W2 can be used for BIU0.");
		clear();YYABORT;}
	      ff = OPERAND(Imm, flagsort, FlagS, FlagE);
	      
	     flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
		sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	  switch ($1) {
	    case 0://lddis
    
	      //qlh flag
	      if(flags[LF])
		  flagsort = 0x0;
	      else if(flags[QHF])
		  flagsort = 0x1;
	      else if(flags[QLF])
		  flagsort = 0x2;
	      qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
	      
	      flags.reset();
        
	      ADDOPERAND(Opc, UCPM::BIU0disLdToMSIA, @$.S, @$.E); 
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
            break;
        
            case 1://ldstep
    
	      if(flags[RF])
		  flagsort = 0x1;	     
	      else
		  flagsort = 0x0;
	      rf = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();

	      ADDOPERAND(Opc, UCPM::BIU0ComLdToMSIA, @$.S, @$.E); 
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(rf));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
	    break;

	  default:
	  llvmerror(&@1, "invalid BIU0Ld instruction!");clear();YYABORT;
	  break;
       }
       break;
       
       case 5://to Wx.m[dis(flag)]
       
	     if(flags[W0F])
		flagsort = 0x0;
	     else if(flags[W2F])
		flagsort = 0x1;
	     else {
		llvmerror(&@1, "Only W0/W2 can be used for BIU0.");
		clear();YYABORT;}
	      ff = OPERAND(Imm, flagsort, FlagS, FlagE);
	      
	     flagsort = flags[SHIFTF];
	        dis = OPERAND(Imm, flagsort, FlagS, FlagE);	     
	
	  switch ($1) {
	    case 0://lddis
    
	      //qlh flag
	      if(flags[LF])
		  flagsort = 0x0;
	      else if(flags[QHF])
		  flagsort = 0x1;
	      else if(flags[QLF])
		  flagsort = 0x2;
	      qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
	      
	      flags.reset();
        
	      ADDOPERAND(Opc, UCPM::BIU0disLdToDIS, @$.S, @$.E); 
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
            break;
        
            case 1://ldstep
    
	      if(flags[RF])
		  flagsort = 0x1;	     
	      else
		  flagsort = 0x0;
	      rf = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();

	      ADDOPERAND(Opc, UCPM::BIU0ComLdToDIS, @$.S, @$.E); 
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(rf));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
	    break;

	  default:
	  llvmerror(&@1, "invalid BIU0Ld instruction!");clear();YYABORT;
	  break;
       }
       break;
       
    default:
    llvmerror(&@3, "invalid BIU0 dest!");clear();YYABORT;
    break;
    }
   

}
| stinst{
      if(tm->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU0_Store inst! Tm should be T0-T3!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU0_Store inst! Ts should be T0-T3!");clear();YYABORT;}//niuxu  
 
	flagsort = (flags[RF] << 3) | (flags[MF] << 2) | (flags[APPF] << 1) | flags[BRF];
	f = OPERAND(Imm, flagsort, FlagS, FlagE);
     
        //qlh flag
        if(flags[LF])
            flagsort = 0x0;
        else if(flags[HF])
            flagsort = 0x1;
        else if(flags[QF])
            flagsort = 0x2;
        else
            flagsort = 0x3;
        qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
        
      ADDOPERAND(Opc, UCPM::BIU0St, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();  
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh));      
  
}
| binInstr{
      if(tm->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU0 inst! Ts0 should be T0-T3!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU0 inst! Ts1 should be T0-T3!");clear();YYABORT;}//niuxu   
      if(tp->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU0 inst! Tm should be T0-T3!");clear();YYABORT;}//niuxu 
	 
      ADDOPERAND(Opc, UCPM::BIU0Bin, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if (imm2 == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm2));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if (imm1 == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));
     
}
| shiftInstr{
      if(tm->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU0 inst! Ts1 should be T0-T3!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU0 inst! Tm should be T0-T3!");clear();YYABORT;}//niuxu   
	 
      ADDOPERAND(Opc, UCPM::BIU0Shift, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if (imm1 == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));
      if (imm2 == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm2));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
     
}
| compareInstr{
      if(tm->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU0_Compare inst! Ts1 should be T0-T3!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU0_Compare inst! Tm should be T0-T3!");clear();YYABORT;}//niuxu  
	 
      ADDOPERAND(Opc, UCPM::BIU0Com, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      //Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if (imm1 == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm2));
     
}
| notInstr{
      if(tm->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU0_Not inst! Ts1 should be T0-T3!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU0_Not inst! Tm should be T0-T3!");clear();YYABORT;}//niuxu 
	 
      ADDOPERAND(Opc, UCPM::BIU0NOT, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      //Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if (imm1 == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));
     
}
| movInstr{
      if(tm->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU0_Mov inst! Ts0 should be T0-T3!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU0_Mov inst! Tm should be T0-T3!");clear();YYABORT;}//niuxu         
       
        if(flags[BF])
            flagsort = 0x0;
        else if(flags[SF])
            flagsort = 0x1;
        else 
            flagsort = 0x2;
        f = OPERAND(Imm, flagsort, FlagS, FlagE);
        
        if(flags[MLF])
            flagsort = 0x1;
        else if(flags[MHF])
            flagsort = 0x2;
        else if(flags[HF])
            flagsort = 0x3; 
        else 
	    flagsort = 0x0;//LF
        ff = OPERAND(Imm, flagsort, FlagS, FlagE);
        
        if(flags[dMLF])
            flagsort = 0x1;
        else if(flags[dMHF])
            flagsort = 0x2;
        else if(flags[dHF])
            flagsort = 0x3;  
        else 
	    flagsort = 0x0;//LF
        qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
        
        flags.reset();
        
      ADDOPERAND(Opc, UCPM::BIU0Mov, @$.S, @$.E);

      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if (imm1 == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));
	
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh));
     
}
| maskInstr{
      if(tm->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU0_Mask inst! Ts1 should be T0-T3!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU0_Mask inst! Tm should be T0-T3!");clear();YYABORT;}//niuxu        
       
       if(flags[BF])
	{
	    if(flags[HF])
	      flagsort = 0b100;
	    else 
	      flagsort = 0b000;
	}
        else if(flags[SF])
            flagsort = 0b001;
        else 
            flagsort = 0b010;
        f = OPERAND(Imm, flagsort, FlagS, FlagE);
        
        flags.reset();
        
      ADDOPERAND(Opc, UCPM::BIU0MaskGen, @$.S, @$.E);

      Operands.push_back(nullptr);
      condpos = Operands.size();
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if (imm1 == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));

	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	
     
}
| waitInstr{
            
      ADDOPERAND(Opc, UCPM::BIU0Wait, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    
}
| t _flag K flag_ ASSIGNTO biu0dest{
      if(tm->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU0_KG inst! Tm should be T0-T3!");clear();YYABORT;}//niuxu  
	 
             if(flags[W0F])
		flagsort = 0x0;
	     else if(flags[W2F])
		flagsort = 0x1;
	     else {
		llvmerror(&@1, "Only W0/W2 can be used for BIU0.");
		clear();YYABORT;}
		
	      ff = OPERAND(Imm, flagsort, FlagS, FlagE);
	
		      
	     flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
		sia = OPERAND(Imm, flagsort, FlagS, FlagE);
		
	     flagsort = flags[SHIFTF];
	        dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	        
	     flags.reset();
	      
    switch ($6) {
    
        case 3://to Wx.m[t]   	   	      	      
	      ADDOPERAND(Opc, UCPM::BIU0KGToM, @$.S, @$.E); 
              Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
              Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
        break;
       
        case 4://to Wx.m[s++,i++,a++]
	      ADDOPERAND(Opc, UCPM::BIU0KGToMSIA, @$.S, @$.E); 
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
         break;
         
        case 5://to Wx.m[dis(shift)]
	      ADDOPERAND(Opc, UCPM::BIU0KGToMDIS, @$.S, @$.E); 
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
         break;
       
      default:
         llvmerror(&@3,"invalid BIU0 dest");clear();YYABORT;
	//break;
    }
}
| setCGInstr{
            
          flagsort = (flags[ONF]);
          f = OPERAND(Imm, flagsort, FlagS, FlagE);	
	  flags.reset();
	   
	    ADDOPERAND(Opc, UCPM::BIU0SetCG, @$.S, @$.E);
	    Operands.push_back(nullptr);
	    condpos = Operands.size();
	    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));  
    
};
 
 
biu1inst: ldselect ASSIGNTO biu1dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::bBIU0: 
	    case UCPMReg::bBIU1: 
	    case UCPMReg::bBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect BIU1_Load inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::biuIALU:
	      if(ut->getReg() > UCPMReg::T5)
		{llvmerror(&@3, "Incorrect BIU1_Load inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::biuIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect BIU1_Load inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::biuIFALU:
	      if(ut->getReg() > UCPMReg::T5)
		{llvmerror(&@3, "Incorrect BIU1_Load inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::biuIFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect BIU1_Load inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }    
    
    flagsort = (flags[RF] << 3) | (flags[MF] << 2) | (flags[APPF] << 1) | flags[BRF];
    f = OPERAND(Imm, flagsort, FlagS, FlagE); 
	
    switch ($3) {
    
        case 0://to biu1
	  switch ($1) {
	    case 0://lddis
    
	      //qlh flag
	      if(flags[LF])
		  flagsort = 0x0;
	      else if(flags[QHF])
		  flagsort = 0x1;
	      else if(flags[QLF])
		  flagsort = 0x2;
	      qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();
        
	      ADDOPERAND(Opc, UCPM::BIU1disLdToBIU, @$.S, @$.E); 
              Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh));
            break;
        
            case 1://ldstep
    
	      if(flags[RF])
		  flagsort = 0x1;	     
	      else
		  flagsort = 0x0;
	      rf = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();

	      ADDOPERAND(Opc, UCPM::BIU1ComLdToBIU, @$.S, @$.E); 
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(rf));
	    break;

	  default:
	  llvmerror(&@1, "invalid BIU1Ld instruction!");clear();YYABORT;
	    break;
       }
       break;
       
	case 1://to shu
          switch ($1) {
	    case 0://lddis
    
	      //qlh flag
	      if(flags[LF])
		  flagsort = 0x0;
	      else if(flags[QHF])
		  flagsort = 0x1;
	      else if(flags[QLF])
		  flagsort = 0x2;
	      qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();
        
	      ADDOPERAND(Opc, UCPM::BIU1disLdToSHU, @$.S, @$.E); 
              Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh));
            break;
        
            case 1://ldstep
    
	      if(flags[RF])
		  flagsort = 0x1;	     
	      else
		  flagsort = 0x0;
	      rf = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();

	      ADDOPERAND(Opc, UCPM::BIU1ComLdToSHU, @$.S, @$.E); 
    
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(rf));

	    break;

	  default:
	  llvmerror(&@1, "invalid BIU1Ld instruction!");clear();YYABORT;
	  break;
       }
       break;
        
        case 2://to maccI
        
/*        if(ipath->getImm() == 1)
		flagsort = 0x0;
	else {
                llvmerror(&@1, "BIU1 to IMAC/IALU must use port I1"); 
                clear();YYABORT;
             }*/
             
             switch(ipath->getImm())
             {
		case 0:
		  flagsort = 0;
		  break;
		case 1:
		  flagsort = 1;
		  break;
		case 2:
		  flagsort = 2;
		  break;
		default:
		   llvmerror(&@1, "BIU1 to IMAC/IALU must use port I0/I1/I2"); 
                   clear();YYABORT;
             }
             
	ff = OPERAND(Imm, flagsort, FlagS, FlagE);
	//flags.reset();
	     
          switch ($1) {
	    case 0://lddis
    
	      //qlh flag
	      if(flags[LF])
		  flagsort = 0x0;
	      else if(flags[QHF])
		  flagsort = 0x1;
	      else if(flags[QLF])
		  flagsort = 0x2;
	      qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();
        
	      ADDOPERAND(Opc, UCPM::BIU1disLdToMACCI, @$.S, @$.E); 
              Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
            break;
        
            case 1://ldstep
    
	      if(flags[RF])
		  flagsort = 0x1;	     
	      else
		  flagsort = 0x0;
	      rf = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();

	      ADDOPERAND(Opc, UCPM::BIU1ComLdToMACCI, @$.S, @$.E); 
    
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(rf));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));

	    break;

	  default:
	  llvmerror(&@1, "invalid BIU1Ld instruction!");clear();YYABORT;
	  break;
       }
       break;
       
       case 6://to maccIF
       
/*       if(ipath->getImm() == 3)
		flagsort = 0x0;
       else if(ipath->getImm() == 7)
		flagsort = 0x1;
       else {
                llvmerror(&@1, "BIU1 to IFMAC/IFALU must use port I3 or I7"); 
                clear();YYABORT;
             }*/
             
             switch(ipath->getImm())
             {
		case 3:
		  flagsort = 0;
		  break;
		case 4:
		  flagsort = 1;
		  break;
		case 5:
		  flagsort = 2;
		  break;
		case 7:
		  flagsort = 3;
		  break;
		default:
		   llvmerror(&@1, "BIU1 to IFMAC/IFALU must use port I3/I4/I5/I7"); 
                   clear();YYABORT;
             }
             
	ff = OPERAND(Imm, flagsort, FlagS, FlagE);
	//flags.reset();
	
          switch ($1) {
	    case 0://lddis
    
	      //qlh flag
	      if(flags[LF])
		  flagsort = 0x0;
	      else if(flags[QHF])
		  flagsort = 0x1;
	      else if(flags[QLF])
		  flagsort = 0x2;
	      qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();
        
	      ADDOPERAND(Opc, UCPM::BIU1disLdToMACCIF, @$.S, @$.E); 
              Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
            break;
        
            case 1://ldstep
    
	      if(flags[RF])
		  flagsort = 0x1;	     
	      else
		  flagsort = 0x0;
	      rf = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();

	      ADDOPERAND(Opc, UCPM::BIU1ComLdToMACCIF, @$.S, @$.E); 
    
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(rf));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));

	    break;

	  default:
	  llvmerror(&@1, "invalid BIU1Ld instruction!");clear();YYABORT;
	  break;
       }
       break;
       
        case 3://to Wx.m[t]
       
	     if(flags[W1F])
		flagsort = 0x0;
	     else if(flags[W3F])
	        flagsort = 0x1;
	     else {
		llvmerror(&@1, "Only W1/W3 can be used for BIU1.");
		clear();YYABORT;}
		ff = OPERAND(Imm, flagsort, FlagS, FlagE);
	      
	  switch ($1) {
	    case 0://lddis
    
	      //qlh flag
	      if(flags[LF])
		  flagsort = 0x0;
	      else if(flags[QHF])
		  flagsort = 0x1;
	      else if(flags[QLF])
		  flagsort = 0x2;
	      qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
	      
	      flags.reset();
        
	      ADDOPERAND(Opc, UCPM::BIU1disLdToM, @$.S, @$.E); 
              Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
            break;
        
            case 1://ldstep
    
	      if(flags[RF])
		  flagsort = 0x1;	     
	      else
		  flagsort = 0x0;
	      rf = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();

	      ADDOPERAND(Opc, UCPM::BIU1ComLdToM, @$.S, @$.E); 
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(rf));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	    break;

	  default:
	  llvmerror(&@1, "invalid BIU1Ld instruction!");clear();YYABORT;
	  break;
       }
       break;
       
         case 4://to Wx.m[s++,i++,a++]
       
	     if(flags[W1F])
		flagsort = 0x0;
	     else if(flags[W3F])
	        flagsort = 0x1;
	     else {
		llvmerror(&@1, "Only W1/W3 can be used for BIU1.");
		clear();YYABORT;}
	     ff = OPERAND(Imm, flagsort, FlagS, FlagE);
	      
	     flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
		sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	  switch ($1) {
	    case 0://lddis
    
	      //qlh flag
	      if(flags[LF])
		  flagsort = 0x0;
	      else if(flags[QHF])
		  flagsort = 0x1;
	      else if(flags[QLF])
		  flagsort = 0x2;
	      qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
	      
	      flags.reset();
        
	      ADDOPERAND(Opc, UCPM::BIU1disLdToMSIA, @$.S, @$.E); 
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
            break;
        
            case 1://ldstep
    
	      if(flags[RF])
		  flagsort = 0x1;	     
	      else
		  flagsort = 0x0;
	      rf = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();

	      ADDOPERAND(Opc, UCPM::BIU1ComLdToMSIA, @$.S, @$.E); 
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(rf));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
	    break;

	  default:
	  llvmerror(&@1, "invalid BIU1Ld instruction!");clear();YYABORT;
	  break;
       }
       break;
       
          case 5://to Wx.m[dis(flag)]
       
	     if(flags[W1F])
		flagsort = 0x0;
	     else if(flags[W3F])
		flagsort = 0x1;
	      else {
		llvmerror(&@1, "Only W1/W3 can be used for BIU1.");
		clear();YYABORT;}
	     ff = OPERAND(Imm, flagsort, FlagS, FlagE);
	      
	     flagsort = flags[SHIFTF];
	        dis = OPERAND(Imm, flagsort, FlagS, FlagE);	     
	
	  switch ($1) {
	    case 0://lddis
    
	      //qlh flag
	      if(flags[LF])
		  flagsort = 0x0;
	      else if(flags[QHF])
		  flagsort = 0x1;
	      else if(flags[QLF])
		  flagsort = 0x2;
	      qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
	      
	      flags.reset();
        
	      ADDOPERAND(Opc, UCPM::BIU1disLdToDIS, @$.S, @$.E); 
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
            break;
        
            case 1://ldstep
    
	      if(flags[RF])
		  flagsort = 0x1;	     
	      else
		  flagsort = 0x0;
	      rf = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();

	      ADDOPERAND(Opc, UCPM::BIU1ComLdToDIS, @$.S, @$.E); 
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(rf));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
	    break;

	  default:
	  llvmerror(&@1, "invalid BIU1Ld instruction!");clear();YYABORT;
	  break;
       }
       break;
	  default:
	  llvmerror(&@3, "invalid BIU1 dest!");clear();YYABORT;
	  break;
       }
       break;
  
}
| stinst{
      if(tm->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU1_Store inst! Tm should be T0-T3!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU1_Store inst! Ts should be T0-T3!");clear();YYABORT;}//niuxu       
	flagsort = (flags[RF] << 3) | (flags[MF] << 2) | (flags[APPF] << 1) | flags[BRF];
	f = OPERAND(Imm, flagsort, FlagS, FlagE);
     
        //qlh flag
        if(flags[LF])
            flagsort = 0x0;
        else if(flags[HF])
            flagsort = 0x1;
        else if(flags[QF])
            flagsort = 0x2;
        else
            flagsort = 0x3;
        qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
        
      ADDOPERAND(Opc, UCPM::BIU1St, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();  
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh));      
  
}
| binInstr{
      if(tm->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU1 inst! Ts0 should be T0-T3!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU1 inst! Ts1 should be T0-T3!");clear();YYABORT;}//niuxu   
      if(tp->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU1 inst! Tm should be T0-T3!");clear();YYABORT;}//niuxu 
	 
      ADDOPERAND(Opc, UCPM::BIU1Bin, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();  
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if (imm2 == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm2));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if (imm1 == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));
     
}
| shiftInstr{
      if(tm->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU1 inst! Ts1 should be T0-T3!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU1 inst! Tm should be T0-T3!");clear();YYABORT;}//niuxu
	 
      ADDOPERAND(Opc, UCPM::BIU1Shift, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size(); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if (imm1 == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));
      if (imm2 == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm2));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
     
}
| compareInstr{
      if(tm->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU1_Compare inst! Ts1 should be T0-T3!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU1_Compare inst! Tm should be T0-T3!");clear();YYABORT;}//niuxu  
	 
      ADDOPERAND(Opc, UCPM::BIU1Com, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size(); 
      //Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if (imm1 == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm2));
     
}
| notInstr{
      if(tm->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU1_Not inst! Ts1 should be T0-T3!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU1_Not inst! Tm should be T0-T3!");clear();YYABORT;}//niuxu 
	 
      ADDOPERAND(Opc, UCPM::BIU1NOT, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size(); 
      //Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if (imm1 == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));
     
}
| movInstr{
      if(tm->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU1_Mov inst! Ts0 should be T0-T3!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU1_Mov inst! Tm should be T0-T3!");clear();YYABORT;}//niuxu           
       
        if(flags[BF])
            flagsort = 0x0;
        else if(flags[SF])
            flagsort = 0x1;
        else 
            flagsort = 0x2;
        f = OPERAND(Imm, flagsort, FlagS, FlagE);
        
        if(flags[MLF])
            flagsort = 0x1;
        else if(flags[MHF])
            flagsort = 0x2;
        else if(flags[HF])
            flagsort = 0x3; 
        else 
	    flagsort = 0x0;//LF
        ff = OPERAND(Imm, flagsort, FlagS, FlagE);
        
        if(flags[dMLF])
            flagsort = 0x1;
        else if(flags[dMHF])
            flagsort = 0x2;
        else if(flags[dHF])
            flagsort = 0x3;  
        else 
	    flagsort = 0x0;//LF
        qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
        
        
        flags.reset();
        
      ADDOPERAND(Opc, UCPM::BIU1Mov, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size(); 

      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if (imm1 == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));
	
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh));
     
}
| maskInstr{
      if(tm->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU1_Mask inst! Ts1 should be T0-T3!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU1_Mask inst! Tm should be T0-T3!");clear();YYABORT;}//niuxu        
       
        if(flags[BF])
	{
	    if(flags[HF])
	      flagsort = 0b100;
	    else 
	      flagsort = 0b000;
	}
        else if(flags[SF])
            flagsort = 0b001;
        else 
            flagsort = 0b010;
        f = OPERAND(Imm, flagsort, FlagS, FlagE);
        
        flags.reset();
        
      ADDOPERAND(Opc, UCPM::BIU1MaskGen, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size(); 

      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if (imm1 == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));

	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	
     
}
| waitInstr{
            
      ADDOPERAND(Opc, UCPM::BIU1Wait, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size(); 
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    
}
| t _flag K flag_ ASSIGNTO biu1dest{
      if(tm->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU1_KG inst! Tm should be T0-T3!");clear();YYABORT;}//niuxu 
	 
	     if(flags[W1F])
		flagsort = 0x0;
	     else if(flags[W3F])
		flagsort = 0x1;
	     else {
		llvmerror(&@1, "Only W1/W3 can be used for BIU1.");
		clear();YYABORT;}
		
	      ff = OPERAND(Imm, flagsort, FlagS, FlagE);
	
		      
	     flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
		sia = OPERAND(Imm, flagsort, FlagS, FlagE);
		
	     flagsort = flags[SHIFTF];
	        dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	        
	     flags.reset();
	      
    switch ($6) {
    
        case 3://to Wx.m[t]   	   	      	      
	      ADDOPERAND(Opc, UCPM::BIU1KGToM, @$.S, @$.E); 
              Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
              Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
        break;
       
        case 4://to Wx.m[s++,i++,a++]
	      ADDOPERAND(Opc, UCPM::BIU1KGToMSIA, @$.S, @$.E); 
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
         break;
         
        case 5://to Wx.m[dis(shift)]
	      ADDOPERAND(Opc, UCPM::BIU1KGToMDIS, @$.S, @$.E); 
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
         break;
       
      default:
         llvmerror(&@3,"invalid BIU1 dest");clear();YYABORT;
	//break;
    }
}
| setCGInstr{
            
          flagsort = (flags[ONF]);
          f = OPERAND(Imm, flagsort, FlagS, FlagE);	
	  flags.reset();
	   
	    ADDOPERAND(Opc, UCPM::BIU1SetCG, @$.S, @$.E);
	    Operands.push_back(nullptr);
	    condpos = Operands.size();
	    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));  
    
}; 

biu2inst: ldselect ASSIGNTO biu2dest {
      if (unit != NULL)
      {
	switch(unit->getReg())
	{
	    case UCPMReg::bBIU0: 
	    case UCPMReg::bBIU1: 
	    case UCPMReg::bBIU2: 
	      if(ut->getReg() > UCPMReg::T3)
		{llvmerror(&@3, "Incorrect BIU2_Load inst! BIUx.Tt should be T0-T3!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::biuIALU:
	      if(ut->getReg() > UCPMReg::T5)
		{llvmerror(&@3, "Incorrect BIU2_Load inst! IALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu
	    break;
	    case UCPMReg::biuIMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect BIU2_Load inst! IMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::biuIFALU:
	      if(ut->getReg() > UCPMReg::T5)
		{llvmerror(&@3, "Incorrect BIU2_Load inst! IFALU.Tt should be T0-T5!");clear();YYABORT;}//niuxu	    
	    break;
	    case UCPMReg::biuIFMAC:
	      if(ut->getReg() == UCPMReg::T6)
		{llvmerror(&@3, "Incorrect BIU2_Load inst! IFMAC.Tt should be T0-T5,T7!");clear();YYABORT;}//niuxu	    
	    break;
	}
      }    
 
    flagsort = (flags[RF] << 3) | (flags[MF] << 2) | (flags[APPF] << 1) | flags[BRF];
    f = OPERAND(Imm, flagsort, FlagS, FlagE);
    
    switch ($3) {
    
        case 0://to biu2
	  switch ($1) {
	    case 0://lddis
    
	      //qlh flag
	      if(flags[LF])
		  flagsort = 0x0;
	      else if(flags[QHF])
		  flagsort = 0x1;
	      else if(flags[QLF])
		  flagsort = 0x2;
	      qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();
        
	      ADDOPERAND(Opc, UCPM::BIU2disLdToBIU, @$.S, @$.E); 
              Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
	      Operands.push_back(nullptr);
	      condpos = Operands.size(); 
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh));
            break;
        
            case 1://ldstep
    
	      if(flags[RF])
		  flagsort = 0x1;	     
	      else
		  flagsort = 0x0;
	      rf = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();

	      ADDOPERAND(Opc, UCPM::BIU2ComLdToBIU, @$.S, @$.E); 
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
	      Operands.push_back(nullptr);
	      condpos = Operands.size(); 
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(rf));
	    break;

	  default:
	  llvmerror(&@1, "invalid BIU2Ld instruction!");clear();YYABORT;
	  break;
       }
       break;
       
	case 1://to shu
          switch ($1) {
	    case 0://lddis
    
	      //qlh flag
	      if(flags[LF])
		  flagsort = 0x0;
	      else if(flags[QHF])
		  flagsort = 0x1;
	      else if(flags[QLF])
		  flagsort = 0x2;
	      qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();
        
	      ADDOPERAND(Opc, UCPM::BIU2disLdToSHU, @$.S, @$.E); 
              Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
	      Operands.push_back(nullptr);
	      condpos = Operands.size(); 
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh));
            break;
        
            case 1://ldstep
    
	      if(flags[RF])
		  flagsort = 0x1;	     
	      else
		  flagsort = 0x0;
	      rf = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();

	      ADDOPERAND(Opc, UCPM::BIU2ComLdToSHU, @$.S, @$.E); 
    
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
	      Operands.push_back(nullptr);
	      condpos = Operands.size(); 
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(rf));

	    break;

	  default:
	  llvmerror(&@1, "invalid BIU2Ld instruction!");clear();YYABORT;
	  break;
       }
       break;
        
        case 2://to maccI
        
/*        if(ipath->getImm() == 2)
		flagsort = 0x0;
	else {
                llvmerror(&@1, "BIU2 to IMAC/IALU must use port I2"); 
                clear();YYABORT;
             }*/
             
             switch(ipath->getImm())
             {
		case 0:
		  flagsort = 0;
		  break;
		case 1:
		  flagsort = 1;
		  break;
		case 2:
		  flagsort = 2;
		  break;
		default:
		   llvmerror(&@1, "BIU2 to IMAC/IALU must use port I0/I1/I2"); 
                   clear();YYABORT;
             }
             
	ff = OPERAND(Imm, flagsort, FlagS, FlagE);
	//flags.reset();
	
          switch ($1) {
	    case 0://lddis
    
	      //qlh flag
	      if(flags[LF])
		  flagsort = 0x0;
	      else if(flags[QHF])
		  flagsort = 0x1;
	      else if(flags[QLF])
		  flagsort = 0x2;
	      qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();
        
	      ADDOPERAND(Opc, UCPM::BIU2disLdToMACCI, @$.S, @$.E); 
              Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
	      Operands.push_back(nullptr);
	      condpos = Operands.size(); 
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
            break;
        
            case 1://ldstep
    
	      if(flags[RF])
		  flagsort = 0x1;	     
	      else
		  flagsort = 0x0;
	      rf = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();

	      ADDOPERAND(Opc, UCPM::BIU2ComLdToMACCI, @$.S, @$.E); 
    
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
	      Operands.push_back(nullptr);
	      condpos = Operands.size(); 
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(rf));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));

	    break;

	  default:
	  llvmerror(&@1, "invalid BIU2Ld instruction!");clear();YYABORT;
	  break;
       }
       break;
       
       case 6://to maccIF
       
/*       if(ipath->getImm() == 5)
		flagsort = 0x0;
       else {
                llvmerror(&@1, "BIU2 to IFMAC/IFALU must use port I5"); 
                clear();YYABORT;
             }*/
             
             
             switch(ipath->getImm())
             {
		case 3:
		  flagsort = 0;
		  break;
		case 4:
		  flagsort = 1;
		  break;
		case 5:
		  flagsort = 2;
		  break;
		default:
		   llvmerror(&@1, "BIU2 to IFMAC/IFALU must use port I3/I4/I5"); 
                   clear();YYABORT;
             }
             
	ff = OPERAND(Imm, flagsort, FlagS, FlagE);
	//flags.reset();
	
          switch ($1) {
	    case 0://lddis
    
	      //qlh flag
	      if(flags[LF])
		  flagsort = 0x0;
	      else if(flags[QHF])
		  flagsort = 0x1;
	      else if(flags[QLF])
		  flagsort = 0x2;
	      qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();
        
	      ADDOPERAND(Opc, UCPM::BIU2disLdToMACCIF, @$.S, @$.E); 
              Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
	      Operands.push_back(nullptr);
	      condpos = Operands.size(); 
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
            break;
        
            case 1://ldstep
    
	      if(flags[RF])
		  flagsort = 0x1;	     
	      else
		  flagsort = 0x0;
	      rf = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();

	      ADDOPERAND(Opc, UCPM::BIU2ComLdToMACCIF, @$.S, @$.E); 
    
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(unit));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ut));//unit'T
	      Operands.push_back(nullptr);
	      condpos = Operands.size(); 
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(rf));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));

	    break;

	  default:
	  llvmerror(&@1, "invalid BIU2Ld instruction!");clear();YYABORT;
	  break;
       }
       break;
       
       case 3://to Wx.m[t]
       
	     if(flags[W4F])
		flagsort = 0x0;
	      else {
		llvmerror(&@1, "Only W4 can be used for BIU2.");
		clear();YYABORT;}
	     ff = OPERAND(Imm, flagsort, FlagS, FlagE);
	      
	  switch ($1) {
	    case 0://lddis
    
	      //qlh flag
	      if(flags[LF])
		  flagsort = 0x0;
	      else if(flags[QHF])
		  flagsort = 0x1;
	      else if(flags[QLF])
		  flagsort = 0x2;
	      qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
	      
	      flags.reset();
        
	      ADDOPERAND(Opc, UCPM::BIU2disLdToM, @$.S, @$.E); 
              Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
	      Operands.push_back(nullptr);
	      condpos = Operands.size(); 
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
            break;
        
            case 1://ldstep
    
	      if(flags[RF])
		  flagsort = 0x1;	     
	      else
		  flagsort = 0x0;
	      rf = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();

	      ADDOPERAND(Opc, UCPM::BIU2ComLdToM, @$.S, @$.E); 
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
	      Operands.push_back(nullptr);
	      condpos = Operands.size(); 
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(rf));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	    break;

	  default:
	  llvmerror(&@1, "invalid BIU2Ld instruction!");clear();YYABORT;
	  break;
       }
       break;
       
        case 4://to Wx.m[s++,i++,a++]
       
	     if(flags[W4F])
		flagsort = 0x0;
	      else {
		llvmerror(&@1, "Only W4 can be used for BIU2.");
		clear();YYABORT;}
	     ff = OPERAND(Imm, flagsort, FlagS, FlagE);
	      
	     flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
		sia = OPERAND(Imm, flagsort, FlagS, FlagE);
	
	  switch ($1) {
	    case 0://lddis
    
	      //qlh flag
	      if(flags[LF])
		  flagsort = 0x0;
	      else if(flags[QHF])
		  flagsort = 0x1;
	      else if(flags[QLF])
		  flagsort = 0x2;
	      qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
	      
	      flags.reset();
        
	      ADDOPERAND(Opc, UCPM::BIU2disLdToMSIA, @$.S, @$.E); 
	      Operands.push_back(nullptr);
	      condpos = Operands.size(); 
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
            break;
        
            case 1://ldstep
    
	      if(flags[RF])
		  flagsort = 0x1;	     
	      else
		  flagsort = 0x0;
	      rf = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();

	      ADDOPERAND(Opc, UCPM::BIU2ComLdToMSIA, @$.S, @$.E); 
	      Operands.push_back(nullptr);
	      condpos = Operands.size(); 
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(rf));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
	    break;

	  default:
	  llvmerror(&@1, "invalid BIU2Ld instruction!");clear();YYABORT;
	  break;
       }
       break;
       
    case 5://to Wx.m[dis(flag)]
       
	     if(flags[W4F])
		flagsort = 0x0;
	      else {
		llvmerror(&@1, "Only W4 can be used for BIU2.");
		clear();YYABORT;}
		
	      ff = OPERAND(Imm, flagsort, FlagS, FlagE);
	      
	     flagsort = flags[SHIFTF];
	        dis = OPERAND(Imm, flagsort, FlagS, FlagE);	     
	
	  switch ($1) {
	    case 0://lddis
    
	      //qlh flag
	      if(flags[LF])
		  flagsort = 0x0;
	      else if(flags[QHF])
		  flagsort = 0x1;
	      else if(flags[QLF])
		  flagsort = 0x2;
	      qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
	      
	      flags.reset();
        
	      ADDOPERAND(Opc, UCPM::BIU2disLdToDIS, @$.S, @$.E); 
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
            break;
        
            case 1://ldstep
    
	      if(flags[RF])
		  flagsort = 0x1;	     
	      else
		  flagsort = 0x0;
	      rf = OPERAND(Imm, flagsort, FlagS, FlagE);
	      flags.reset();

	      ADDOPERAND(Opc, UCPM::BIU2ComLdToDIS, @$.S, @$.E); 
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(rf));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
	    break;

	  default:
	  llvmerror(&@1, "invalid BIU2Ld instruction!");clear();YYABORT;
	  break;
       }
       break;
    default:
    llvmerror(&@3, "invalid BIU2 dest!");clear();YYABORT;
	  break;
    }
   
  
}
| stinst{
      if(tm->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU2_Store inst! Tm should be T0-T3!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU2_Store inst! Ts should be T0-T3!");clear();YYABORT;}//niuxu 
	 
	flagsort =(flags[RF] << 3) | (flags[MF] << 2) | (flags[APPF] << 1) | flags[BRF];
	f = OPERAND(Imm, flagsort, FlagS, FlagE);
     
        //qlh flag
        if(flags[LF])
            flagsort = 0x0;
        else if(flags[HF])
            flagsort = 0x1;
        else if(flags[QF])
            flagsort = 0x2;
        else
            flagsort = 0x3;
        qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
        
      ADDOPERAND(Opc, UCPM::BIU2St, @$.S, @$.E); 
      Operands.push_back(nullptr);
      condpos = Operands.size();   
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh));      
  
}
| binInstr{
      if(tm->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU2 inst! Ts0 should be T0-T3!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU2 inst! Ts1 should be T0-T3!");clear();YYABORT;}//niuxu   
      if(tp->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU2 inst! Tm should be T0-T3!");clear();YYABORT;}//niuxu 	 
	 
      ADDOPERAND(Opc, UCPM::BIU2Bin, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();  
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tp));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if (imm2 == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm2));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if (imm1 == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));
     
}
| shiftInstr{
      if(tm->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU2 inst! Ts1 should be T0-T3!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU2 inst! Tm should be T0-T3!");clear();YYABORT;}//niuxu   
	 
      ADDOPERAND(Opc, UCPM::BIU2Shift, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size(); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if (imm1 == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));
      if (imm2 == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm2));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
     
}
| compareInstr{
      if(tm->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU2_Compare inst! Ts1 should be T0-T3!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU2_Compare inst! Tm should be T0-T3!");clear();YYABORT;}//niuxu  
	 
      ADDOPERAND(Opc, UCPM::BIU2Com, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size(); 
      //Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if (imm1 == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm2));
     
}
| notInstr{
      if(tm->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU2_Not inst! Ts1 should be T0-T3!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU2_Not inst! Tm should be T0-T3!");clear();YYABORT;}//niuxu 
	 
      ADDOPERAND(Opc, UCPM::BIU2NOT, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size(); 
      //Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if (imm1 == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));
     
}
| movInstr{
      if(tm->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU2_Mov inst! Ts0 should be T0-T3!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU2_Mov inst! Tm should be T0-T3!");clear();YYABORT;}//niuxu           
       
        if(flags[BF])
            flagsort = 0x0;
        else if(flags[SF])
            flagsort = 0x1;
        else 
            flagsort = 0x2;
        f = OPERAND(Imm, flagsort, FlagS, FlagE);
        
	if(flags[MLF])
            flagsort = 0x1;
        else if(flags[MHF])
            flagsort = 0x2;
        else if(flags[HF])
            flagsort = 0x3; 
        else 
	    flagsort = 0x0;//LF
        ff = OPERAND(Imm, flagsort, FlagS, FlagE);
        
        if(flags[dMLF])
            flagsort = 0x1;
        else if(flags[dMHF])
            flagsort = 0x2;
        else if(flags[dHF])
            flagsort = 0x3;  
        else 
	    flagsort = 0x0;//LF
        qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
        
        flags.reset();
        
      ADDOPERAND(Opc, UCPM::BIU2Mov, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size(); 

      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      if (imm1 == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));
	
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh));
     
}
| maskInstr{
      if(tm->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU2_Mask inst! Ts1 should be T0-T3!");clear();YYABORT;}//niuxu
      if(tn->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU2_Mask inst! Tm should be T0-T3!");clear();YYABORT;}//niuxu        
       
        if(flags[BF])
	{
	    if(flags[HF])
	      flagsort = 0b100;
	    else 
	      flagsort = 0b000;
	}
        else if(flags[SF])
            flagsort = 0b001;
        else 
            flagsort = 0b010;
        f = OPERAND(Imm, flagsort, FlagS, FlagE);
        
        flags.reset();
        
      ADDOPERAND(Opc, UCPM::BIU2MaskGen, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size(); 

      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tn));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
      if (imm1 == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));

	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	
     
}
| waitInstr{
            
      ADDOPERAND(Opc, UCPM::BIU2Wait, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size();       
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
    
}
| t _flag K flag_ ASSIGNTO biu2dest{
      if(tm->getReg() > UCPMReg::T3)
	 {llvmerror(&@1, "Incorrect BIU2_KG inst! Tm should be T0-T3!");clear();YYABORT;}//niuxu 
	 
	      if(flags[W4F])
		flagsort = 0x0;
	      else {
		llvmerror(&@1, "Only W4 can be used for BIU2.");
		clear();YYABORT;}
		
	      ff = OPERAND(Imm, flagsort, FlagS, FlagE);
	
		      
	     flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
		sia = OPERAND(Imm, flagsort, FlagS, FlagE);
		
	     flagsort = flags[SHIFTF];
	        dis = OPERAND(Imm, flagsort, FlagS, FlagE);
	        
	     flags.reset();
	      
    switch ($6) {
    
        case 3://to Wx.m[t]   	   	      	      
	      ADDOPERAND(Opc, UCPM::BIU2KGToM, @$.S, @$.E); 
              Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
              Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
        break;
       
        case 4://to Wx.m[s++,i++,a++]
	      ADDOPERAND(Opc, UCPM::BIU2KGToMSIA, @$.S, @$.E); 
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
         break;
         
        case 5://to Wx.m[dis(shift)]
	      ADDOPERAND(Opc, UCPM::BIU2KGToMDIS, @$.S, @$.E); 
	      Operands.push_back(nullptr);
	      condpos = Operands.size();
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
         break;
       
      default:
         llvmerror(&@3,"invalid BIU2 dest");clear();YYABORT;
	//break;
    }
}
| setCGInstr{
            
          flagsort = (flags[ONF]);
          f = OPERAND(Imm, flagsort, FlagS, FlagE);	
	  flags.reset();
	   
	    ADDOPERAND(Opc, UCPM::BIU2SetCG, @$.S, @$.E);
	    Operands.push_back(nullptr);
	    condpos = Operands.size();
	    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));  
    
}; 

//imacaccaddclause: MR ACC1 t MUL V _flag t LBRACKET imm5 RBRACKET flag_  ADD  t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imacrealflag flag_ _flag imacflags flag_ {imm = OPERAND(Imm, $9, @9.S, @9.E);imm1 = OPERAND(Imm, $19, @19.S, @19.E);} |
//                  MR ACC1 t MUL V _flag t LBRACKET imm5 RBRACKET flag_  ADD  t MUL V _flag t LBRACKET imm5 RBRACKET flag_ _flag imacrealflag flag_ {imm = OPERAND(Imm, $9, @9.S, @9.E);imm1 = OPERAND(Imm, $19, @19.S, @19.E);};

ldselect: lddis{
            $$ = 0; 
            if(tm->getReg() > UCPMReg::T3)
	      {llvmerror(&@1, "Incorrect BIUx_Load inst! Tm should be T0-T3!");clear();YYABORT;}//niuxu
	    if(tn->getReg() > UCPMReg::T3)
	      {llvmerror(&@1, "Incorrect BIUx_Load inst! Ts should be T0-T3!");clear();YYABORT;}//niuxu  
        } |
        ldstep{
            $$ = 1;
            if(tm->getReg() > UCPMReg::T3)
	      {llvmerror(&@1, "Incorrect BIUx_Load inst! Tm should be T0-T3!");clear();YYABORT;}//niuxu
        };
lddis:      t _flag t flag_ _flag biuloadflags flag_ _flag lddisflag flag_ |
            t _flag t flag_ _flag lddisflag flag_ ;
            
lddis:      t _flag t flag_ _flag error flag_ _flag lddisflag flag_ {llvmerror(&@6, "BIU_Load flags error! Available flags are A++,M,BR"); clear();YYABORT;}|//niuxx
	    t _flag t flag_ _flag biuloadflags flag_ error {llvmerror(&@8, "BIUdisLd must be followed by QL/QH/L !"); clear();YYABORT;} |
            t _flag t flag_ error {llvmerror(&@5, "BIUdisLd must be followed by QL/QH/L !"); clear();YYABORT;};
            
ldstep:     t _flag biuloadflags flag_ |

	    t _flag error flag_ {llvmerror(&@3, "BIULoad_R flags error! Available flags are A++,M,BR"); clear();YYABORT;}|//niuxx
	    t _flag biuloadflags flag_ _flag biurflag flag_ | 
	    t;     

//biu0dest: shu0te | shu1te | ialute | imacte | ifalute | ifmacte | bbiu0te | w_mindexn | w_mindexsia;
//biu1dest: shu0te | b1shu2te | ialute | imacte | ifalute | ifmacte | bbiu1te | w_mindexn | w_mindexsia;
//biu2dest: b2shu1te | b1shu2te | ialute | imacte | ifalute | ifmacte | bbiu2te | w_mindexn | w_mindexsia;

biu0dest: biushute | ialute | imacte | ifalute | ifmacte | bbiu0te | w_mindexn | w_mindexsia | w_mindexdis;
biu1dest: biushute | ialute | imacte | ifalute | ifmacte | bbiu1te | w_mindexn | w_mindexsia | w_mindexdis;
biu2dest: biushute | ialute | imacte | ifalute | ifmacte | bbiu2te | w_mindexn | w_mindexsia | w_mindexdis;



w_mindexn: wflag DOT MINDEXN {
  $$ = 3; ms = md;
  md = OPERAND(Reg, MRI->getRegClass(UCPMReg::MRegRegClassID).getRegister($3), @$.S, @$.E);
};

w_mindexsia: wflag DOT M LBRACKET siaflags RBRACKET {$$=4;} | wflag DOT M {$$=4;} |
	     wflag DOT M LBRACKET error RBRACKET {llvmerror(&@5, "BIU dest flags error! Available flags are t/(S++,I++,A++)/dis(shift)"); clear();YYABORT;};//niuxx

w_mindexdis: wflag DOT M LBRACKET DIS _flag disflag flag_ RBRACKET {$$=5;} | wflag DOT M LBRACKET DIS RBRACKET{$$=5;}|
	     wflag DOT M LBRACKET DIS _flag error flag_ RBRACKET {llvmerror(&@7, "BIU dest flags error! Available flags are t/(S++,I++,A++)/dis(shift)"); clear();YYABORT;};//niuxx

stinst:  t _flag t flag_ ASSIGNTO DM _flag biuflags flag_ _flag storeflag flag_ |

	 t _flag t flag_ ASSIGNTO DM _flag error flag_ _flag storeflag flag_ {llvmerror(&@8, "BIU_Store flags error! Available flags are A++,M,BR"); clear();YYABORT;}|//niuxx
         t _flag t flag_ ASSIGNTO DM _flag biuflags flag_ |
         
         t _flag t flag_ ASSIGNTO DM _flag error flag_ {llvmerror(&@8, "BIU_Store flags error! Available flags are A++,M,BR"); clear();YYABORT;}|//niuxx
         t _flag t flag_ ASSIGNTO DM _flag storeflag flag_ |
         t _flag t flag_ ASSIGNTO DM;

       

binInstr:     addclause {opc = OPERAND(Reg, UCPMReg::BIUADD, @$.S, @$.E);} | 
              subclause {opc = OPERAND(Reg, UCPMReg::BIUSUB, @$.S, @$.E);} | 
              addrclause {opc = OPERAND(Reg, UCPMReg::BIUADDR, @$.S, @$.E);} | 
              subrclause {opc = OPERAND(Reg, UCPMReg::BIUSUBR, @$.S, @$.E);} | 
              andclause {opc = OPERAND(Reg, UCPMReg::BIUAND, @$.S, @$.E);} |
              orclause {opc = OPERAND(Reg, UCPMReg::BIUOR, @$.S, @$.E);} |
              xorclause {opc = OPERAND(Reg, UCPMReg::BIUXOR, @$.S, @$.E);} |
              lshtclause {opc = OPERAND(Reg, UCPMReg::BIULSHT, @$.S, @$.E);} |
              rshtclause {opc = OPERAND(Reg, UCPMReg::BIURSHT, @$.S, @$.E);} ;
              
addclause: t LBRACKET IMM5 RBRACKET ADD t LBRACKET IMM5 RBRACKET ASSIGNTO t LBRACKET IMM5 RBRACKET
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $8, @8.S, @8.E);imm2 = OPERAND(Imm, $13, @13.S, @13.E);};
subclause: t LBRACKET IMM5 RBRACKET SUB t LBRACKET IMM5 RBRACKET ASSIGNTO t LBRACKET IMM5 RBRACKET
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $8, @8.S, @8.E);imm2 = OPERAND(Imm, $13, @13.S, @13.E);};
addrclause: t LBRACKET IMM5 RBRACKET ADD t LBRACKET IMM5 RBRACKET LPAREN R RPAREN ASSIGNTO t LBRACKET IMM5 RBRACKET
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $8, @8.S, @8.E);imm2 = OPERAND(Imm, $16, @16.S, @16.E);};
subrclause: t LBRACKET IMM5 RBRACKET SUB t LBRACKET IMM5 RBRACKET LPAREN R RPAREN ASSIGNTO t LBRACKET IMM5 RBRACKET
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $8, @8.S, @8.E);imm2 = OPERAND(Imm, $16, @16.S, @16.E);};
andclause: t LBRACKET IMM5 RBRACKET AND t LBRACKET IMM5 RBRACKET ASSIGNTO t LBRACKET IMM5 RBRACKET
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $8, @8.S, @8.E);imm2 = OPERAND(Imm, $13, @13.S, @13.E);};
orclause : t LBRACKET IMM5 RBRACKET OR t LBRACKET IMM5 RBRACKET ASSIGNTO t LBRACKET IMM5 RBRACKET
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $8, @8.S, @8.E);imm2 = OPERAND(Imm, $13, @13.S, @13.E);}; 
xorclause : t LBRACKET IMM5 RBRACKET XOR t LBRACKET IMM5 RBRACKET ASSIGNTO t LBRACKET IMM5 RBRACKET
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $8, @8.S, @8.E);imm2 = OPERAND(Imm, $13, @13.S, @13.E);}; 
lshtclause : t LBRACKET IMM5 RBRACKET LSHT t LBRACKET IMM5 RBRACKET ASSIGNTO t LBRACKET IMM5 RBRACKET
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $8, @8.S, @8.E);imm2 = OPERAND(Imm, $13, @13.S, @13.E);}; 
rshtclause : t LBRACKET IMM5 RBRACKET RSHT t LBRACKET IMM5 RBRACKET ASSIGNTO t LBRACKET IMM5 RBRACKET
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $8, @8.S, @8.E);imm2 = OPERAND(Imm, $13, @13.S, @13.E);}; 

	  

shiftInstr :   lshitclause {opc = OPERAND(Reg, UCPMReg::BIULSHTI, @$.S, @$.E);} |
               rshitclause {opc = OPERAND(Reg, UCPMReg::BIURSHTI, @$.S, @$.E);} ;
lshitclause: t LBRACKET IMM5 RBRACKET LSHT IMM5 ASSIGNTO t LBRACKET IMM5 RBRACKET
	     {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $6, @6.S, @6.E);imm2 = OPERAND(Imm, $10, @10.S, @10.E);};
rshitclause: t LBRACKET IMM5 RBRACKET RSHT IMM5 ASSIGNTO t LBRACKET IMM5 RBRACKET
	     {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $6, @6.S, @6.E);imm2 = OPERAND(Imm, $10, @10.S, @10.E);};

compareInstr : t LBRACKET IMM5 RBRACKET EQU IMM5 ASSIGNTO t LBRACKET IMM5 RBRACKET
	     {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $10, @10.S, @10.E);imm2 = OPERAND(Imm, $6, @6.S, @6.E);};

notInstr:  NOT2 t LBRACKET IMM5 RBRACKET ASSIGNTO t LBRACKET IMM5 RBRACKET
	     {imm = OPERAND(Imm, $4, @4.S, @4.E);imm1 = OPERAND(Imm, $9, @9.S, @9.E);};

	     
movInstr: movclause {opc = OPERAND(Reg, UCPMReg::BIUMOV, @$.S, @$.E);} |
          invertclause {opc = OPERAND(Reg, UCPMReg::BIUINV, @$.S, @$.E);} ;
movclause: t LBRACKET IMM5 RBRACKET _flag biuImmflag flag_ ASSIGNTO t LBRACKET IMM5 RBRACKET _flag biuImm2_flag flag_ _flag biuImm1flag flag_
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $11, @11.S, @11.E);}| 
	  t LBRACKET IMM5 RBRACKET ASSIGNTO t LBRACKET IMM5 RBRACKET 
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $8, @8.S, @8.E);}|
	  
	  t LBRACKET IMM5 RBRACKET _flag error flag_ ASSIGNTO t LBRACKET IMM5 RBRACKET _flag biuImm2_flag flag_ _flag biuImm1flag flag_
	  {llvmerror(&@6, "BIUMov flags error! Available flags are L/ML/MH/H"); clear();YYABORT;}|//niuxx
	  t LBRACKET IMM5 RBRACKET _flag biuImmflag flag_ ASSIGNTO t LBRACKET IMM5 RBRACKET _flag error flag_ _flag biuImm1flag flag_
	  {llvmerror(&@14, "BIUMov flags error! Available flags are B/S"); clear();YYABORT;}|//niuxx
	  t LBRACKET IMM5 RBRACKET _flag biuImmflag flag_ ASSIGNTO t LBRACKET IMM5 RBRACKET _flag biuImm2_flag flag_ _flag error flag_
	  {llvmerror(&@17, "BIUMov flags error! Available flags are L/ML/MH/H"); clear();YYABORT;};//niuxx
invertclause: t LBRACKET IMM5 RBRACKET LPAREN INVERT RPAREN _flag biuImmflag flag_ ASSIGNTO t LBRACKET IMM5 RBRACKET _flag biuImm2flag flag_ _flag biuImm1flag flag_
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $14, @14.S, @14.E);}
	  | t LBRACKET IMM5 RBRACKET LPAREN INVERT RPAREN ASSIGNTO t LBRACKET IMM5 RBRACKET 
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $11, @11.S, @11.E);};

	  
maskInstr: t LBRACKET IMM5 RBRACKET _flag biumaskflags flag_ ASSIGNTO t LBRACKET IMM5 RBRACKET DOT MASK
           {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $11, @11.S, @11.E);}| 
           t LBRACKET IMM5 RBRACKET ASSIGNTO t LBRACKET IMM5 RBRACKET DOT MASK
           {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $8, @8.S, @8.E);}|
           
	   t LBRACKET IMM5 RBRACKET _flag error flag_ ASSIGNTO t LBRACKET IMM5 RBRACKET DOT MASK
	   {llvmerror(&@6, "BIUMaskGen flags error! Available flags are B/(B,H)/S"); clear();YYABORT;};//niuxx
           
waitInstr: WAIT IMM5 {imm = OPERAND(Imm, $2, @2.S, @2.E);};

setcond0Instr: biu0cond{  //****** 
	    isSetCond = true;
	    ADDOPERAND(Opc, UCPM::BIU0SetCond, @$.S, @$.E);
	    Operands.push_back(nullptr);
            condpos = Operands.size(); 
	    if (imm == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
	    if (imm1 == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));   
	  };
setcond1Instr: biu1cond{   
	    isSetCond = true;
	    ADDOPERAND(Opc, UCPM::BIU1SetCond, @$.S, @$.E);
	    Operands.push_back(nullptr);
            condpos = Operands.size(); 
	    if (imm == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
	    if (imm1 == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));   
	  };
setcond2Instr: biu2cond{   
	    isSetCond = true;
	    ADDOPERAND(Opc, UCPM::BIU2SetCond, @$.S, @$.E);
	    Operands.push_back(nullptr);
            condpos = Operands.size(); 
	    if (imm == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
	    if (imm1 == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));   
	  };

biu0cond: IMMSYM DOT IMM5 ASSIGNTO BIU0 DOT SETCOND LBRACKET IMM5 RBRACKET 
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $9, @9.S, @9.E);};      
biu1cond: IMMSYM DOT IMM5 ASSIGNTO BIU1 DOT SETCOND LBRACKET IMM5 RBRACKET 
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $9, @9.S, @9.E);};
biu2cond: IMMSYM DOT IMM5 ASSIGNTO BIU2 DOT SETCOND LBRACKET IMM5 RBRACKET 
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $9, @9.S, @9.E);};
    	  

imm0Instr: biu0imm{
            
        if(flags[BF])
            flagsort = 0x0;
        else if(flags[SF])
            flagsort = 0x1;
        else if(flags[UF])
            flagsort = 0x2;
        else 
            flagsort = 0x3;  
        f = OPERAND(Imm, flagsort, FlagS, FlagE);
        
        if(flags[MLF])
            flagsort = 0x1;
        else if(flags[MHF])
            flagsort = 0x2;
        else if(flags[HF])
            flagsort = 0x3;  
        else
            flagsort = 0x0;//LF
        ff = OPERAND(Imm, flagsort, FlagS, FlagE);
        
        flags.reset();
        
      ADDOPERAND(Opc, UCPM::BIU0Imm, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size(); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));

      if (imm1 == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));  
	
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
};
imm1Instr: biu1imm{
            
        if(flags[BF])
            flagsort = 0x0;
        else if(flags[SF])
            flagsort = 0x1;
        else if(flags[UF])
            flagsort = 0x2;
        else 
            flagsort = 0x3;  
        f = OPERAND(Imm, flagsort, FlagS, FlagE);
        
        if(flags[MLF])
            flagsort = 0x1;
        else if(flags[MHF])
            flagsort = 0x2;
        else if(flags[HF])
            flagsort = 0x3;  
        else
            flagsort = 0x0;//LF
        ff = OPERAND(Imm, flagsort, FlagS, FlagE);
        
        flags.reset();
        
      ADDOPERAND(Opc, UCPM::BIU1Imm, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size(); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));

      if (imm1 == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));  
	
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
};
imm2Instr: biu2imm{
            
        if(flags[BF])
            flagsort = 0x0;
        else if(flags[SF])
            flagsort = 0x1;
        else if(flags[UF])
            flagsort = 0x2;
        else 
            flagsort = 0x3;  
        f = OPERAND(Imm, flagsort, FlagS, FlagE);
        
        if(flags[MLF])
            flagsort = 0x1;
        else if(flags[MHF])
            flagsort = 0x2;
        else if(flags[HF])
            flagsort = 0x3;  
        else
            flagsort = 0x0;//LF
        ff = OPERAND(Imm, flagsort, FlagS, FlagE);
        
        flags.reset();
        
      ADDOPERAND(Opc, UCPM::BIU2Imm, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size(); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(tm));

      if (imm1 == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));
      if (imm == NULL)
        ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
      else
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));  
	
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
};

biu0imm: IMMSYM DOT IMM5 ASSIGNTO BIU0 DOT t LBRACKET IMM5 RBRACKET _flag biuImm2flag flag_ _flag biuImmflag flag_
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $9, @9.S, @9.E);}|
	 IMMSYM DOT IMM5 ASSIGNTO BIU0 DOT t LBRACKET IMM5 RBRACKET _flag biuImm2flag flag_ 
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $9, @9.S, @9.E);}| 
	 IMMSYM DOT IMM5 ASSIGNTO BIU0 DOT t LBRACKET IMM5 RBRACKET 
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $9, @9.S, @9.E);}|
	  
	 IMMSYM DOT IMM5 ASSIGNTO BIU0 DOT t LBRACKET IMM5 RBRACKET _flag error flag_
	 {llvmerror(&@12, "BIU0Imm dest flags error! Available flags are U/B/S"); clear();YYABORT;}|//niuxx
	 IMMSYM DOT IMM5 ASSIGNTO BIU0 DOT t LBRACKET IMM5 RBRACKET _flag biuImm2flag flag_ _flag error flag_
	 {llvmerror(&@12, "BIU0Imm dest flags error! Available flags are L/ML/MH/H"); clear();YYABORT;};//niuxx
biu1imm: IMMSYM DOT IMM5 ASSIGNTO BIU1 DOT t LBRACKET IMM5 RBRACKET _flag biuImm2flag flag_ _flag biuImmflag flag_
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $9, @9.S, @9.E);}| 
	 IMMSYM DOT IMM5 ASSIGNTO BIU1 DOT t LBRACKET IMM5 RBRACKET _flag biuImm2flag flag_ 
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $9, @9.S, @9.E);}| 
	 IMMSYM DOT IMM5 ASSIGNTO BIU1 DOT t LBRACKET IMM5 RBRACKET 
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $9, @9.S, @9.E);}|
	  
	 IMMSYM DOT IMM5 ASSIGNTO BIU1 DOT t LBRACKET IMM5 RBRACKET _flag error flag_
	 {llvmerror(&@12, "BIU1Imm dest flags error! Available flags are U/B/S"); clear();YYABORT;}|//niuxx
	 IMMSYM DOT IMM5 ASSIGNTO BIU1 DOT t LBRACKET IMM5 RBRACKET _flag biuImm2flag flag_ _flag error flag_
	 {llvmerror(&@12, "BIU1Imm dest flags error! Available flags are L/ML/MH/H"); clear();YYABORT;};//niuxx
biu2imm: IMMSYM DOT IMM5 ASSIGNTO BIU2 DOT t LBRACKET IMM5 RBRACKET _flag biuImm2flag flag_ _flag biuImmflag flag_
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $9, @9.S, @9.E);}| 
	 IMMSYM DOT IMM5 ASSIGNTO BIU2 DOT t LBRACKET IMM5 RBRACKET _flag biuImm2flag flag_ 
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $9, @9.S, @9.E);}| 
	 IMMSYM DOT IMM5 ASSIGNTO BIU2 DOT t LBRACKET IMM5 RBRACKET 
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $9, @9.S, @9.E);}|
      
	 IMMSYM DOT IMM5 ASSIGNTO BIU2 DOT t LBRACKET IMM5 RBRACKET _flag error flag_
	 {llvmerror(&@12, "BIU2Imm dest flags error! Available flags are U/B/S"); clear();YYABORT;}|//niuxx
	 IMMSYM DOT IMM5 ASSIGNTO BIU2 DOT t LBRACKET IMM5 RBRACKET _flag biuImm2flag flag_ _flag error flag_
	 {llvmerror(&@12, "BIU2Imm dest flags error! Available flags are L/ML/MH/H"); clear();YYABORT;};//niuxx
// ducx end biu --------------------------------------------------


// ducx start mfetch --------------------------------------------------
seqslot: reinst | lpinst | mpustop | mfetchbininst | mfetchnotinst | mfetchmovinst
	 | kiMreginst | readwriteReg | jumpinst | jumpcondinst | mfetchsetcondInstr | FlagCheckInstr; 

FlagCheckInstr: FlagCheck{
            
      flagsort = (flags[ONF]);
      f = OPERAND(Imm, flagsort, FlagS, FlagE);	
	    flags.reset();
	   
	    ADDOPERAND(Opc, UCPM::FlagCheck, @$.S, @$.E);
	    Operands.push_back(nullptr);
	    condpos = Operands.size();
	    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));  
    
};

FlagCheck:  FLAGCHECK LPAREN setcgflag RPAREN |
            FLAGCHECK LPAREN error RPAREN {llvmerror(&@3, "Incorrect FlagCheck inst! flag must be 'ON' or 'OFF' !"); clear();YYABORT;};

mfetchsetcondInstr: mfetchcond{   
	    isSetCond = true;
	    ADDOPERAND(Opc, UCPM::MFetchSetCond, @$.S, @$.E);
	    Operands.push_back(nullptr);
            condpos = Operands.size(); 
	    if (imm == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
	    if (imm1 == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	    else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));   
};

mfetchcond: IMMSYM DOT IMM5 ASSIGNTO MFETCH DOT SETCOND LBRACKET IMM5 RBRACKET 
	  {imm = OPERAND(Imm, $3, @3.S, @3.E);imm1 = OPERAND(Imm, $9, @9.S, @9.E);};
	  
reinst: REPEAT ALPHA repeatexp edflag{

        if(flags[EIF])
            flagsort = 0b10;
        else if(flags[DIF])
            flagsort = 0b11;
        else
	    flagsort = 0;
	    
        f = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
       
    switch ($3){
	case 0:
	  ADDOPERAND(Opc, UCPM::REPEATIMM, @$.S, @$.E);	  
	  Operands.push_back(nullptr);
          condpos = Operands.size();     
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));  
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	break;
	
	case 1:
	  ADDOPERAND(Opc, UCPM::REPEATK, @$.S, @$.E);
	  Operands.push_back(nullptr);
          condpos = Operands.size(); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm)); 
	  if (imm1 == NULL)
	      ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
	  else
	      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
	break;
	
	default:
	  break;
    }


};

repeatexp: immrep {$$ = 0;}
	   | kirep {$$ = 1;};
	
immrep:  _flag IMM5 {imm = OPERAND(Imm, $2, @2.S, @2.E);};
kirep:	 _flag KI flag_{imm = OPERAND(Imm, $2-12, @2.S, @2.E);}
	| _flag KI SUB IMM5 flag_{
			      imm = OPERAND(Imm, $2-12, @2.S, @2.E);
			      imm1 = OPERAND(Imm, $4, @4.S, @4.E);
	      };
	      
edflag: 
| _flag interruptflag flag_
| _flag error flag_ {llvmerror(&@2, "Mfetch flags error! Available flags are EI/DI"); clear();YYABORT;};//niuxx

/*	  
reinst: REPEAT ALPHA _flag repeatexp {Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));};
repeatexp: immrep{ADDOPERAND(Opc, UCPM::REPEATIMM, @-2.S, @$.E);}; //-2 flag_
immrep: IMM5 {imm = OPERAND(Imm, $1, @$.S, @$.E); };*/

lpinst: lpexp lpcond lpflag;
lpexp: LOOP label ALPHA{
  //OS<<"Position 3\n";
  ADDOPERAND(Opc, UCPM::LPTO, @$.S, @$.E);
  Operands.push_back(nullptr);
  condpos = Operands.size();
  if(expr) Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(expr));
  else ADDOPERAND(Imm, $2, @2.S, @2.E);
};
lpcond: _flag KI flag_{
  ADDOPERAND(Imm, $2-12, @2.S, @2.E);
  ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
}
| _flag KI SUB IMM5 flag_{
 //OS<<"Position 2\n";
  ADDOPERAND(Imm, $2-12, @2.S, @2.E);
  ADDOPERAND(Imm, $4, @4.S, @4.E);
};
lpflag: {
	  ADDOPERAND(Imm, 0, SMLoc(), SMLoc());
}
| _flag interruptflag flag_{

        if(flags[EIF])
            flagsort = 0b10;
        else if(flags[DIF])
            flagsort = 0b11;
        f = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
        Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
};

mfetchbininst: binexp edflag{
              
        if(flags[EIF])
            flagsort = 0b10;
        else if(flags[DIF])
            flagsort = 0b11;
        else
	    flagsort = 0;    
        f = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
        
      ADDOPERAND(Opc, UCPM::MFetchBinInstr, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size(); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm2));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
     
};

binexp:     mfetchadd {opc = OPERAND(Reg, UCPMReg::MFetchADD, @$.S, @$.E);} | 
            mfetchsub {opc = OPERAND(Reg, UCPMReg::MFetchSUB, @$.S, @$.E);} | 
            mfetchand {opc = OPERAND(Reg, UCPMReg::MFetchAND, @$.S, @$.E);} |
            mfetchor {opc = OPERAND(Reg, UCPMReg::MFetchOR, @$.S, @$.E);}   |
            mfetchst {opc = OPERAND(Reg, UCPMReg::MFetchST, @$.S, @$.E);}   | 
            mfetchnlt {opc = OPERAND(Reg, UCPMReg::MFetchNLT, @$.S, @$.E);} | 
            mfetchequ {opc = OPERAND(Reg, UCPMReg::MFetchEQU, @$.S, @$.E);} |
            mfetchneq {opc = OPERAND(Reg, UCPMReg::MFetchNEQ, @$.S, @$.E);} |
            mfetchlsh {opc = OPERAND(Reg, UCPMReg::MFetchLSHTimm, @$.S, @$.E);} |
            mfetchrsh {opc = OPERAND(Reg, UCPMReg::MFetchRSHTimm, @$.S, @$.E);};
            
mfetchadd: kiflagtol ADD kiflagtol ASSIGNTO kiflagtol
	  {imm = OPERAND(Imm, $1-12, @1.S, @1.E);imm1 = OPERAND(Imm, $3-12, @3.S, @3.E);imm2 = OPERAND(Imm, $5-12, @5.S, @5.E);};
mfetchsub: kiflagtol SUB kiflagtol ASSIGNTO kiflagtol
	  {imm = OPERAND(Imm, $1-12, @1.S, @1.E);imm1 = OPERAND(Imm, $3-12, @3.S, @3.E);imm2 = OPERAND(Imm, $5-12, @5.S, @5.E);};
mfetchand: kiflagtol AND kiflagtol ASSIGNTO kiflagtol
	  {imm = OPERAND(Imm, $1-12, @1.S, @1.E);imm1 = OPERAND(Imm, $3-12, @3.S, @3.E);imm2 = OPERAND(Imm, $5-12, @5.S, @5.E);};
mfetchor : kiflagtol OR kiflagtol ASSIGNTO kiflagtol
	  {imm = OPERAND(Imm, $1-12, @1.S, @1.E);imm1 = OPERAND(Imm, $3-12, @3.S, @3.E);imm2 = OPERAND(Imm, $5-12, @5.S, @5.E);};
mfetchst: kiflagtol ST kiflagtol ASSIGNTO kiflagtol
	  {imm = OPERAND(Imm, $1-12, @1.S, @1.E);imm1 = OPERAND(Imm, $3-12, @3.S, @3.E);imm2 = OPERAND(Imm, $5-12, @5.S, @5.E);};
mfetchnlt: kiflagtol NLT kiflagtol ASSIGNTO kiflagtol
	  {imm = OPERAND(Imm, $1-12, @1.S, @1.E);imm1 = OPERAND(Imm, $3-12, @3.S, @3.E);imm2 = OPERAND(Imm, $5-12, @5.S, @5.E);};
mfetchequ: kiflagtol EQU kiflagtol ASSIGNTO kiflagtol
	  {imm = OPERAND(Imm, $1-12, @1.S, @1.E);imm1 = OPERAND(Imm, $3-12, @3.S, @3.E);imm2 = OPERAND(Imm, $5-12, @5.S, @5.E);};
mfetchneq : kiflagtol NEQ kiflagtol ASSIGNTO kiflagtol
	  {imm = OPERAND(Imm, $1-12, @1.S, @1.E);imm1 = OPERAND(Imm, $3-12, @3.S, @3.E);imm2 = OPERAND(Imm, $5-12, @5.S, @5.E);};
mfetchlsh: kiflagtol LSHT kiflagtol ASSIGNTO kiflagtol
	  {imm = OPERAND(Imm, $1-12, @1.S, @1.E);imm1 = OPERAND(Imm, $3-12, @3.S, @3.E);imm2 = OPERAND(Imm, $5-12, @5.S, @5.E);};
mfetchrsh: kiflagtol RSHT kiflagtol ASSIGNTO kiflagtol
	  {imm = OPERAND(Imm, $1-12, @1.S, @1.E);imm1 = OPERAND(Imm, $3-12, @3.S, @3.E);imm2 = OPERAND(Imm, $5-12, @5.S, @5.E);};

mfetchnotinst: notexp edflag{
             
        if(flags[EIF])
            flagsort = 0b10;
        else if(flags[DIF])
            flagsort = 0b11;
        else
	    flagsort = 0;    
        f = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
        
      ADDOPERAND(Opc, UCPM::MFetchNOTInstr, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size(); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
};
notexp:	 NOT kiflagtol ASSIGNTO kiflagtol
	 {imm = OPERAND(Imm, $2-12, @2.S, @2.E);imm1 = OPERAND(Imm, $4-12, @4.S, @4.E);};

	 
mfetchmovinst: movexp {
      flagsort = flags[CRF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE);
         
        if(flags[EIF])
            flagsort = 0b10;
        else if(flags[DIF])
            flagsort = 0b11;
        else
	    flagsort = 0;    
        ff = OPERAND(Imm, flagsort, FlagS, FlagE);
        
      flags.reset();
      ADDOPERAND(Opc, UCPM::MFetchMOVInstr, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size(); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
};
movexp:kiflagtol ASSIGNTO kiflagtol _flag mfetchflag flag_ edflag
	 {imm = OPERAND(Imm, $1-12, @1.S, @1.E);imm1 = OPERAND(Imm, $3-12, @3.S, @3.E);}| 
       kiflagtol ASSIGNTO kiflagtol edflag
	 {imm = OPERAND(Imm, $1-12, @1.S, @1.E);imm1 = OPERAND(Imm, $3-12, @3.S, @3.E);}|
       kiflagtol ASSIGNTO kiflagtol _flag error flag_ edflag
       {llvmerror(&@5, "Mfetch flags error! Available flags is CR"); clear();YYABORT;};//niuxx
	 
kiMreginst: KII ASSIGNTO mindexn edflag{
        if(flags[EIF])
            flagsort = 0b10;
        else if(flags[DIF])
            flagsort = 0b11;
        else
	    flagsort = 0;    
        f = OPERAND(Imm, flagsort, FlagS, FlagE);
        flags.reset();
      ADDOPERAND(Opc, UCPM::KIMRegToM, @$.S, @$.E);
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(md));
      Operands.push_back(nullptr);
      condpos = Operands.size(); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));

}
| KII ASSIGNTO mindexsia edflag{

    flagsort = (flags[APPF2] << 2) | (flags[SPPF] << 1) | flags[IPPF];
    sia = OPERAND(Imm, flagsort, FlagS, FlagE);	
        
        if(flags[EIF])
            flagsort = 0b10;
        else if(flags[DIF])
            flagsort = 0b11;
        else
	    flagsort = 0;    
        f = OPERAND(Imm, flagsort, FlagS, FlagE);
        
    flags.reset();
    
      ADDOPERAND(Opc, UCPM::KIMRegToMSIA, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size(); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(sia));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
}
| KII ASSIGNTO mindexdis edflag{

    flagsort = (flags[SHIFTF]);
    dis = OPERAND(Imm, flagsort, FlagS, FlagE);	
        if(flags[EIF])
            flagsort = 0b10;
        else if(flags[DIF])
            flagsort = 0b11;
        else
	    flagsort = 0;    
        f = OPERAND(Imm, flagsort, FlagS, FlagE);      
    flags.reset();
    
      ADDOPERAND(Opc, UCPM::KIMRegToMDIS, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size(); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(dis));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
};

readwriteReg: readReg {
      flagsort = flags[BF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE);	  
        if(flags[EIF])
            flagsort = 0b10;
        else if(flags[DIF])
            flagsort = 0b11;
        else
	    flagsort = 0;    
        ff = OPERAND(Imm, flagsort, FlagS, FlagE);
        
      flags.reset();
      ADDOPERAND(Opc, UCPM::MFetchReadRegInstr, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size(); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));
}
| writeReg {
      flagsort = flags[BF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE);	  
        if(flags[EIF])
            flagsort = 0b10;
        else if(flags[DIF])
            flagsort = 0b11;
        else
	    flagsort = 0;    
        ff = OPERAND(Imm, flagsort, FlagS, FlagE);
        
      flags.reset();
      ADDOPERAND(Opc, UCPM::MFetchWriteRegInstr, @$.S, @$.E);
      Operands.push_back(nullptr);
      condpos = Operands.size(); 
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f));
      Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));

};
	 
readReg:  REG _flag bflag flag_ ASSIGNTO kiflagtol edflag
      {imm = OPERAND(Imm, $6-12, @6.S, @6.E); imm1 = OPERAND(Imm, $1, @1.S, @1.E); };
      //| REG ASSIGNTO kiflagtol edflag
      //{imm = OPERAND(Imm, $3-12, @3.S, @3.E); imm1 = OPERAND(Imm, $1, @1.S, @1.E); };
      
readReg:  REG _flag error flag_ ASSIGNTO kiflagtol edflag
      {llvmerror(&@3, "Incorrect MFetch inst! must have (B)!"); clear();YYABORT;};
      
writeReg:kiflagtol ASSIGNTO WRITEREG _flag bflag flag_ edflag
      {imm1 = OPERAND(Imm, $3, @3.S, @3.E); imm = OPERAND(Imm, $1-12, @1.S, @1.E);};
      //| kiflagtol ASSIGNTO WRITEREG edflag
      //{imm1 = OPERAND(Imm, $3, @3.S, @3.E); imm = OPERAND(Imm, $1-12, @1.S, @1.E);};
      
writeReg:kiflagtol ASSIGNTO WRITEREG _flag error flag_ edflag
      {llvmerror(&@5, "Incorrect MFetch inst! must have (B)!"); clear();YYABORT;};
      
kiflagtol: KI | KI19 | KI23;
      
jumpinst: JMP kimep {

      flagsort = flags[SF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE);	   
      
        if(flags[EIF])
            flagsort = 0b10;
        else if(flags[DIF])
            flagsort = 0b11;
        else
	    flagsort = 0;    
        ff = OPERAND(Imm, flagsort, FlagS, FlagE);
        
      flags.reset();
      
	  ADDOPERAND(Opc, UCPM::JUMPK, @$.S, @$.E);
	  Operands.push_back(nullptr);
          condpos = Operands.size(); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));

}
| JMP labelep {

      flagsort = flags[SF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE);	 
      
      if(flags[EIF])
            flagsort = 0b10;
        else if(flags[DIF])
            flagsort = 0b11;
        else
	    flagsort = 0;    
        ff = OPERAND(Imm, flagsort, FlagS, FlagE);
        
      flags.reset();
      
      	  ADDOPERAND(Opc, UCPM::JUMP, @$.S, @$.E);
      	  Operands.push_back(nullptr);
          condpos = Operands.size(); 
	  if(expr) 
	    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(expr));
	  else 
	    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm)); 
	    
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff)); 

};

kimep:	KI _flag sflag flag_ edflag {imm = OPERAND(Imm, $1-12, @1.S, @1.E);}| 
	KI edflag {imm = OPERAND(Imm, $1-12, @1.S, @1.E);}|
	
	KI _flag error flag_ edflag {llvmerror(&@3, "JUMP_kim flags error! Available flags is S"); clear();YYABORT;};//niuxx
labelep:  label edflag { 
	      if(!expr) 
		imm = OPERAND(Imm, $1, @1.S, @1.E);
	  }
	  | label _flag sflag flag_ edflag { 
	      if(!expr) 
		imm = OPERAND(Imm, $1, @1.S, @1.E);
	  }|
	  label _flag error flag_ edflag {llvmerror(&@3, "JUMP_label flags error! Available flags is S"); clear();YYABORT;};//niuxx
  
	
jumpcondinst: IFIF _flag condki flag_ JMP kimep{

      flagsort = flags[SF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE);	
      
        if(flags[EIF])
            flagsort = 0b10;
        else if(flags[DIF])
            flagsort = 0b11;
        else
	    flagsort = 0;    
        ff = OPERAND(Imm, flagsort, FlagS, FlagE);
        
      flags.reset();
      
	  ADDOPERAND(Opc, UCPM::JUMPKcondki, @$.S, @$.E);
	  Operands.push_back(nullptr);
          condpos = Operands.size();
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff)); 

}
| IFIF _flag condki flag_ JMP labelep{

      flagsort = flags[SF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE);	 
      
        if(flags[EIF])
            flagsort = 0b10;
        else if(flags[DIF])
            flagsort = 0b11;
        else
	    flagsort = 0;    
        ff = OPERAND(Imm, flagsort, FlagS, FlagE);
        
      flags.reset();
      
	  ADDOPERAND(Opc, UCPM::JUMPcondki, @$.S, @$.E);
	  Operands.push_back(nullptr);
          condpos = Operands.size(); 
	  if(expr) 
	    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(expr));
	  else 
	    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));

}
| IFIF _flag condki2319 flag_ JMP kimep{

      flagsort = flags[SF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE);	 
      
        if(flags[EIF])
            flagsort = 0b10;
        else if(flags[DIF])
            flagsort = 0b11;
        else
	    flagsort = 0;    
        ff = OPERAND(Imm, flagsort, FlagS, FlagE);
        
      flags.reset();
      
	  ADDOPERAND(Opc, UCPM::JUMPKcondki2319, @$.S, @$.E);
	  Operands.push_back(nullptr);
          condpos = Operands.size();
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm2));
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));

}
| IFIF _flag condki2319 flag_ JMP labelep{

      flagsort = flags[SF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE);	 
      
        if(flags[EIF])
            flagsort = 0b10;
        else if(flags[DIF])
            flagsort = 0b11;
        else
	    flagsort = 0;    
        ff = OPERAND(Imm, flagsort, FlagS, FlagE);
        
      flags.reset();
      
	  ADDOPERAND(Opc, UCPM::JUMPcondki2319, @$.S, @$.E);
	  Operands.push_back(nullptr);
          condpos = Operands.size(); 
	  if(expr) 
	    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(expr));
	  else 
	    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm2)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));

}
| IFIF _flag conduncq flag_ JMP kimep{

      flagsort = flags[SF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE);	
      
       if(flags[UF])
	  flagsort = 0x0;
       else if(flags[NF])
	  flagsort = 0x1;
       else if(flags[CF])
	  flagsort = 0x2;
       else if(flags[QF])
	  flagsort = 0x3;
      qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
      
        if(flags[EIF])
            flagsort = 0b10;
        else if(flags[DIF])
            flagsort = 0b11;
        else
	    flagsort = 0;    
        ff = OPERAND(Imm, flagsort, FlagS, FlagE);
        
      flags.reset();
      
	  ADDOPERAND(Opc, UCPM::JUMPKcondUNCQ, @$.S, @$.E);
	  Operands.push_back(nullptr);
          condpos = Operands.size();
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm2)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc));
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));

}
| IFIF _flag conduncq flag_ JMP labelep{

      flagsort = flags[SF];
      f = OPERAND(Imm, flagsort, FlagS, FlagE);	
      
       if(flags[UF])
	  flagsort = 0x0;
       else if(flags[NF])
	  flagsort = 0x1;
       else if(flags[CF])
	  flagsort = 0x2;
       else if(flags[QF])
	  flagsort = 0x3;
      qlh = OPERAND(Imm, flagsort, FlagS, FlagE);
      
        if(flags[EIF])
            flagsort = 0b10;
        else if(flags[DIF])
            flagsort = 0b11;
        else
	    flagsort = 0;    
        ff = OPERAND(Imm, flagsort, FlagS, FlagE);
        
        
      flags.reset();
      
	  ADDOPERAND(Opc, UCPM::JUMPcondUNCQ, @$.S, @$.E);
	  Operands.push_back(nullptr);
          condpos = Operands.size();
	  if(expr) 
	    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(expr));
	  else 
	    Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(f)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(qlh)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm1)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(imm2)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(opc)); 
	  Operands.push_back(std::unique_ptr<UCPM::UCPMAsmOperand>(ff));

};
	  
condki:   condequ0 {opc = OPERAND(Reg, UCPMReg::CondEQU0, @$.S, @$.E);} |
	  condneq0 {opc = OPERAND(Reg, UCPMReg::CondNEQ0, @$.S, @$.E);} ;
condequ0: NEG kiflagtol {imm1 = OPERAND(Imm, $2-12, @2.S, @2.E);};
condneq0: kiflagtol {imm1 = OPERAND(Imm, $1-12, @1.S, @1.E);};

condki2319: condequ {opc = OPERAND(Reg, UCPMReg::CondEQU, @$.S, @$.E);} |
	    condneq {opc = OPERAND(Reg, UCPMReg::CondNEQ, @$.S, @$.E);} |
	    condnst {opc = OPERAND(Reg, UCPMReg::CondNST, @$.S, @$.E);} |
	    condst {opc = OPERAND(Reg, UCPMReg::CondST, @$.S, @$.E);} ;
condequ: kiflagtol EQU KI23 {imm1 = OPERAND(Imm, $1-12, @1.S, @1.E);imm2 = OPERAND(Imm, 1, SMLoc(), SMLoc());} |
	 kiflagtol EQU KI19 {imm1 = OPERAND(Imm, $1-12, @1.S, @1.E);imm2 = OPERAND(Imm, 0, SMLoc(), SMLoc());} ;
condneq: kiflagtol NEQ KI23 {imm1 = OPERAND(Imm, $1-12, @1.S, @1.E);imm2 = OPERAND(Imm, 1, SMLoc(), SMLoc());} |
	 kiflagtol NEQ KI19 {imm1 = OPERAND(Imm, $1-12, @1.S, @1.E);imm2 = OPERAND(Imm, 0, SMLoc(), SMLoc());} ;
condnst: kiflagtol NST KI23 {imm1 = OPERAND(Imm, $1-12, @1.S, @1.E);imm2 = OPERAND(Imm, 1, SMLoc(), SMLoc());} |
	 kiflagtol NST KI19 {imm1 = OPERAND(Imm, $1-12, @1.S, @1.E);imm2 = OPERAND(Imm, 0, SMLoc(), SMLoc());} ;
condst:  kiflagtol ST KI23 {imm1 = OPERAND(Imm, $1-12, @1.S, @1.E);imm2 = OPERAND(Imm, 1, SMLoc(), SMLoc());} |
	 kiflagtol ST KI19 {imm1 = OPERAND(Imm, $1-12, @1.S, @1.E);imm2 = OPERAND(Imm, 0, SMLoc(), SMLoc());} ;

conduncq: condIALU {opc = OPERAND(Reg, UCPMReg::ALUIALU, @$.S, @$.E);} |
	  condIMAC {opc = OPERAND(Reg, UCPMReg::ALUIMAC, @$.S, @$.E);} |
	  condIFALU {opc = OPERAND(Reg, UCPMReg::ALUIFALU, @$.S, @$.E);} |
	  condIFMAC {opc = OPERAND(Reg, UCPMReg::ALUIFMAC, @$.S, @$.E);} ;

condIALU: AND IALU DOT uncqflag{imm1 = OPERAND(Imm, 1, SMLoc(), SMLoc());imm2 = OPERAND(Imm, 0, SMLoc(), SMLoc());} |
	  OR IALU DOT uncqflag{imm1 = OPERAND(Imm, 0, SMLoc(), SMLoc());imm2 = OPERAND(Imm, 0, SMLoc(), SMLoc());} |
	  NEG LPAREN AND IALU DOT uncqflag RPAREN{imm1 = OPERAND(Imm, 1, SMLoc(), SMLoc());imm2 = OPERAND(Imm, 1, SMLoc(), SMLoc());} |
	  NEG LPAREN OR IALU DOT uncqflag RPAREN{imm1 = OPERAND(Imm, 0, SMLoc(), SMLoc());imm2 = OPERAND(Imm, 1, SMLoc(), SMLoc());} |
	  
	  AND IALU DOT error {llvmerror(&@4, "IF CondIALU flags error! Available flags are U/N/C/Q"); clear();YYABORT;}|//niuxx
	  OR IALU DOT error {llvmerror(&@4, "IF CondIALU flags error! Available flags are U/N/C/Q"); clear();YYABORT;}|//niuxx
	  NEG LPAREN AND IALU DOT error RPAREN {llvmerror(&@6, "IF CondIALU flags error! Available flags are U/N/C/Q"); clear();YYABORT;}|//niuxx
	  NEG LPAREN OR IALU DOT error RPAREN {llvmerror(&@6, "IF CondIALU flags error! Available flags are U/N/C/Q"); clear();YYABORT;};//niuxx
	  
condIMAC: AND IMAC DOT uncqflag{imm1 = OPERAND(Imm, 1, SMLoc(), SMLoc());imm2 = OPERAND(Imm, 0, SMLoc(), SMLoc());} |
	  OR IMAC DOT uncqflag{imm1 = OPERAND(Imm, 0, SMLoc(), SMLoc());imm2 = OPERAND(Imm, 0, SMLoc(), SMLoc());} |
	  NEG LPAREN AND IMAC DOT uncqflag RPAREN{imm1 = OPERAND(Imm, 1, SMLoc(), SMLoc());imm2 = OPERAND(Imm, 1, SMLoc(), SMLoc());} |
	  NEG LPAREN OR IMAC DOT uncqflag RPAREN{imm1 = OPERAND(Imm, 0, SMLoc(), SMLoc());imm2 = OPERAND(Imm, 1, SMLoc(), SMLoc());} |
	  
	  AND IMAC DOT error {llvmerror(&@4, "IF CondIMAC flags error! Available flags are U/N/C/Q"); clear();YYABORT;}|//niuxx
	  OR IMAC DOT error {llvmerror(&@4, "IF CondIMAC flags error! Available flags are U/N/C/Q"); clear();YYABORT;}|//niuxx
	  NEG LPAREN AND IMAC DOT error RPAREN {llvmerror(&@6, "IF CondIMAC flags error! Available flags are U/N/C/Q"); clear();YYABORT;}|//niuxx
	  NEG LPAREN OR IMAC DOT error RPAREN {llvmerror(&@6, "IF CondIMAC flags error! Available flags are U/N/C/Q"); clear();YYABORT;};//niuxx
	  
condIFALU:AND IFALU DOT uncqflag{imm1 = OPERAND(Imm, 1, SMLoc(), SMLoc());imm2 = OPERAND(Imm, 0, SMLoc(), SMLoc());} |
	  OR IFALU DOT uncqflag{imm1 = OPERAND(Imm, 0, SMLoc(), SMLoc());imm2 = OPERAND(Imm, 0, SMLoc(), SMLoc());} |
	  NEG LPAREN AND IFALU DOT uncqflag RPAREN{imm1 = OPERAND(Imm, 1, SMLoc(), SMLoc());imm2 = OPERAND(Imm, 1, SMLoc(), SMLoc());} |
	  NEG LPAREN OR IFALU DOT uncqflag RPAREN{imm1 = OPERAND(Imm, 0, SMLoc(), SMLoc());imm2 = OPERAND(Imm, 1, SMLoc(), SMLoc());} |
	  
	  AND IFALU DOT error {llvmerror(&@4, "IF CondIFALU flags error! Available flags are U/N/C/Q"); clear();YYABORT;}|//niuxx
	  OR IFALU DOT error {llvmerror(&@4, "IF CondIFALU flags error! Available flags are U/N/C/Q"); clear();YYABORT;}|//niuxx
	  NEG LPAREN AND IFALU DOT error RPAREN {llvmerror(&@6, "IF CondIFALU flags error! Available flags are U/N/C/Q"); clear();YYABORT;}|//niuxx
	  NEG LPAREN OR IFALU DOT error RPAREN {llvmerror(&@6, "IF CondIFALU flags error! Available flags are U/N/C/Q"); clear();YYABORT;};//niuxx
	  
condIFMAC:AND IFMAC DOT uncqflag{imm1 = OPERAND(Imm, 1, SMLoc(), SMLoc());imm2 = OPERAND(Imm, 0, SMLoc(), SMLoc());} |
	  OR IFMAC DOT uncqflag{imm1 = OPERAND(Imm, 0, SMLoc(), SMLoc());imm2 = OPERAND(Imm, 0, SMLoc(), SMLoc());} |
	  NEG LPAREN AND IFMAC DOT uncqflag RPAREN{imm1 = OPERAND(Imm, 1, SMLoc(), SMLoc());imm2 = OPERAND(Imm, 1, SMLoc(), SMLoc());} |
	  NEG LPAREN OR IFMAC DOT uncqflag RPAREN{imm1 = OPERAND(Imm, 0, SMLoc(), SMLoc());imm2 = OPERAND(Imm, 1, SMLoc(), SMLoc());} |
	  
	  AND IFMAC DOT error {llvmerror(&@4, "IF CondIFMAC flags error! Available flags are U/N/C/Q"); clear();YYABORT;}|//niuxx
	  OR IFMAC DOT error {llvmerror(&@4, "IF CondIFMAC flags error! Available flags are U/N/C/Q"); clear();YYABORT;}|//niuxx
	  NEG LPAREN AND IFMAC DOT error RPAREN {llvmerror(&@6, "IF CondIFMAC flags error! Available flags are U/N/C/Q"); clear();YYABORT;}|//niuxx
	  NEG LPAREN OR IFMAC DOT error RPAREN {llvmerror(&@6, "IF CondIFMAC flags error! Available flags are U/N/C/Q"); clear();YYABORT;};//niuxx

mpustop:MPUSTOP {
	    ADDOPERAND(Opc, UCPM::MPUStop, @$.S, @$.E);
	    Operands.push_back(nullptr);
            condpos = Operands.size(); 
          };

// ducx end mfetch --------------------------------------------------


ialut: ialu DOT t {$$ = 2; unit = OPERAND(Reg, UCPMReg::IALU, @1.S, @1.E); unit2 = OPERAND(Reg, UCPMReg::MTIALU, @1.S, @1.E); unit3 = OPERAND(Reg, UCPMReg::IALUIALU, @1.S, @1.E); unit4 = OPERAND(Reg, UCPMReg::IMACIALU, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};
_ialut: _IALU DOT t {$$ = 6;  unit3 = OPERAND(Reg, UCPMReg::_IALUIALU, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};
imact: imac DOT t {$$ = 2; unit = OPERAND(Reg, UCPMReg::sIMAC, @1.S, @1.E); unit2 = OPERAND(Reg, UCPMReg::MTIMAC, @1.S, @1.E); unit3 = OPERAND(Reg, UCPMReg::IALUIMAC, @1.S, @1.E); unit4 = OPERAND(Reg, UCPMReg::IMACIMAC, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));}; 
ifalut: ifalu DOT t {$$ = 2; unit = OPERAND(Reg, UCPMReg::sIFALU, @1.S, @1.E); unit2 = OPERAND(Reg, UCPMReg::MTIFALU, @1.S, @1.E); unit3 = OPERAND(Reg, UCPMReg::IALUIFALU, @1.S, @1.E); unit4 = OPERAND(Reg, UCPMReg::IMACIFALU, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};
_ifalut: _IFALU DOT t {$$ = 6;  unit3 = OPERAND(Reg, UCPMReg::_IFALUIFALU, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};
ifmact: ifmac DOT t {$$ = 2; unit = OPERAND(Reg, UCPMReg::IFMAC, @1.S, @1.E); unit2 = OPERAND(Reg, UCPMReg::MTIFMAC, @1.S, @1.E); unit3 = OPERAND(Reg, UCPMReg::IALUIFMAC, @1.S, @1.E); unit4 = OPERAND(Reg, UCPMReg::IMACIFMAC, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));}; 

ialute: ialu DOT shusrct _flag IPATH flag_ {$$ = 2; ipath = OPERAND(Imm, $5, @5.S, @5.E); unit = OPERAND(Reg, UCPMReg::biuIALU, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};
imacte: imac DOT shusrct _flag IPATH flag_ {$$ = 2; ipath = OPERAND(Imm, $5, @5.S, @5.E); unit = OPERAND(Reg, UCPMReg::biuIMAC, @1.S, @1.E); if (!ut) ut = tk ? tk : (tp ? tp : (tn ? tn : tm));};
ifalute: ifalu DOT shusrct _flag IPATH flag_ {$$ = 6; ipath = OPERAND(Imm, $5, @5.S, @5.E); unit = OPERAND(Reg, UCPMReg::biuIFALU, @1.S, @1.E); if (!ut) ut = tk ? tk : (tp ? tp : (tn ? tn : tm));};
ifmacte: ifmac DOT shusrct _flag IPATH flag_ {$$ = 6; ipath = OPERAND(Imm, $5, @5.S, @5.E); unit = OPERAND(Reg, UCPMReg::biuIFMAC, @1.S, @1.E); if (!ut) ut = tk ? tk : (tp ? tp : (tn ? tn : tm));};

/*biu0t: biu0 {$$ = 3; unit = b; unit2 = b2;
             unsigned treg = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(0);//here 't0' is assigned to biu0t
             ut = OPERAND(Reg, treg, @$.S, @$.E); }
biu1t: biu1 {$$ = 3; unit = b; unit2 = b2;
             unsigned treg = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(0);//here 't0' is assigned to biu0t
             ut = OPERAND(Reg, treg, @$.S, @$.E); }
biu2t: biu2 {$$ = 3; unit = b; unit2 = b2;
             unsigned treg = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister(0);//here 't0' is assigned to biu0t
             ut = OPERAND(Reg, treg, @$.S, @$.E); }
biu0: BIU0 {$$ = 2; b = OPERAND(Reg, UCPMReg::BIU0, @$.S, @$.E); b2 = OPERAND(Reg, UCPMReg::MTBIU0, @$.S, @$.E);};
biu1: BIU1 {$$ = 2; b = OPERAND(Reg, UCPMReg::BIU1, @$.S, @$.E); b2 = OPERAND(Reg, UCPMReg::MTBIU1, @$.S, @$.E);};
biu2: BIU2 {$$ = 2; b = OPERAND(Reg, UCPMReg::BIU2, @$.S, @$.E); b2 = OPERAND(Reg, UCPMReg::MTBIU2, @$.S, @$.E);};*/

shu0t: SHU0 DOT t {$$ = 1; unit = OPERAND(Reg, UCPMReg::SHU0, @1.S, @1.E); unit2 = OPERAND(Reg, UCPMReg::MTSHU0, @1.S, @1.E); unit3 = OPERAND(Reg, UCPMReg::IALUSHU0, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));} ;
shu1t: SHU1 DOT t {$$ = 1; unit = OPERAND(Reg, UCPMReg::SHU1, @1.S, @1.E); unit2 = OPERAND(Reg, UCPMReg::MTSHU1, @1.S, @1.E); unit3 = OPERAND(Reg, UCPMReg::IALUSHU1, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));} ;
shu2t: SHU2 DOT t {$$ = 1; unit = OPERAND(Reg, UCPMReg::SHU2, @1.S, @1.E); unit2 = OPERAND(Reg, UCPMReg::MTSHU2, @1.S, @1.E); unit3 = OPERAND(Reg, UCPMReg::IALUSHU2, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));} ;

//haoxb
/*ialu_shu0t: IALU DOT t AND SHU0 DOT t {$$ = 1; unit = OPERAND(Reg, UCPMReg::SHU0, @1.S, @1.E); unit2 = OPERAND(Reg, UCPMReg::MTSHU0, @1.S, @1.E); unit3 = OPERAND(Reg, UCPMReg::IALUSHU0, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};
ialu_shu1t:  IALU DOT t AND SHU1 DOT t {$$ = 1; unit = OPERAND(Reg, UCPMReg::SHU1, @1.S, @1.E); unit2 = OPERAND(Reg, UCPMReg::MTSHU1, @1.S, @1.E); unit3 = OPERAND(Reg, UCPMReg::IALUSHU1, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};
ialu_shu2t: IALU DOT t AND SHU2 DOT t {$$ = 1; unit = OPERAND(Reg, UCPMReg::SHU2, @1.S, @1.E); unit2 = OPERAND(Reg, UCPMReg::MTSHU2, @1.S, @1.E); unit3 = OPERAND(Reg, UCPMReg::IALUSHU2, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};

ialu_ialut:IALU DOT t AND ialu DOT t {$$ = 2; unit = OPERAND(Reg, UCPMReg::IALU, @1.S, @1.E); unit2 = OPERAND(Reg, UCPMReg::MTIALU, @1.S, @1.E); unit3 = OPERAND(Reg, UCPMReg::IALUIALU, @1.S, @1.E); unit4 = OPERAND(Reg, UCPMReg::IMACIALU, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};
ialu_ifalut:IALU DOT t AND ifalu DOT t {$$ = 2; unit = OPERAND(Reg, UCPMReg::IFALU, @1.S, @1.E); unit2 = OPERAND(Reg, UCPMReg::MTIFALU, @1.S, @1.E); unit3 = OPERAND(Reg, UCPMReg::IALUIFALU, @1.S, @1.E); unit4 = OPERAND(Reg, UCPMReg::sIMAC, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));} ;
ialu_imact:IALU DOT t AND imac DOT t {$$ = 2; unit = OPERAND(Reg, UCPMReg::IMAC, @1.S, @1.E); unit2 = OPERAND(Reg, UCPMReg::MTIMAC, @1.S, @1.E); unit3 = OPERAND(Reg, UCPMReg::IALUIMAC, @1.S, @1.E); unit4 = OPERAND(Reg, UCPMReg::sIMAC, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));} ;
ialu_ifmact:IALU DOT t AND ifmac DOT t {$$ = 2; unit = OPERAND(Reg, UCPMReg::IFMAC, @1.S, @1.E); unit2 = OPERAND(Reg, UCPMReg::MTIFMAC, @1.S, @1.E); unit3 = OPERAND(Reg, UCPMReg::IALUIFMAC, @1.S, @1.E); unit4 = OPERAND(Reg, UCPMReg::sIMAC, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));} ;

ialu_biu0t: IALU DOT t AND BIU0 DOT t {$$ = 1; unit = OPERAND(Reg, UCPMReg::BIU0, @1.S, @1.E); unit2 = OPERAND(Reg, UCPMReg::MTBIU0, @1.S, @1.E); unit3 = OPERAND(Reg, UCPMReg::IALUBIU0, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));} ;
ialu_biu1t: IALU DOT t AND BIU1 DOT t {$$ = 1; unit = OPERAND(Reg, UCPMReg::BIU1, @1.S, @1.E); unit2 = OPERAND(Reg, UCPMReg::MTBIU1, @1.S, @1.E); unit3 = OPERAND(Reg, UCPMReg::IALUBIU1, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));} ;
ialu_biu2t: IALU DOT t AND BIU2 DOT t {$$ = 1; unit = OPERAND(Reg, UCPMReg::BIU2, @1.S, @1.E); unit2 = OPERAND(Reg, UCPMReg::MTBIU2, @1.S, @1.E); unit3 = OPERAND(Reg, UCPMReg::IALUBIU2, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));} ;
*/
//dcx FOR BIU
shu0te: SHU0 DOT shusrct {$$ = 1; unit = OPERAND(Reg, UCPMReg::SHU0, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};
shu1te: SHU1 DOT shusrct {$$ = 1; unit = OPERAND(Reg, UCPMReg::SHU1, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};
shu2te: SHU2 DOT shusrct {$$ = 1; unit = OPERAND(Reg, UCPMReg::SHU2, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};
b1shu2te: SHU2 DOT shusrct {$$ = 1; unit = OPERAND(Reg, UCPMReg::B1SHU2, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};
b2shu1te: SHU1 DOT shusrct {$$ = 1; unit = OPERAND(Reg, UCPMReg::B2SHU1, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};
bbiu0te: BIU0 DOT shusrct {$$ = 0; unit = OPERAND(Reg, UCPMReg::bBIU0, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};
bbiu1te: BIU1 DOT shusrct {$$ = 0; unit = OPERAND(Reg, UCPMReg::bBIU1, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};
bbiu2te: BIU2 DOT shusrct {$$ = 0; unit = OPERAND(Reg, UCPMReg::bBIU2, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};
bshu0te: SHU0 DOT shusrct {$$ = 1; unit = OPERAND(Reg, UCPMReg::biuSHU0, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};
bshu1te: SHU1 DOT shusrct {$$ = 1; unit = OPERAND(Reg, UCPMReg::biuSHU1, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};
bshu2te: SHU2 DOT shusrct {$$ = 1; unit = OPERAND(Reg, UCPMReg::biuSHU2, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};


//dcx FOR SHU
biu0t: BIU0 DOT t {$$ = 1; unit = OPERAND(Reg, UCPMReg::BIU0, @1.S, @1.E); unit2 = OPERAND(Reg, UCPMReg::MTBIU0, @1.S, @1.E); unit3 = OPERAND(Reg, UCPMReg::IALUBIU0, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};
biu1t: BIU1 DOT t {$$ = 1; unit = OPERAND(Reg, UCPMReg::BIU1, @1.S, @1.E); unit2 = OPERAND(Reg, UCPMReg::MTBIU1, @1.S, @1.E); unit3 = OPERAND(Reg, UCPMReg::IALUBIU1, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};
biu2t: BIU2 DOT t {$$ = 1; unit = OPERAND(Reg, UCPMReg::BIU2, @1.S, @1.E); unit2 = OPERAND(Reg, UCPMReg::MTBIU2, @1.S, @1.E); unit3 = OPERAND(Reg, UCPMReg::IALUBIU2, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};
s1biu1t: BIU1 DOT t {$$ = 1; unit = OPERAND(Reg, UCPMReg::S1BIU1, @1.S, @1.E); if (!ut) ut = tk ? tk : (tp ? tp : (tn ? tn : tm));};
s2biu1t: BIU1 DOT t {$$ = 1; unit = OPERAND(Reg, UCPMReg::S2BIU1, @1.S, @1.E); if (!ut) ut = tk ? tk : (tp ? tp : (tn ? tn : tm));};
//sshu0t:DestSHU0 DOT t {$$ = 0; unit = OPERAND(Reg, UCPMReg::sSHU0, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};
//sshu1t:DestSHU1 DOT t {$$ = 0; unit = OPERAND(Reg, UCPMReg::sSHU1, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};
//sshu2t:DestSHU2 DOT t {$$ = 0; unit = OPERAND(Reg, UCPMReg::sSHU2, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};
sbiu0t: BIU0 DOT t {$$ = 1; unit = OPERAND(Reg, UCPMReg::shuBIU0, @1.S, @1.E); unit2 = OPERAND(Reg, UCPMReg::MTBIU0, @1.S, @1.E); unit3 = OPERAND(Reg, UCPMReg::ALUBIU0, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};
sbiu1t: BIU1 DOT t {$$ = 1; unit = OPERAND(Reg, UCPMReg::shuBIU1, @1.S, @1.E); unit2 = OPERAND(Reg, UCPMReg::MTBIU1, @1.S, @1.E); unit3 = OPERAND(Reg, UCPMReg::ALUBIU1, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};
sbiu2t: BIU2 DOT t {$$ = 1; unit = OPERAND(Reg, UCPMReg::shuBIU2, @1.S, @1.E); unit2 = OPERAND(Reg, UCPMReg::MTBIU2, @1.S, @1.E); unit3 = OPERAND(Reg, UCPMReg::ALUBIU2, @1.S, @1.E); if (!ut) ut = ts ? ts : (tl ? tl : (tk ? tk : (tp ? tp : (tn ? tn : tm))));};


//mindexs: MINDEXS {$$ = 0; ms = md; md = OPERAND(Reg, UCPMReg::MSPP, @$.S, @$.E);};
//mindexi: MINDEXI {$$ = 0; ms = md; md = OPERAND(Reg, UCPMReg::MIPP, @$.S, @$.E);};
mindexn: MINDEXN {$$ = 3; ms = md;
  md = OPERAND(Reg,MRI->getRegClass(UCPMReg::MRegRegClassID).getRegister($1),@$.S, @$.E);
};
/*ialu_mindexn: IALU DOT t AND MINDEXN {$$ = 3; ms = md;
  md = OPERAND(Reg,
               MRI->getRegClass(UCPMReg::MRegRegClassID).getRegister($1),
               @$.S, @$.E);
};*/

shuts: TREG {
  unsigned treg = MRI->getRegClass(UCPMReg::SHUTSPortRegClassID).getRegister($1);
  if (!tm) tm = OPERAND(Reg, treg, @$.S, @$.E);
  else if (!tn) tn = OPERAND(Reg, treg, @$.S, @$.E);
  else if (!tp) tp = OPERAND(Reg, treg, @$.S, @$.E);
  else if (!tk) tk = OPERAND(Reg, treg, @$.S, @$.E);
  else if (!tl) tl = OPERAND(Reg, treg, @$.S, @$.E);
  else if (!ts) ts = OPERAND(Reg, treg, @$.S, @$.E);
  else if (!ut) ut = OPERAND(Reg, treg, @$.S, @$.E);
} ;

t: TREG {
  unsigned treg = MRI->getRegClass(UCPMReg::TPortRegClassID).getRegister($1);
  if (!tm) tm = OPERAND(Reg, treg, @$.S, @$.E);
  else if (!tn) tn = OPERAND(Reg, treg, @$.S, @$.E);
  else if (!tp) tp = OPERAND(Reg, treg, @$.S, @$.E);
  else if (!tk) tk = OPERAND(Reg, treg, @$.S, @$.E);
  else if (!tl) tl = OPERAND(Reg, treg, @$.S, @$.E);
  else if (!ts) ts = OPERAND(Reg, treg, @$.S, @$.E);
  else if (!ut) ut = OPERAND(Reg, treg, @$.S, @$.E);
} ;
constt: _constt {
  unsigned treg = $1;
  if (!tm) tm = OPERAND(Reg, treg, @$.S, @$.E);
  else if (!tn) tn = OPERAND(Reg, treg, @$.S, @$.E);
  else if (!tp) tp = OPERAND(Reg, treg, @$.S, @$.E);
  else if (!tk) tk = OPERAND(Reg, treg, @$.S, @$.E);
  else if (!tl) tl = OPERAND(Reg, treg, @$.S, @$.E);
  else if (!ts) ts = OPERAND(Reg, treg, @$.S, @$.E);
  else if (!ut) ut = OPERAND(Reg, treg, @$.S, @$.E);
}
/*_constt: TBB {$$ = UCPMReg::TBB;} |
         TBH {$$ = UCPMReg::TBH;} |
         TBW {$$ = UCPMReg::TBW;} |
         TBD {$$ = UCPMReg::TBD;} |
         TSQ {$$ = UCPMReg::TSQ;} ;*/
         
_constt: TC0 {$$ = UCPMReg::TC0;} |
         TC1 {$$ = UCPMReg::TC1;} |
         TC2 {$$ = UCPMReg::TC2;} |
         TC3 {$$ = UCPMReg::TC3;} |
         TC4 {$$ = UCPMReg::TC4;} |
         TC5 {$$ = UCPMReg::TC5;} |
         TC6 {$$ = UCPMReg::TC6;} |
         TC7 {$$ = UCPMReg::TC7;} |
         TC8 {$$ = UCPMReg::TC8;} |
         TC9 {$$ = UCPMReg::TC9;} |
         TCA {$$ = UCPMReg::TCA;} |
         TCB {$$ = UCPMReg::TCB;} |
         TCC {$$ = UCPMReg::TCC;} |
         TCD {$$ = UCPMReg::TCD;} |
         TCE {$$ = UCPMReg::TCE;} |
         TCF {$$ = UCPMReg::TCF;} |
         TB {$$ = UCPMReg::TSB;} ;

shutsrct: shuts | constt;
shusrct: t | constt;
tripara: dupara COMMA t;
dupara: t COMMA t;

_flag: LPAREN {FlagS = @$.E;};
flag_: RPAREN {FlagE = @$.S;};
imm: imm5 | IMM;
imm1: imm5 | IMM;
imm2: imm5 | IMM;
imm5: IMM3 | IMM5 ; 
ialu: IALU ;
imac: IMAC ;
falu: FALU ;
fmac: FMAC ;
ifalu: IFALU ;
ifmac: IFMAC ;


ialuflags: ialuflag | ialuflag COMMA ialuflags;
ialuflag:    T   {flags.set(TF);}  |
             CI  {flags.set(CIF);} |
             F   {flags.set(FF);}  |
             ROUND   {flags.set(ROUNDF);}  |
             B   {flags.set(BF);}  |
             S   {flags.set(SF);}  |
             L   {flags.set(LF);}  |
             U   {flags.set(UF);}  |
             N   {flags.set(NF);}  |//haoxb
             A1  {flags.set(A1F);}  |//haoxb
             A2  {flags.set(A2F);}  |//haoxb
             FLAG  {flags.set(FLAGF);}  |
             A   {flags.set(AF);}  |
             E   {flags.set(EF);}  |
             X   {flags.set(XF);}  |
             P   {flags.set(PF);}  |
             G   {flags.set(GF);}  ;

ialuconjflags:ialuconjflag | ialuconjflag COMMA ialuconjflags;//IALU.CONJ flags
ialuconjflag: B   {if (flags[BF] || flags[SF]) {llvmerror(&@1, "IALU/IFALU_Conj flags error! Available flags are B/S,T,F"); clear();YYABORT;}
		   else flags.set(BF);}  |
              S   {if (flags[BF] || flags[BF]) {llvmerror(&@1, "IALU/IFALU_Conj flags error! Available flags are B/S,T,F"); clear();YYABORT;}
		   else flags.set(SF);}  |
              T   {if (flags[TF]) {llvmerror(&@1, "IALU/IFALU_Conj flags error! Available flags are B/S,T,F"); clear();YYABORT;}
		   else flags.set(TF);}  |
              F   {if (flags[FF]) {llvmerror(&@1, "IALU/IFALU_Conj flags error! Available flags are B/S,T,F"); clear();YYABORT;}
		   else flags.set(FF);}  ;//niuxx
             
ialusel1flags: ialusel1flag | ialusel1flag COMMA ialusel1flags;//IALU.Sel1 flags
ialusel1flag: N   {if (flags[NF]) {llvmerror(&@1, "IALU/IFALU_Sel flags error! Available flags are N,T,CI,F,B/S,U"); clear();YYABORT;}
		   else flags.set(NF);}  |
	      T   {if (flags[TF]) {llvmerror(&@1, "IALU/IFALU_Sel flags error! Available flags are N,T,CI,F,B/S,U"); clear();YYABORT;}
		   else flags.set(TF);}  |
	      CI  {if (flags[CIF]) {llvmerror(&@1, "IALU/IFALU_Sel flags error! Available flags are N,T,CI,F,B/S,U"); clear();YYABORT;}
		   else flags.set(CIF);} |
	      F   {if (flags[FF]) {llvmerror(&@1, "IALU/IFALU_Sel flags error! Available flags are N,T,CI,F,B/S,U"); clear();YYABORT;}
		   else flags.set(FF);}  |
	      B   {if (flags[BF] || flags[SF]) {llvmerror(&@1, "IALU/IFALU_Sel flags error! Available flags are N,T,CI,F,B/S,U"); clear();YYABORT;}
		   else flags.set(BF);}  |
              S   {if (flags[SF] || flags[BF]) {llvmerror(&@1, "IALU/IFALU_Sel flags error! Available flags are N,T,CI,F,B/S,U"); clear();YYABORT;}
		   else flags.set(SF);}  |
              U   {if (flags[UF]) {llvmerror(&@1, "IALU/IFALU_Sel flags error! Available flags are N,T,CI,F,B/S,U"); clear();YYABORT;}
		   else flags.set(UF);}  ;//niuxx             
             
ialusel0flags: ialusel0flag | ialusel0flag COMMA ialusel0flags;//IALU.Sel0 flags
ialusel0flag: T   {if (flags[TF]) {llvmerror(&@1, "IALU/IFALU_Sel flags error! Available flags are T,F,B/S,U,P,L"); clear();YYABORT;}
		   else flags.set(TF);}  |
	      F   {if (flags[FF]) {llvmerror(&@1, "IALU/IFALU_Sel flags error! Available flags are T,F,B/S,U,P,L"); clear();YYABORT;}
		   else flags.set(FF);}  |
	      B   {if (flags[BF] || flags[SF]) {llvmerror(&@1, "IALU/IFALU_Sel flags error! Available flags are T,F,B/S,U,P,L"); clear();YYABORT;}
		   else flags.set(BF);}  |
              S   {if (flags[SF] || flags[BF]) {llvmerror(&@1, "IALU/IFALU_Sel flags error! Available flags are T,F,B/S,U,P,L"); clear();YYABORT;}
		   else flags.set(SF);}  |
              U   {if (flags[UF]) {llvmerror(&@1, "IALU/IFALU_Sel flags error! Available flags are T,F,B/S,U,P,L"); clear();YYABORT;}
		   else flags.set(UF);}  |
              P   {if (flags[PF]) {llvmerror(&@1, "IALU/IFALU_Sel flags error! Available flags are T,F,B/S,U,P,L"); clear();YYABORT;}
		   else flags.set(PF);}  |
              L   {if (flags[LF]) {llvmerror(&@1, "IALU/IFALU_Sel flags error! Available flags are T,F,B/S,U,P,L"); clear();YYABORT;}
		   else flags.set(LF);}  ;//niuxx
             
ialucompsel2flags: ialucompsel2flag | ialucompsel2flag COMMA ialucompsel2flags;//IALU.CompSel2 flags
ialucompsel2flag:  L   {if (flags[LF]) {llvmerror(&@1, "IALU/IFALU_Compsel flags error! Available flags are L,B/S,A"); clear();YYABORT;}
			else flags.set(LF);}  |
		   B   {if (flags[BF] || flags[SF]) {llvmerror(&@1, "IALU/IFALU_Compsel flags error! Available flags are L,B/S,A"); clear();YYABORT;}
			else flags.set(BF);}  |
		   S   {if (flags[SF] || flags[BF]) {llvmerror(&@1, "IALU/IFALU_Compsel flags error! Available flags are L,B/S,A"); clear();YYABORT;}
			else flags.set(SF);}  |
		   A   {if (flags[AF]) {llvmerror(&@1, "IALU/IFALU_Compsel flags error! Available flags are L,B/S,A"); clear();YYABORT;}
			else flags.set(AF);}  ;//niuxx
       
ialucompsel1flags: ialucompsel1flag | ialucompsel1flag COMMA ialucompsel1flags;//IALU.CompSel1 flags
ialucompsel1flag:  U   {if (flags[UF]) {llvmerror(&@1, "IALU/IFALU_CompSel flags error! Available flags are U,B/S,A"); clear();YYABORT;}
			else flags.set(UF);}  |
		   B   {if (flags[BF] || flags[SF]) {llvmerror(&@1, "IALU/IFALU_CompSel flags error! Available flags are U,B/S,A"); clear();YYABORT;}
			else flags.set(BF);}  |
		   S   {if (flags[SF] || flags[BF]) {llvmerror(&@1, "IALU/IFALU_CompSel flags error! Available flags are U,B/S,A"); clear();YYABORT;}
			else flags.set(SF);}  |
		   A   {if (flags[AF]) {llvmerror(&@1, "IALU/IFALU_CompSel flags error! Available flags are U,B/S,A"); clear();YYABORT;}
			else flags.set(AF);}  ;//niuxx
		   
ialucompsel0flags: ialucompsel0flag | ialucompsel0flag COMMA ialucompsel0flags;//IALU.CompSel0 flags
ialucompsel0flag:  B   {if (flags[BF] || flags[SF]) {llvmerror(&@1, "IALU/IFALU_CompSel flags error! Available flags are B/S,A,X,T"); clear();YYABORT;}
			else flags.set(BF);}  |
		   S   {if (flags[SF] || flags[BF]) {llvmerror(&@1, "IALU/IFALU_CompSel flags error! Available flags are B/S,A,X,T"); clear();YYABORT;}
			else flags.set(SF);}  |
		   A   {if (flags[AF]) {llvmerror(&@1, "IALU/IFALU_CompSel flags error! Available flags are B/S,A,X,T"); clear();YYABORT;}
			else flags.set(AF);}  |
		   X   {if (flags[XF]) {llvmerror(&@1, "IALU/IFALU_CompSel flags error! Available flags are B/S,A,X,T"); clear();YYABORT;}
			else flags.set(XF);}  |
		   T   {if (flags[TF]) {llvmerror(&@1, "IALU/IFALU_CompSel flags error! Available flags are B/S,A,X,T"); clear();YYABORT;}
			else flags.set(TF);}  ;//niuxx		   

//IALU.Count flags
//IALU.First flags
ialucfflags:B	{flags.set(BF);}|
	    S	{flags.set(SF);}|
	    N	{flags.set(NF);}|
	    B COMMA N	{flags.set(BF);flags.set(NF);}|
	    S COMMA N	{flags.set(SF);flags.set(NF);};//niuxx
		  
       
ialusignedflags: B   {flags.set(BF);}  |//IALU.SIGNED flags
		 S   {flags.set(SF);}  ;//niuxx


//IALU.MODADD flags
//IALU.MODSUB flags
//IALU.DivStart flags
//IALU.DivCont flags
//IALU.ReadR flags
//IALU.Expd flags
//IALU.Tm >> Imm5 flags
ialuubsflags:	U	{flags.set(UF);}|
		B	{flags.set(BF);}|
		S	{flags.set(SF);}|
		U COMMA B	{flags.set(UF);flags.set(BF);}|
		B COMMA U	{flags.set(UF);flags.set(BF);}|
		U COMMA S	{flags.set(UF);flags.set(SF);}|
		S COMMA U	{flags.set(UF);flags.set(SF);}; //niuxx
	             
ialureadqflags:ialureadqflag | ialureadqflag COMMA ialureadqflags;//IALU.ReadQ flags
ialureadqflag:U   {if (flags[UF]) {llvmerror(&@1, "IALU/IFALU_ReadQ flags error! Available flags are U,B/S,T,F"); clear();YYABORT;}
		   else flags.set(UF);}  |
              B   {if (flags[BF] || flags[SF]) {llvmerror(&@1, "IALU/IFALU_ReadQ flags error! Available flags are U,B/S,T,F"); clear();YYABORT;}
		   else flags.set(BF);}  |
              S   {if (flags[SF] || flags[BF]) {llvmerror(&@1, "IALU/IFALU_ReadQ flags error! Available flags are U,B/S,T,F"); clear();YYABORT;}
		   else flags.set(SF);}  |
              T   {if (flags[TF]) {llvmerror(&@1, "IALU/IFALU_ReadQ flags error! Available flags are U,B/S,T,F"); clear();YYABORT;}
		   else flags.set(TF);}  |
              F   {if (flags[FF]) {llvmerror(&@1, "IALU/IFALU_ReadQ flags error! Available flags are U,B/S,T,F"); clear();YYABORT;}
		   else flags.set(FF);}  ;//niuxx              

ialucprsflags:ialucprsflag | ialucprsflag COMMA ialucprsflags;//IALU.CPRS flags
ialucprsflag:U   {if (flags[UF]) {llvmerror(&@1, "IALU/IFALU_Cprs flags error! Available flags are U,S,T,F"); clear();YYABORT;}
		  else flags.set(UF);}  |
	     S   {if (flags[SF]) {llvmerror(&@1, "IALU/IFALU_Cprs flags error! Available flags are U,S,T,F"); clear();YYABORT;}
		  else flags.set(SF);}  |
	     T   {if (flags[TF]) {llvmerror(&@1, "IALU/IFALU_Cprs flags error! Available flags are U,S,T,F"); clear();YYABORT;}
		  else flags.set(TF);}  |
	     F   {if (flags[FF]) {llvmerror(&@1, "IALU/IFALU_Cprs flags error! Available flags are U,S,T,F"); clear();YYABORT;}
		  else flags.set(FF);}  ;//niuxx

ialursubflags:ialursubflag | ialursubflag COMMA ialursubflags;//IALU.RSub falgs
ialursubflag:  T   {if (flags[TF]) {llvmerror(&@1, "IALU/IFALU_Sub flags error! Available flags are T,F,B/S,U"); clear();YYABORT;}
		   else flags.set(TF);}  |
	      F   {if (flags[FF]) {llvmerror(&@1, "IALU/IFALU_Sub flags error! Available flags are T,F,B/S,U"); clear();YYABORT;}
		   else flags.set(FF);}  |
              B   {if (flags[BF] || flags[SF]) {llvmerror(&@1, "IALU/IFALU_Sub flags error! Available flags are T,F,B/S,U"); clear();YYABORT;}
		   else flags.set(BF);}  |
              S   {if (flags[SF] || flags[BF]) {llvmerror(&@1, "IALU/IFALU_Sub flags error! Available flags are T,F,B/S,U"); clear();YYABORT;}
		   else flags.set(SF);}  |	      
              U   {if (flags[UF]) {llvmerror(&@1, "IALU/IFALU_Sub flags error! Available flags are T,F,B/S,U"); clear();YYABORT;}
		   else flags.set(UF);}  ;//niuxx		  
		  
ialuraddflags:ialuraddflag | ialuraddflag COMMA ialuraddflags;//IALU.RAdd falgs
ialuraddflag:  T   {if (flags[TF]) {llvmerror(&@1, "IALU/IFALU_RAdd flags error! Available flags are T,F,B/S,U"); clear();YYABORT;}
		   else flags.set(TF);}  |
	      F   {if (flags[FF]) {llvmerror(&@1, "IALU/IFALU_RAdd flags error! Available flags are T,F,B/S,U"); clear();YYABORT;}
		   else flags.set(FF);}  |
              B   {if (flags[BF] || flags[SF]) {llvmerror(&@1, "IALU/IFALU_RAdd flags error! Available flags are T,F,B/S,U"); clear();YYABORT;}
		   else flags.set(BF);}  |
              S   {if (flags[SF] || flags[BF]) {llvmerror(&@1, "IALU/IFALU_RAdd flags error! Available flags are T,F,B/S,U"); clear();YYABORT;}
		   else flags.set(SF);}  |	      
              U   {if (flags[UF]) {llvmerror(&@1, "IALU/IFALU_RAdd flags error! Available flags are T,F,B/S,U"); clear();YYABORT;}
		   else flags.set(UF);}  ;//niuxx            
 
ialulshiflags:ialulshiflag | ialulshiflag COMMA ialulshiflags;//IALU.Tm << Imm3 flags
ialulshiflag: U   {if (flags[UF]) {llvmerror(&@1, "IALU/IFALU_LshiftI flags error! Available flags are U,B/S,T"); clear();YYABORT;}
		   else flags.set(UF);}  |
              B   {if (flags[BF] || flags[SF]) {llvmerror(&@1, "IALU/IFALU_LshiftI flags error! Available flags are U,B/S,T"); clear();YYABORT;}
		   else flags.set(BF);}  |
              S   {if (flags[SF] || flags[BF]) {llvmerror(&@1, "IALU/IFALU_LshiftI flags error! Available flags are U,B/S,T"); clear();YYABORT;}
		   else flags.set(SF);}  | 
	      T   {if (flags[TF]) {llvmerror(&@1, "IALU/IFALU_LshiftI flags error! Available flags are U,B/S,T"); clear();YYABORT;}
		   else flags.set(TF);}  ;//niuxx
 
ialurshflags:ialurshflag | ialurshflag COMMA ialurshflags;//IALU.Tm >> Tn flags
ialurshflag: B   {if (flags[BF] || flags[SF]) {llvmerror(&@1, "IALU/IFALU_Rshift flags error! Available flags are B/S,U,Round"); clear();YYABORT;}
		  else flags.set(BF);}  |
             S   {if (flags[SF] || flags[BF]) {llvmerror(&@1, "IALU/IFALU_Rshift flags error! Available flags are B/S,U,Round"); clear();YYABORT;}
		  else flags.set(SF);}  |
             U   {if (flags[UF]) {llvmerror(&@1, "IALU/IFALU_Rshift flags error! Available flags are B/S,U,Round"); clear();YYABORT;}
		  else flags.set(UF);}  |
             ROUND   {if (flags[ROUNDF]) {llvmerror(&@1, "IALU/IFALU_Rshift flags error! Available flags are B/S,U,Round"); clear();YYABORT;}
		      else flags.set(ROUNDF);}  ;//niuxx
 
ialulshflags:ialulshflag | ialulshflag COMMA ialulshflags;//IALU.Tm << Tn flags
ialulshflag: B   {if (flags[BF] || flags[SF]) {llvmerror(&@1, "IALU/IFALU_Lshift flags error! Available flags are B/S,U,T,Round"); clear();YYABORT;}
		  else flags.set(BF);}  |
             S   {if (flags[SF] || flags[BF]) {llvmerror(&@1, "IALU/IFALU_Lshift flags error! Available flags are B/S,U,T,Round"); clear();YYABORT;}
		  else flags.set(SF);}  |
             U   {if (flags[UF]) {llvmerror(&@1, "IALU/IFALU_Lshift flags error! Available flags are B/S,U,T,Round"); clear();YYABORT;}
		  else flags.set(UF);}  |
	     T   {if (flags[TF]) {llvmerror(&@1, "IALU/IFALU_Lshift flags error! Available flags are B/S,U,T,Round"); clear();YYABORT;}
		  else flags.set(TF);}  |
             ROUND   {if (flags[ROUNDF]) {llvmerror(&@1, "IALU/IFALU_Lshift flags error! Available flags are B/S,U,T,Round"); clear();YYABORT;}
		      else flags.set(ROUNDF);}  ;//niuxx

ialusubflags: ialusubflag | ialusubflag COMMA ialusubflags;//IALU sub flags
ialusubflag:	T   {if (flags[TF]) {llvmerror(&@1, "IALU/IFALU_Sub flags error! Available flags are T,CI,F,B/S,U"); clear();YYABORT;}
		     else  flags.set(TF);}  |
		CI  {if (flags[CIF]) {llvmerror(&@1, "IALU/IFALU_Sub flags error! Available flags are T,CI,F,B/S,U"); clear();YYABORT;}
		     else flags.set(CIF);} |
		F   {if (flags[FF]) {llvmerror(&@1, "IALU/IFALU_Sub flags error! Available flags are T,CI,F,B/S,U"); clear();YYABORT;}
		     else flags.set(FF);}  |
		B   {if (flags[BF] || flags[SF]) {llvmerror(&@1, "IALU/IFALU_Sub flags error! Available flags are T,CI,F,B/S,U"); clear();YYABORT;}
		     else flags.set(BF);}  |
		S   {if (flags[SF] || flags[BF]) {llvmerror(&@1, "IALU/IFALU_Sub flags error! Available flags are T,CI,F,B/S,U"); clear();YYABORT;}
		     else flags.set(SF);}  |
		U   {if (flags[UF]) {llvmerror(&@1, "IALU/IFALU_Sub flags error! Available flags are T,CI,F,B/S,U"); clear();YYABORT;}
		     else flags.set(UF);} ;//niuxx		      
		      
ialuaddflags: ialuaddflag | ialuaddflag COMMA ialuaddflags;//IALU add flags
ialuaddflag:	T   {if (flags[TF]) {llvmerror(&@1, "IALU/IFALU_Add flags error! Available flags are T,CI,F,B/S,U"); clear();YYABORT;}
		     else  flags.set(TF);}  |
		CI  {if (flags[CIF]) {llvmerror(&@1, "IALU/IFALU_Add flags error! Available flags are T,CI,F,B/S,U"); clear();YYABORT;}
		     else flags.set(CIF);} |
		F   {if (flags[FF]) {llvmerror(&@1, "IALU/IFALU_Add flags error! Available flags are T,CI,F,B/S,U"); clear();YYABORT;}
		     else flags.set(FF);}  |
		B   {if (flags[BF] || flags[SF]) {llvmerror(&@1, "IALU/IFALU_Add flags error! Available flags are T,CI,F,B/S,U"); clear();YYABORT;}
		     else flags.set(BF);}  |
		S   {if (flags[SF] || flags[BF]) {llvmerror(&@1, "IALU/IFALU_Add flags error! Available flags are T,CI,F,B/S,U"); clear();YYABORT;}
		     else flags.set(SF);}  |
		U   {if (flags[UF]) {llvmerror(&@1, "IALU/IFALU_Add flags error! Available flags are T,CI,F,B/S,U"); clear();YYABORT;}
		     else flags.set(UF);} ;//niuxx
 
ialulogicflags: B   {flags.set(BF);}  |//IALU & | ^ flags
		S   {flags.set(SF);}  |
		N   {flags.set(NF);};//niuxx

ialuequflags:    ialuequflag | ialuequflag COMMA ialuequflags;//IALU == flags
ialuequflag:     B   {if (flags[BF] || flags[SF]) {llvmerror(&@1, "IALU/IFALU_Equ flags error! Available flags are B/S,F,N"); clear();YYABORT;}
		      else flags.set(BF);}  |
		 S   {if (flags[SF] || flags[BF]) {llvmerror(&@1, "IALU/IFALU_Equ flags error! Available flags are B/S,F,N"); clear();YYABORT;}
		      else flags.set(SF);}  |
		 F   {if (flags[FF]) {llvmerror(&@1, "IALU/IFALU_Equ flags error! Available flags are B/S,F,N"); clear();YYABORT;}
		      else flags.set(FF);}  |		  
		 N   {if (flags[NF]) {llvmerror(&@1, "IALU/IFALU_Equ flags error! Available flags are B/S,F,N"); clear();YYABORT;}
		      else flags.set(NF);};//niuxx		
             
ialushiftflags: ialushiftflag | ialushiftflag COMMA ialushiftflags;
ialushiftflag:    T   {flags.set(TF);}  |
		  F   {flags.set(FF);}  |
		  B   {flags.set(BF);}  |
		  S   {flags.set(SF);}  |
		  U   {flags.set(UF);}  ;
             
//yangl: for imac r/w flags     

imacwriteflag_flags: imacwriteflag_flag | imacwriteflag_flag COMMA imacwriteflag_flags;//IMAC WriteFlag flags 
imacwriteflag_flag: N      {if (flags[NF]) {llvmerror(&@1, "IMAC/IFMAC_WriteFLAG flags error! Available flags are ( N/C/V/(N,C,V),Erased )/(MC,MV)/(T,LS)"); clear();YYABORT;}
			   else flags.set(NF);}     |
                   CFLAG  {if (flags[CF]) {llvmerror(&@1, "IMAC/IFMAC_WriteFLAG flags error! Available flags are ( N/C/V/(N,C,V),Erased )/(MC,MV)/(T,LS)"); clear();YYABORT;}
			   else flags.set(CF);}     |
                   V      {if (flags[VF]) {llvmerror(&@1, "IMAC/IFMAC_WriteFLAG flags error! Available flags are ( N/C/V/(N,C,V),Erased )/(MC,MV)/(T,LS)"); clear();YYABORT;}
			   else flags.set(VF);}     |
                   MC     {if (flags[MCF]) {llvmerror(&@1, "IMAC/IFMAC_WriteFLAG flags error! Available flags are ( N/C/V/(N,C,V),Erased )/(MC,MV)/(T,LS)"); clear();YYABORT;}
			   else flags.set(MCF);}    |
                   MV     {if (flags[MVF]) {llvmerror(&@1, "IMAC/IFMAC_WriteFLAG flags error! Available flags are ( N/C/V/(N,C,V),Erased )/(MC,MV)/(T,LS)"); clear();YYABORT;}
			   else flags.set(MVF);}    |
                   T      {if (flags[TF]) {llvmerror(&@1, "IMAC/IFMAC_WriteFLAG flags error! Available flags are ( N/C/V/(N,C,V),Erased )/(MC,MV)/(T,LS)"); clear();YYABORT;}
			   else flags.set(TF);}     |
                   LS     {if (flags[LSF]) {llvmerror(&@1, "IMAC/IFMAC_WriteFLAG flags error! Available flags are ( N/C/V/(N,C,V),Erased )/(MC,MV)/(T,LS)"); clear();YYABORT;}
			   else flags.set(LSF);}    |
                   ERASE  {if (flags[ERASEF]) {llvmerror(&@1, "IMAC/IFMAC_WriteFLAG flags error! Available flags are ( N/C/V/(N,C,V),Erased )/(MC,MV)/(T,LS)"); clear();YYABORT;}
			   else flags.set(ERASEF);} ;//niuxx
			   
imacreadflag_flags: imacreadflag_flag | imacreadflag_flag COMMA imacreadflag_flags;//IMAC ReadFlag flags 
imacreadflag_flag: N      {if (flags[NF]) {llvmerror(&@1, "IMAC/IFMAC_ReadFLAG flags error! Available flags are ( N/C/V/(N,C,V),Erased )/(MC,MV)/(T,LS)"); clear();YYABORT;}
			   else flags.set(NF);}     |
                   CFLAG  {if (flags[CF]) {llvmerror(&@1, "IMAC/IFMAC_ReadFLAG flags error! Available flags are ( N/C/V/(N,C,V),Erased )/(MC,MV)/(T,LS)"); clear();YYABORT;}
			   else flags.set(CF);}     |
                   V      {if (flags[VF]) {llvmerror(&@1, "IMAC/IFMAC_ReadFLAG flags error! Available flags are ( N/C/V/(N,C,V),Erased )/(MC,MV)/(T,LS)"); clear();YYABORT;}
			   else flags.set(VF);}     |
                   MC     {if (flags[MCF]) {llvmerror(&@1, "IMAC/IFMAC_ReadFLAG flags error! Available flags are ( N/C/V/(N,C,V),Erased )/(MC,MV)/(T,LS)"); clear();YYABORT;}
			   else flags.set(MCF);}    |
                   MV     {if (flags[MVF]) {llvmerror(&@1, "IMAC/IFMAC_ReadFLAG flags error! Available flags are ( N/C/V/(N,C,V),Erased )/(MC,MV)/(T,LS)"); clear();YYABORT;}
			   else flags.set(MVF);}    |
                   T      {if (flags[TF]) {llvmerror(&@1, "IMAC/IFMAC_ReadFLAG flags error! Available flags are ( N/C/V/(N,C,V),Erased )/(MC,MV)/(T,LS)"); clear();YYABORT;}
			   else flags.set(TF);}     |
                   LS     {if (flags[LSF]) {llvmerror(&@1, "IMAC/IFMAC_ReadFLAG flags error! Available flags are ( N/C/V/(N,C,V),Erased )/(MC,MV)/(T,LS)"); clear();YYABORT;}
			   else flags.set(LSF);}    |
                   ERASE  {if (flags[ERASEF]) {llvmerror(&@1, "IMAC/IFMAC_ReadFLAG flags error! Available flags are ( N/C/V/(N,C,V),Erased )/(MC,MV)/(T,LS)"); clear();YYABORT;}
			   else flags.set(ERASEF);} ;//niuxx			

ialusendflags: ialusendflag | ialusendflag COMMA ialusendflags;
ialusendflag:   U   {flags.set(UF);}  |
		N   {flags.set(NF);}  |
		CFLAG   {flags.set(CF);}  |
		V   {flags.set(VF);}  |
		A   {flags.set(AF);}  |
		ERASE {flags.set(ERASEF);} |
		L   {flags.set(LF);}  |
		CR  {flags.set(CRF);} ;

//IALU.WriteFlag flags		       
ialuwriteflagflags:A	{flags.set(AF);}|
		   A COMMA ERASE	{flags.set(AF);flags.set(ERASEF);}|
		   ERASE COMMA A	{flags.set(AF);flags.set(ERASEF);}|
		   ialuflagflags;//niuxx 
//IALU.Flag flags		       
ialuflagflags:U	{flags.set(UF);}|
	      N	{flags.set(NF);}|
	      CFLAG	{flags.set(CF);}|
	      V	{flags.set(VF);}|
	      ERASE	{flags.set(ERASEF);}|
	      U COMMA ERASE	{flags.set(UF);flags.set(ERASEF);}|
	      ERASE COMMA U	{flags.set(UF);flags.set(ERASEF);}|
	      N COMMA ERASE	{flags.set(NF);flags.set(ERASEF);}|
	      ERASE COMMA N	{flags.set(NF);flags.set(ERASEF);}|
	      CFLAG COMMA ERASE	{flags.set(CF);flags.set(ERASEF);}|
	      ERASE COMMA CFLAG	{flags.set(CF);flags.set(ERASEF);}|
	      V COMMA ERASE	{flags.set(VF);flags.set(ERASEF);}|
	      ERASE COMMA V	{flags.set(VF);flags.set(ERASEF);};//niuxx
		       
imachlflag:    HH   {flags.set(HHF);}  |
               LL   {flags.set(LLF);}  |
               HL   {flags.set(HLF);}  ;

imacrealflag:  B   {flags.set(BF);}  |
               S   {flags.set(SF);}  ;
imaccompflag:  R   {flags.set(RF);}  |
               I   {flags.set(IF);}  ;

//IMAC/IFMAC Tp +- Tm * Tn               
imacflags: imacflagpart2 | imacflagpart2 COMMA imacflags ;
imacflagpart2: U   {if (flags[UF]) {llvmerror(&@1, "IMAC/IFMAC_Add/Sub_Mul flags error! Available flags are U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}
		    else flags.set(UF);}  |
               L   {if (flags[LF]) {llvmerror(&@1, "IMAC/IFMAC_Add/Sub_Mul flags error! Available flags are U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}
		    else flags.set(LF);}  |
               P   {if (flags[PF]) {llvmerror(&@1, "IMAC/IFMAC_Add/Sub_Mul flags error! Available flags are U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}
		    else flags.set(PF);}  |
               T   {if (flags[TF]) {llvmerror(&@1, "IMAC/IFMAC_Add/Sub_Mul flags error! Available flags are U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}
		    else flags.set(TF);}  |
               F   {if (flags[FF]) {llvmerror(&@1, "IMAC/IFMAC_Add/Sub_Mul flags error! Available flags are U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}
		    else flags.set(FF);}  |
               CFLAG         {if (flags[CF] || flags[SENDF]) {llvmerror(&@1, "IMAC/IFMAC_Add/Sub_Mul flags error! Available flags are U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}
			      else flags.set(CF);}  |
               SEND          {if (flags[SENDF] || flags[CF]) {llvmerror(&@1, "IMAC/IFMAC_Add/Sub_Mul flags error! Available flags are U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}
			      flags.set(SENDF);}  |
               SHIFTMODE0    {if (flags[S0F]) {llvmerror(&@1, "IMAC/IFMAC_Add/Sub_Mul flags error! Available flags are U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}
			      else flags.set(S0F);}    |
               SHIFTMODE1    {if (flags[S1F]) {llvmerror(&@1, "IMAC/IFMAC_Add/Sub_Mul flags error! Available flags are U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}
			      else flags.set(S1F);}    |
               SHIFTMODE2    {if (flags[S2F]) {llvmerror(&@1, "IMAC/IFMAC_Add/Sub_Mul flags error! Available flags are U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}
			      else flags.set(S2F);}    |
               SHIFTMODE3    {if (flags[S3F]) {llvmerror(&@1, "IMAC/IFMAC_Add/Sub_Mul flags error! Available flags are U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}
			      else flags.set(S3F);}    |
               X   {if (flags[XF]) {llvmerror(&@1, "IMAC/IFMAC_Add/Sub_Mul flags error! Available flags are U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}
		    else flags.set(XF);}  |
               A   {if (flags[AF]) {llvmerror(&@1, "IMAC/IFMAC_Add/Sub_Mul flags error! Available flags are U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}
		    else flags.set(AF);} ;//niuxx

//IMAC/IFMAC MR +=/-= Tm * Tn               
imacmrasmflags: imacmrasmflag | imacmrasmflag COMMA imacmrasmflags;
imacmrasmflag: CR  {if (flags[CRF]) {llvmerror(&@1, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}
		    else flags.set(CRF);} |
               U   {if (flags[UF]) {llvmerror(&@1, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}
		    else flags.set(UF);}  |
               L   {if (flags[LF]) {llvmerror(&@1, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}
		    else flags.set(LF);}  |
               P   {if (flags[PF]) {llvmerror(&@1, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}
		    else flags.set(PF);}  |
               T   {if (flags[TF]) {llvmerror(&@1, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}
		    else flags.set(TF);}  |
               F   {if (flags[FF]) {llvmerror(&@1, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}
		    else flags.set(FF);}  |
               CFLAG         {if (flags[CF] || flags[SENDF]) {llvmerror(&@1, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}
			      else flags.set(CF);}  |
               SEND          {if (flags[SENDF] || flags[CF]) {llvmerror(&@1, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}
			      flags.set(SENDF);}  |
               SHIFTMODE0    {if (flags[S0F]) {llvmerror(&@1, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}
			      else flags.set(S0F);}    |
               SHIFTMODE1    {if (flags[S1F]) {llvmerror(&@1, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}
			      else flags.set(S1F);}    |
               SHIFTMODE2    {if (flags[S2F]) {llvmerror(&@1, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}
			      else flags.set(S2F);}    |
               SHIFTMODE3    {if (flags[S3F]) {llvmerror(&@1, "IMAC/IFMAC_MR_Mul flags error! Available flags are CR,U,L,P,T,F,C/Send,ShiftMode0/1/2/3"); clear();YYABORT;}
			      else flags.set(S3F);}    ;//niuxx

imacmulavmrflags:imacmulavmrflag | imacmulavmrflag COMMA imacmulavmrflags;//IMAC.MR+=Tm*V(Tl[k])+Tn*VPLUS flags
imacmulavmrflag: L   {if (flags[LF]) {llvmerror(&@1, "IMAC/IFMAC_MR_VVPLUS flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
		      else flags.set(LF);}  |
		 P   {if (flags[PF]) {llvmerror(&@1, "IMAC/IFMAC_MR_VVPLUS flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
		      else flags.set(PF);}  |
		 T   {if (flags[TF]) {llvmerror(&@1, "IMAC/IFMAC_MR_VVPLUS flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
		      else flags.set(TF);}  |
		 F   {if (flags[FF]) {llvmerror(&@1, "IMAC/IFMAC_MR_VVPLUS flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
		      else flags.set(FF);}  |
		 SHIFTMODE0    {if (flags[S0F]) {llvmerror(&@1, "IMAC/IFMAC_MR_VVPLUS flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
				else flags.set(S0F);}    |
		 SHIFTMODE1    {if (flags[S1F]) {llvmerror(&@1, "IMAC/IFMAC_MR_VVPLUS flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
				else flags.set(S1F);}    |
		 SHIFTMODE2    {if (flags[S2F]) {llvmerror(&@1, "IMAC/IFMAC_MR_VVPLUS flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
				else flags.set(S2F);}    |
		 SHIFTMODE3    {if (flags[S3F]) {llvmerror(&@1, "IMAC/IFMAC_MR_VVPLUS flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
				else flags.set(S3F);}    ;//niuxx			      
               
imacmulavflags:imacmulavflag | imacmulavflag COMMA imacmulavflags;//IMAC.Tp+Tm*V(Tl[k])+Tn*VPLUS flags
imacmulavflag: 	 L   {if (flags[LF]) {llvmerror(&@1, "IMAC/IFMAC_Mul_VVPLUS flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
		      else flags.set(LF);}  |
		 P   {if (flags[PF]) {llvmerror(&@1, "IMAC/IFMAC_Mul_VVPLUS flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
		      else flags.set(PF);}  |
		 T   {if (flags[TF]) {llvmerror(&@1, "IMAC/IFMAC_Mul_VVPLUS flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
		      else flags.set(TF);}  |
		 F   {if (flags[FF]) {llvmerror(&@1, "IMAC/IFMAC_Mul_VVPLUS flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
		      else flags.set(FF);}  |
		 SHIFTMODE0    {if (flags[S0F]) {llvmerror(&@1, "IMAC/IFMAC_Mul_VVPLUS flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
				else flags.set(S0F);}    |
		 SHIFTMODE1    {if (flags[S1F]) {llvmerror(&@1, "IMAC/IFMAC_Mul_VVPLUS flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
				else flags.set(S1F);}    |
		 SHIFTMODE2    {if (flags[S2F]) {llvmerror(&@1, "IMAC/IFMAC_Mul_VVPLUS flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
				else flags.set(S2F);}    |
		 SHIFTMODE3    {if (flags[S3F]) {llvmerror(&@1, "IMAC/IFMAC_Mul_VVPLUS flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
				else flags.set(S3F);}    ;//niuxx
               
imacasflags: imacasflag | imacasflag COMMA imacasflags;//  Tp AS Tm* Tn flags
imacasflag: L   	{if (flags[LF]) {llvmerror(&@1, "IMAC/IFMAC_AS flags error! Available flags are L,P,T,C,X,ShiftMode0/1/2/3"); clear();YYABORT;}
			  else flags.set(LF);}  |
	    P   	{if (flags[PF]) {llvmerror(&@1, "IMAC/IFMAC_AS flags error! Available flags are L,P,T,C,X,ShiftMode0/1/2/3"); clear();YYABORT;}
			 else flags.set(PF);}  |
	    T   	{if (flags[TF]) {llvmerror(&@1, "IMAC/IFMAC_AS flags error! Available flags are L,P,T,C,X,ShiftMode0/1/2/3"); clear();YYABORT;}
			 else flags.set(TF);}  |
	    CFLAG       {if (flags[CF]) {llvmerror(&@1, "IMAC/IFMAC_AS flags error! Available flags are L,P,T,C,X,ShiftMode0/1/2/3"); clear();YYABORT;}
			 else flags.set(CF);}  |
	    X   	{if (flags[XF]) {llvmerror(&@1, "IMAC/IFMAC_AS flags error! Available flags are L,P,T,C,X,ShiftMode0/1/2/3"); clear();YYABORT;}
			 else flags.set(XF);}  |
	    SHIFTMODE0    {if (flags[S0F]) {llvmerror(&@1, "IMAC/IFMAC_AS flags error! Available flags are L,P,T,C,X,ShiftMode0/1/2/3"); clear();YYABORT;}
			   else flags.set(S0F);}    |
            SHIFTMODE1    {if (flags[S1F]) {llvmerror(&@1, "IMAC/IFMAC_AS flags error! Available flags are L,P,T,C,X,ShiftMode0/1/2/3"); clear();YYABORT;}
			   else flags.set(S1F);}    |
            SHIFTMODE2    {if (flags[S2F]) {llvmerror(&@1, "IMAC/IFMAC_AS flags error! Available flags are L,P,T,C,X,ShiftMode0/1/2/3"); clear();YYABORT;}
			   else flags.set(S2F);}    |
            SHIFTMODE3    {if (flags[S3F]) {llvmerror(&@1, "IMAC/IFMAC_AS flags error! Available flags are L,P,T,C,X,ShiftMode0/1/2/3"); clear();YYABORT;}
			   else flags.set(S3F);}    ;//niuxx
                              
imacmul7flags:imacmul7flag | imacmul7flag COMMA imacmul7flags;//MR+-Tm*V(Tn[k])
imacmul7flag: 	   P   		 {if (flags[PF]) {llvmerror(&@1, "IMAC/IFMAC_MR_MulAV flags error! Available flags are P,C,ShiftMode0/1/2/3"); clear();YYABORT;}
				  else flags.set(PF);}     |
		   CFLAG         {if (flags[CF]) {llvmerror(&@1, "IMAC/IFMAC_MR_MulAV flags error! Available flags are P,C,ShiftMode0/1/2/3"); clear();YYABORT;}
				  else flags.set(CF);}     |
		   SHIFTMODE0    {if (flags[S0F]) {llvmerror(&@1, "IMAC/IFMAC_MR_MulAV flags error! Available flags are P,C,ShiftMode0/1/2/3"); clear();YYABORT;}
				  else flags.set(S0F);}    |
		   SHIFTMODE1    {if (flags[S1F]) {llvmerror(&@1, "IMAC/IFMAC_MR_MulAV flags error! Available flags are P,C,ShiftMode0/1/2/3"); clear();YYABORT;}
				  else flags.set(S1F);}    |
		   SHIFTMODE2    {if (flags[S2F]) {llvmerror(&@1, "IMAC/IFMAC_MR_MulAV flags error! Available flags are P,C,ShiftMode0/1/2/3"); clear();YYABORT;}
				  else flags.set(S2F);}    |
		   SHIFTMODE3    {if (flags[S3F]) {llvmerror(&@1, "IMAC/IFMAC_MR_MulAV flags error! Available flags are P,C,ShiftMode0/1/2/3"); clear();YYABORT;}
				  else flags.set(S3F);}    ;//niuxx
                             
imacmul5_mul6flags:imacmul5_mul6flag | imacmul5_mul6flag COMMA imacmul5_mul6flags;//Tp+-Tm*V(Tn[k]);0+-Tm*V(Tn[k]) flags
imacmul5_mul6flag: P   		 {if (flags[PF]) {llvmerror(&@1, "IMAC/IFMAC_MulAV flags error! Available flags are P,C,ShiftMode0/1/2/3"); clear();YYABORT;}
				  else flags.set(PF);}     |
		   CFLAG         {if (flags[CF]) {llvmerror(&@1, "IMAC/IFMAC_MulAV flags error! Available flags are P,C,ShiftMode0/1/2/3"); clear();YYABORT;}
				  else flags.set(CF);}     |
		   SHIFTMODE0    {if (flags[S0F]) {llvmerror(&@1, "IMAC/IFMAC_MulAV flags error! Available flags are P,C,ShiftMode0/1/2/3"); clear();YYABORT;}
				  else flags.set(S0F);}    |
		   SHIFTMODE1    {if (flags[S1F]) {llvmerror(&@1, "IMAC/IFMAC_MulAV flags error! Available flags are P,C,ShiftMode0/1/2/3"); clear();YYABORT;}
				  else flags.set(S1F);}    |
		   SHIFTMODE2    {if (flags[S2F]) {llvmerror(&@1, "IMAC/IFMAC_MulAV flags error! Available flags are P,C,ShiftMode0/1/2/3"); clear();YYABORT;}
				  else flags.set(S2F);}    |
		   SHIFTMODE3    {if (flags[S3F]) {llvmerror(&@1, "IMAC/IFMAC_MulAV flags error! Available flags are P,C,ShiftMode0/1/2/3"); clear();YYABORT;}
				  else flags.set(S3F);}    ;//niuxx
		     
// IMAC.Tp (B|S){({L},{A})->MR flags
// IMAC.Sel(Tp,MR)(B|S)('HH|HL|LL'){({L},{A})->
imacsendmr_selflags:L   {flags.set(LF);} |
		    A   {flags.set(AF);} |
		    L COMMA A  {flags.set(LF); flags.set(AF);} |
		    A COMMA L  {flags.set(LF); flags.set(AF);} ;//niuxx	
               
imacmulaamrflags:imacmulaamrflag | imacmulaamrflag COMMA imacmulaamrflags;//MR '+=|-='Tm*Tm+1+-Tn*Tn-1 flags
imacmulaamrflag: L   {if (flags[LF]) {llvmerror(&@1, "IMAC/IFMAC_MR_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
		      else flags.set(LF);}  |  
		 P   {if (flags[PF]) {llvmerror(&@1, "IMAC/IFMAC_MR_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
		      else flags.set(PF);}  |
                 T   {if (flags[TF]) {llvmerror(&@1, "IMAC/IFMAC_MR_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
		      else flags.set(TF);}  |
                 F   {if (flags[FF]) {llvmerror(&@1, "IMAC/IFMAC_MR_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
		      else flags.set(FF);}  |
                 SHIFTMODE0    {if (flags[S0F]) {llvmerror(&@1, "IMAC/IFMAC_MR_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
				else flags.set(S0F);}    |
                 SHIFTMODE1    {if (flags[S1F]) {llvmerror(&@1, "IMAC/IFMAC_MR_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
				else flags.set(S1F);}    |
                 SHIFTMODE2    {if (flags[S2F]) {llvmerror(&@1, "IMAC/IFMAC_MR_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
				else flags.set(S2F);}    |
                 SHIFTMODE3    {if (flags[S3F]) {llvmerror(&@1, "IMAC/IFMAC_MR_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
				else flags.set(S3F);}    ;//niuxx
               
imacmulaamr_flags:imacmulaamr_flag | imacmulaamr_flag COMMA imacmulaamr_flags;//MR '+=|-='Tm*Tm+1+-Tn*Tn-1 inside flags
imacmulaamr_flag:P   {if (flags[PF]) {llvmerror(&@1, "IMAC/IFMAC_MR_MulAA flags error! Available flags are P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
		      else flags.set(PF);}  |
                 T   {if (flags[TF]) {llvmerror(&@1, "IMAC/IFMAC_MR_MulAA flags error! Available flags are P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
		      else flags.set(TF);}  |
                 F   {if (flags[FF]) {llvmerror(&@1, "IMAC/IFMAC_MR_MulAA flags error! Available flags are P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
		      else flags.set(FF);}  |
                 SHIFTMODE0    {if (flags[S0F]) {llvmerror(&@1, "IMAC/IFMAC_MR_MulAA flags error! Available flags are P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
				else flags.set(S0F);}    |
                 SHIFTMODE1    {if (flags[S1F]) {llvmerror(&@1, "IMAC/IFMAC_MR_MulAA flags error! Available flags are P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
				else flags.set(S1F);}    |
                 SHIFTMODE2    {if (flags[S2F]) {llvmerror(&@1, "IMAC/IFMAC_MR_MulAA flags error! Available flags are P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
				else flags.set(S2F);}    |
                 SHIFTMODE3    {if (flags[S3F]) {llvmerror(&@1, "IMAC/IFMAC_MR_MulAA flags error! Available flags are P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
				else flags.set(S3F);}    ;//niuxx
               
imacmulaaflags:imacmulaaflag | imacmulaaflag COMMA imacmulaaflags;//Tp+|-Tm* Tm+1+|-Tn*Tn-1 ; 0+|-Tm* Tm+1+|-Tn*Tn-1 flags
imacmulaaflag:  L   {if (flags[LF]) {llvmerror(&@1, "IMAC/IFMAC_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
		     else flags.set(LF);}  |		     
		P   {if (flags[PF]) {llvmerror(&@1, "IMAC/IFMAC_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
		     else flags.set(PF);}  |
                T   {if (flags[TF]) {llvmerror(&@1, "IMAC/IFMAC_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
		     else flags.set(TF);}  |
                F   {if (flags[FF]) {llvmerror(&@1, "IMAC/IFMAC_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
		     else flags.set(FF);}  |
                SHIFTMODE0    {if (flags[S0F]) {llvmerror(&@1, "IMAC/IFMAC_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
			       else flags.set(S0F);}    |
                SHIFTMODE1    {if (flags[S1F]) {llvmerror(&@1, "IMAC/IFMAC_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
			       else flags.set(S1F);}    |
                SHIFTMODE2    {if (flags[S2F]) {llvmerror(&@1, "IMAC/IFMAC_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
			       else flags.set(S2F);}    |
                SHIFTMODE3    {if (flags[S3F]) {llvmerror(&@1, "IMAC/IFMAC_MulAA flags error! Available flags are L,P,T,F,ShiftMode0/1/2/3"); clear();YYABORT;}
			       else flags.set(S3F);}    ;//niuxx
//ducx
ifmacTflag:    T       {flags.set(TF);};

biuloadflags: biuloadflag | biuloadflag COMMA biuloadflags;
biuloadflag:BR	{if (flags[BRF]) {llvmerror(&@1, "BIULoad flags error! Available flags are A++,M,BR"); clear();YYABORT;}
		 else flags.set(BRF);}   |	       
	    M	{if (flags[MF]) {llvmerror(&@1, "BIULoad flags error! Available flags are A++,M,BR"); clear();YYABORT;}
		 else flags.set(MF);}    |
	    APP	{if (flags[APPF]) {llvmerror(&@1, "BIULoad flags error! Available flags are A++,M,BR"); clear();YYABORT;}
		 else flags.set(APPF);}  ;

biuflags: biuflag | biuflag COMMA biuflags;
biuflag:  BR	{if (flags[BRF]) {llvmerror(&@1, "BIUStore flags error! Available flags are A++,M,BR"); clear();YYABORT;}
		 else flags.set(BRF);}   |	       
          M	{if (flags[MF]) {llvmerror(&@1, "BIUStore flags error! Available flags are A++,M,BR"); clear();YYABORT;}
		 else flags.set(MF);}    |
          APP	{if (flags[APPF]) {llvmerror(&@1, "BIUStore flags error! Available flags are A++,M,BR"); clear();YYABORT;}
		 else flags.set(APPF);} ; 
               
biurflag:      R  {flags.set(RF);};  

lddisflag:    QL {flags.set(QLF);}    | 
              QH {flags.set(QHF);}    |
              L  {flags.set(LF);}     |
              R  {flags.set(RF);} ;
               
//ldstepflag :   S {flags.set(SF);}      ;
storerflag:    R {flags.set(RF);};//niuxx

storeflag:    H {flags.set(HF);}      |
              Q {flags.set(QF);}      |
              L {flags.set(LF);}      |
              R {flags.set(RF);}      ;

biuImmflag:   L {flags.set(LF);}    |	      
              ML {flags.set(MLF);}  |
              MH {flags.set(MHF);}  |
              H {flags.set(HF);}    ;
               
biuImm1flag:  L {flags.set(dLF);}     |
              ML {flags.set(dMLF);}   |
              MH {flags.set(dMHF);}   |
              H {flags.set(dHF);}     ;
 
biuImm2_flag:B {flags.set(BF);}     |
             S {flags.set(SF);}     ; 
 
biuImm2flag: B {flags.set(BF);}     |
             S {flags.set(SF);}     |
             U {flags.set(UF);}     ;

biumaskflags:  B {flags.set(BF);}     | //BIUMaskGen
               S {flags.set(SF);}     |
               B COMMA H {flags.set(BF); flags.set(HF);} |
               H COMMA B {flags.set(BF); flags.set(HF);} ;//niuxx		 
		 
//huhh:SHU Flags
/*shuflag :  B {flags.set(BF);}      |
           S {flags.set(SF);}     ;*/
shuflags: shuflag | shuflag COMMA shuflags;
shuflag:     T   {flags.set(TF);}  |             
             F   {flags.set(FF);}  |
             B   {flags.set(BF);}  |
             S   {flags.set(SF);}  |
             U   {flags.set(UF);}  |
           ODD   {flags.set(ODDF);}|
             H   {flags.set(HF);}  |
             R   {flags.set(RF);}  |
             Z   {flags.set(ZF);}  |
             O   {flags.set(OF);}  |
             E   {flags.set(EF);}  ;
             
shubitflags:shubitflag | shubitflag COMMA shubitflags;//SHUx.Bit flags
shubitflag:B   {if (flags[BF] || flags[SF]) {llvmerror(&@1, "SHUx.Bit flags error! Available flags are B/S,T/F"); clear();YYABORT;}
		else flags.set(BF);}  |
	   S   {if (flags[SF] || flags[BF]) {llvmerror(&@1, "SHUx.Bit flags error! Available flags are B/S,T/F"); clear();YYABORT;}
		else flags.set(SF);}  |
	   T   {if (flags[TF] || flags[FF]) {llvmerror(&@1, "SHUx.Bit flags error! Available flags are B/S,T/F"); clear();YYABORT;}
		else flags.set(TF);}  |             
	   F   {if (flags[FF] || flags[TF]) {llvmerror(&@1, "SHUx.Bit flags error! Available flags are B/S,T/F"); clear();YYABORT;}
		else flags.set(FF);}  ;//niuxx

  
shubyteflags:  shubyteflag | shubyteflag COMMA shubyteflags;//SHUx.Byte flags 
shubyteflag: U   {if (flags[UF]) {llvmerror(&@1, "SHUx.Byte falgs error, available flags are U,B/S,T/F"); clear();YYABORT;}
		  else flags.set(UF);} |
	     B   {if (flags[BF] || flags[SF]) {llvmerror(&@1, "SHUx.Byte flags error, available flags are U,B/S,T/F"); clear();YYABORT;}
		  else flags.set(BF);} |
	     S   {if (flags[SF] || flags[BF]) {llvmerror(&@1, "SHUx.Byte flags error, available flags are U,B/S,T/F"); clear();YYABORT;}
		  else flags.set(SF);} |
	     T   {if (flags[TF] || flags[FF]) {llvmerror(&@1, "SHUx.Byte flags error, available flags are U,B/S,T/F"); clear();YYABORT;}
		  else flags.set(TF);} |             
	     F   {if (flags[FF] || flags[TF]) {llvmerror(&@1, "SHUx.Byte flags error, available flags are U,B/S,T/F"); clear();YYABORT;}
		  else flags.set(FF);}  ;//niuxx
	      
shustepextflags:shustepextflag | shustepextflag COMMA shustepextflags;//SHUx.StepExt flags
shustepextflag:ODD  {if (flags[ODDF]) {llvmerror(&@1, "SHUx.StepExt flags error! Available flags are Odd,T/F/E"); clear();YYABORT;}
		     else flags.set(ODDF);}|
		T   {if (flags[TF] || flags[FF] || flags[EF]) {llvmerror(&@1, "SHUx.StepExt flags error! Available flags are Odd,T/F/E"); clear();YYABORT;}
		     else flags.set(TF);}  |  
		F   {if (flags[FF] || flags[TF] || flags[EF]) {llvmerror(&@1, "SHUx.StepExt flags error! Available flags are Odd,T/F/E"); clear();YYABORT;}
		     else flags.set(FF);}  |
		E   {if (flags[EF] || flags[TF] || flags[FF]) {llvmerror(&@1, "SHUx.StepExt flags error! Available flags are Odd,T/F/E"); clear();YYABORT;}
		     else flags.set(EF);}  ;//niuxx
		
shurestepextflags:shurestepextflag | shurestepextflag COMMA shurestepextflags;//SHUx.ReStepExt flags	
shurestepextflag: H   {if (flags[HF]) {llvmerror(&@1, "SHUx.ReStepExt flags error! Available flags are H,T/F/E"); clear();YYABORT;}
		       else flags.set(HF);}  |
		  T   {if (flags[TF] || flags[FF] || flags[EF]) {llvmerror(&@1, "SHUx.ReStepExt flags error! Available flags are H,T/F/E"); clear();YYABORT;}
		       else flags.set(TF);}  |  
		  F   {if (flags[FF] || flags[TF] || flags[EF]) {llvmerror(&@1, "SHUx.ReStepExt flags error! Available flags are H,T/F/E"); clear();YYABORT;}
		       else flags.set(FF);}  |
		  E   {if (flags[EF] || flags[TF] || flags[FF]) {llvmerror(&@1, "SHUx.ReStepExt flags error! Available flags are H,T/F/E"); clear();YYABORT;}
		       else flags.set(EF);}  ;//niuxx

//SHUx.shift falgs		   
shushiftflags:R	{flags.set(RF);}|
	      O {flags.set(OF);}|
	      R COMMA O	{flags.set(RF);flags.set(OF);};//niuxx
		   
  
shuimmtbflags:	O   {flags.set(OF);}  |//SHUx.Imm8 to Tn by TB|Imm7 flags
		T   {flags.set(TF);}  |             
		F   {flags.set(FF);}  |   
		Z   {flags.set(ZF);}  ;//niuxx
 
//S++,I++,A++ flags 
siaflags:SPP  {flags.set(SPPF);}  |
         IPP  {flags.set(IPPF);}  |
         APP  {flags.set(APPF2);} |
         SPP COMMA IPP	{flags.set(SPPF);flags.set(IPPF);}|
         IPP COMMA SPP	{flags.set(SPPF);flags.set(IPPF);}|
         SPP COMMA APP	{flags.set(SPPF);flags.set(APPF2);}|
         APP COMMA SPP	{flags.set(SPPF);flags.set(APPF2);}|
         IPP COMMA APP	{flags.set(IPPF);flags.set(APPF2);}|
         APP COMMA IPP	{flags.set(IPPF);flags.set(APPF2);}|
         SPP COMMA IPP COMMA APP	{flags.set(SPPF);flags.set(IPPF);flags.set(APPF2);}|
         SPP COMMA APP COMMA IPP	{flags.set(SPPF);flags.set(IPPF);flags.set(APPF2);}|
         IPP COMMA SPP COMMA APP	{flags.set(SPPF);flags.set(IPPF);flags.set(APPF2);}|
         IPP COMMA APP COMMA SPP	{flags.set(SPPF);flags.set(IPPF);flags.set(APPF2);}|
         APP COMMA SPP COMMA IPP 	{flags.set(SPPF);flags.set(IPPF);flags.set(APPF2);}|
         APP COMMA IPP COMMA SPP	{flags.set(SPPF);flags.set(IPPF);flags.set(APPF2);};//niuxx

disflag:      SHIFT  {flags.set(SHIFTF);} ;
                            
               
wflag:	       W0 {flags.set(W0F);}     |
               W1 {flags.set(W1F);}     |
               W2 {flags.set(W2F);}     |
               W3 {flags.set(W3F);}     |
               W4 {flags.set(W4F);}     ;    
 

configflag:   KM {flags.set(KMF);}     |
	      KG {flags.set(KGF);}     |
	      KE {flags.set(KEF);}     |
	      KMEABLE {flags.set(KMEABLEF);}     |
	      KGCURRENT {flags.set(KGCURRENTF);}     |
	      BR {flags.set(BRF);}     |
	      L1 {flags.set(L1F);}     |
	      L2 {flags.set(L2F);}     |
	      L3 {flags.set(L3F);}     |
	      L4 {flags.set(L4F);}     |
	      ALL {flags.set(ALLF);}     ;

configmrflag: MR0 {flags.set(MR0F);}     |
	      MR1 {flags.set(MR1F);}     |
	      MR2 {flags.set(MR2F);}     |
	      MR3 {flags.set(MR3F);}     |
	      MR4 {flags.set(MR4F);}     |
	      MR5 {flags.set(MR5F);}     |
	      ALL {flags.set(ALLF);}     |
	      ALL2 {flags.set(ALL2F);}     ;	
	      
configmwflag: MW0 {flags.set(MW0F);}     |
	      MW1 {flags.set(MW1F);}     |
	      MW2 {flags.set(MW2F);}     |
	      MW3 {flags.set(MW3F);}     |
	      MW4 {flags.set(MW4F);}     |
	      MW5 {flags.set(MW5F);}     |
	      ALL {flags.set(ALLF);}     |
	      ALL2 {flags.set(ALL2F);}     ;	 	      
    
configmflag:  KI1215 {flags.set(KI0F);} |
	      KI1619 {flags.set(KI1F);} |
	      KI2023 {flags.set(KI2F);} |
	      KI2427 {flags.set(KI3F);} |
	      KI1227 {flags.set(KI4F);} |
	      KI1618 {flags.set(KI5F);} |
	      KI2022 {flags.set(KI6F);} |
	      KI2426 {flags.set(KI7F);} ;
	      
//haoxb for configlatch	      
configlaflag: RP0    {flags.set(KR0F);} |    
              RP1    {flags.set(KR1F);} |	      
              RP2    {flags.set(KR2F);} |
              RP3    {flags.set(KR3F);} |	      
              RP4    {flags.set(KR4F);} |	      
              RP5    {flags.set(KR5F);} |	      
	      RP02   {flags.set(KR6F);} |
	      RP35   {flags.set(KR7F);} |
	      WP0    {flags.set(KW0F);} |
	      WP1    {flags.set(KW1F);} |
	      WP2    {flags.set(KW2F);} |
	      WP3    {flags.set(KW3F);} |
	      WP4    {flags.set(KW4F);} |
	      WFROMRP0   {flags.set(KFROM0F);} |
	      WFROMRP3   {flags.set(KFROM3F);} |
	      WPALL      {flags.set(KWPALLF);} |
	      RPALL      {flags.set(KRPALLF);} ;
	      
setcgflag:    ON    {flags.set(ONF);} |    
              OFF   {flags.set(OFFF);};	      
	      
	      
siflag :      S   {flags.set(SF);}  |
              I   {flags.set(IF);}  ;
              
abflag :      A   {flags.set(AF);}  |
              B   {flags.set(BF);}  ;

condflag:         {if(!isSetCond) {llvmerror(&@0,"must have (mode)!");clear();YYABORT;}
                   if(condpos) Operands[condpos-1].reset(OPERAND(Reg, UCPMReg::Mode0, @$.S, @$.E));}
          | MODE0 {
	      if(isSetCond) {llvmerror(&@0,"setcond do not have (mode)!");clear();YYABORT;}
	      if(condpos) Operands[condpos-1].reset(OPERAND(Reg, UCPMReg::Mode0, @$.S, @$.E));}
	  | MODE1 {
	      if(isSetCond) {llvmerror(&@0,"setcond do not have (mode)!");clear();YYABORT;}
	      if(condpos) Operands[condpos-1].reset(OPERAND(Reg, UCPMReg::Mode1, @$.S, @$.E));}
	  | NMODE0 {
	      if(isSetCond) {llvmerror(&@0,"setcond do not have (mode)!");clear();YYABORT;}
	      if(condpos) Operands[condpos-1].reset(OPERAND(Reg, UCPMReg::NMode0, @$.S, @$.E));}
	  | NMODE1 {
	      if(isSetCond) {llvmerror(&@0,"setcond do not have (mode)!");clear();YYABORT;}
	      if(condpos) Operands[condpos-1].reset(OPERAND(Reg, UCPMReg::NMode1, @$.S, @$.E));};

mfetchflag: CR  {flags.set(CRF);};
bflag: B {flags.set(BF);};
sflag: S {flags.set(SF);};

uncqflag:	U   {flags.set(UF);}  |
		N   {flags.set(NF);}  |
		CFLAG   {flags.set(CF);}  |
		Q   {flags.set(QF);}  ;

//kiflag: KI;
label: EXPR{$$=0;expr=$1;} | IMM5 {$$=$1;expr=0;};
interruptflag :    EI {flags.set(EIF);}    | 
		   DI {flags.set(DIF);}    ;

%%       
void clear(){
  tm = NULL;
  tn = NULL;
  tp = NULL;
  ts = NULL;
  tk = NULL;
  tl = NULL;//dcx
  ut = NULL;
  revt = NULL;
  ms = NULL;
  md = NULL;
  imm = NULL;
  imm1 = NULL;//dcx
  imm2 = NULL;//dcx
  f = NULL;
  ff = NULL;
  rf = NULL;
  shift = NULL;
  unit = NULL;
  unit2 = NULL;
  unit3 = NULL;
  unit4 = NULL;
  expr = NULL;
  b = NULL;
  b2 = NULL;
  opc = NULL;
  ipath = NULL;
  treg = NULL;
  qlh = NULL;
  step = NULL;
  sia = NULL;
  dis = NULL;//huhh
  oImacFlag = NULL;//yangl

  condpos = 0;
  FlagS = SMLoc();
  FlagE = SMLoc();
  isTnValid = true;//yangl
  isIMACABS = false;//yangl
  isTpValid = true;//yangl
  isTpMR = false;//yangl
  isTpMR_toMR = false;//yangl
  isIALUDoubleDest = false;//ducx
  isSHU0DoubleDest = false;//huhh
  isSHU1DoubleDest = false;//huhh
  isSHU2DoubleDest = false;//huhh
  imac_additional_dest = 0;//yangl
  imac_dest_return_value = -1;//yangl
  isSetCond = false;//ducx
  hasErr = false;//ducx
  flags.reset();//ducx
}
